import 'reflect-metadata';
import { IContainer, ResoveWay } from './IContainer';
import { Type, Token, Factory, SymbolType, ReferenceToken, RefTokenType, RefTokenFacType, RefTokenFac, Modules, LoadType, RefTarget, ClassType, ToInstance, InstanceFactory } from './types';
import { IParameter } from './IParameter';
import { ActionComponent } from './core';
import { IContainerBuilder } from './IContainerBuilder';
import { ResolverChain } from './resolves';
import { LifeScope } from './LifeScope';
import { ParamProviders, IProviderParser, ProviderTypes } from './providers';
import { IResolver } from './IResolver';
/**
 * Container
 *
 * @export
 * @class Container
 * @implements {IContainer}
 */
export declare class Container implements IContainer {
    parent: IContainer;
    children: IContainer[];
    /**
     * provide types.
     *
     * @protected
     * @type {Map<Token<any>, Type<any>>}
     * @memberof Container
     */
    protected provideTypes: Map<Token<any>, Type<any>>;
    /**
     * factories.
     *
     * @protected
     * @type {Map<Token<any>, Function>}
     * @memberof Container
     */
    protected factories: Map<Token<any>, InstanceFactory<any>>;
    constructor();
    readonly size: number;
    /**
     * get root container.
     *
     * @returns {IContainer}
     * @memberof Container
     */
    getRoot(): IContainer;
    private parser;
    getProviderParser(): IProviderParser;
    /**
     * get container builder.
     *
     * @returns {IContainerBuilder}
     * @memberof Container
     */
    getBuilder(): IContainerBuilder;
    /**
    * resolve token value in this container only.
    *
    * @template T
    * @param {Token<T>} token
    * @param {...ParamProviders[]} providers
    * @returns {T}
    * @memberof Container
    */
    getResolvers(): ResolverChain;
    /**
     * has register the token or not.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [aliasOrway]
     * @returns {boolean}
     * @memberof Container
     */
    has<T>(token: Token<T>, aliasOrway?: string | ResoveWay): boolean;
    /**
     * has register type.
     *
     * @template T
     * @param {Token<T>} key
     * @returns
     * @memberof Container
     */
    hasRegister<T>(key: Token<T>): boolean;
    /**
     * Retrieves an instance from the container based on the provided token.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    get<T>(token: Token<T>, alias?: string, ...providers: ParamProviders[]): T;
    /**
     * resolve type instance with token and param provider.
     *
     * @template T
     * @param {Token<T>} token
     * @param {T} [notFoundValue]
     * @param {...ParamProviders[]} providers
     * @memberof Container
     */
    resolve<T>(token: Token<T>, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T;
    /**
     * resolve first token when not null.
     *
     * @template T
     * @param {Token<T>[]} tokens
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    resolveFirst<T>(tokens: Token<T>[], ...providers: ParamProviders[]): T;
    /**
     * resolve token value in this container only.
     *
     * @template T
     * @param {Token<T>} token
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    resolveValue<T>(token: Token<T>, ...providers: ParamProviders[]): T;
    /**
     * get service or target reference service.
     *
     * @template T
     * @param {(Token<T> | Token<any>[])} token servive token.
     * @param {(RefTarget | RefTarget[])} [target] service refrence target.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    getService<T>(token: Token<T> | Token<any>[], target?: RefTarget | RefTarget[] | ParamProviders, toRefToken?: boolean | Token<T> | RefTokenFac<T> | ParamProviders, defaultToken?: boolean | Token<T> | ParamProviders, ...providers: ParamProviders[]): T;
    /**
     * get target reference service.
     *
     * @template T
     * @param {Type<Registration<T>>} [refToken] reference service Registration Injector
     * @param {RefTarget | RefTarget[]} target  the service reference to.
     * @param {Token<T>} [defaultToken] default service token.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    getRefService<T>(refToken: ReferenceToken<T>, target: RefTarget | RefTarget[], defaultToken?: Token<T> | Token<any>[], ...providers: ParamProviders[]): T;
    /**
     * get all service extends type and reference target.
     *
     * @template T
     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.
     * @param {(Token<any> | Token<any>[])} [target] service refrence target.
     * @param {(boolean|ParamProviders)} [both]
     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    getServices<T>(token: Token<T> | ((token: ClassType<T>) => boolean), target?: ResoveWay | Token<any> | Token<any>[] | ParamProviders, both?: boolean | ResoveWay | ParamProviders, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T[];
    /**
     * get all service extends type and reference target.
     *
     * @template T
     * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express
     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.
     * @param {(Token<any> | Token<any>[])} [target] service refrence target.
     * @param {(boolean|ParamProviders)} [both]
     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    iteratorServices<T>(express: (tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean, token: Token<T> | ((token: ClassType<T>) => boolean), target?: ResoveWay | Token<any> | Token<any>[] | ParamProviders, both?: boolean | ResoveWay | ParamProviders, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): void;
    /**
     * iterator all registered factory
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean} callbackfn
     * @param {ResoveWay} [resway= ResoveWay.all]
     * @memberof Container
     */
    iterator(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean, resway?: ResoveWay): void;
    /**
     * iterator.
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>) => void | boolean} callbackfn
     * @memberof IExports
     */
    forEach(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean): void | boolean;
    protected getRefToken<T>(ref: RefTokenFacType<T>, tk: Token<any>): RefTokenType<T> | RefTokenType<T>[];
    protected resolveRef<T>(refToken: RefTokenType<T>, target: Token<any>, ...providers: ParamProviders[]): T;
    /**
     * get tocken key.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @returns {SymbolType<T>}
     * @memberof Container
     */
    getTokenKey<T>(token: Token<T>, alias?: string): SymbolType<T>;
    /**
     * register type.
     * @abstract
     * @template T
     * @param {Token<T>} token
     * @param {T} [value]
     * @returns {this}
     * @memberOf Container
     */
    register<T>(token: Token<T>, value?: Factory<T>): this;
    /**
     * register stingleton type.
     * @abstract
     * @template T
     * @param {Token<T>} token
     * @param {Factory<T>} [value]
     * @returns {this}
     * @memberOf Container
     */
    registerSingleton<T>(token: Token<T>, value?: Factory<T>): this;
    /**
     * register value.
     *
     * @template T
     * @param {Token<T>} token
     * @param {T} value
     * @returns {this}
     * @memberof Container
     */
    registerValue<T>(token: Token<T>, value: T): this;
    /**
     * bind provider.
     *
     * @template T
     * @param {Token<T>} provide
     * @param {Token<T>} provider
     * @returns {this}
     * @memberof Container
     */
    bindProvider<T>(provide: Token<T>, provider: Token<T> | Factory<T>): this;
    /**
     * bind providers for only target class.
     *
     * @param {Token<any>} target
     * @param {ParamProviders[]} providers
     * @param {(mapTokenKey: Token<any>) => void} [onceBinded]
     * @returns {this}
     * @memberof Container
     */
    bindProviders(target?: Token<any> | ProviderTypes, onceBinded?: ProviderTypes | ((mapTokenKey: Token<any>) => void), ...providers: ProviderTypes[]): this;
    /**
     * bind provider ref to target.
     *
     * @template T
     * @param {Token<any>} target
     * @param {Token<T>} provide
     * @param {(Token<T> | Factory<T>)} provider
     * @param {string} [alias]
     * @param {(refToken: Token<T>) => void} [onceBinded]
     * @returns {this}
     * @memberof Container
     */
    bindRefProvider<T>(target: Token<any>, provide: Token<T>, provider: Token<T> | Factory<T>, alias?: string, onceBinded?: (refToken: Token<T>) => void): this;
    unregisterValue<T>(token: Token<T>): this;
    /**
     * unregister the token
     *
     * @template T
     * @param {Token<T>} token
     * @param {ResoveWay} [resway]
     * @returns {this}
     * @memberof Container
     */
    unregister<T>(token: Token<T>, resway?: ResoveWay): this;
    /**
     * clear cache.
     *
     * @param {Type<any>} targetType
     * @memberof IContainer
     */
    clearCache(targetType: Type<any>): void;
    /**
     * get token.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @returns {Token<T>}
     * @memberof Container
     */
    getToken<T>(token: Token<T>, alias?: string): Token<T>;
    getTokenProvider<T>(token: Token<T>): Type<T>;
    /**
     * get token implements class type.
     *
     * @template T
     * @param {Token<T>} token
     * @param {boolean} [inchain]
     * @returns {Type<T>}
     * @memberof Container
     */
    getTokenImpl<T>(token: Token<T>, resway?: ResoveWay): Type<T>;
    /**
     * iterate token  in  token class chain.  return false will break iterate.
     *
     * @param {RefTarget} target
     * @param {(token: Token<any>) => boolean} express
     * @memberof Container
     */
    forInRefTarget(target: RefTarget, express: (token: Token<any>) => boolean): void;
    /**
     * get token implement class and base classes.
     *
     * @param {Token<any>} token
     * @returns {Token<any>[]}
     * @memberof Container
     */
    getTokenClassChain(token: Token<any>, chain?: boolean): Token<any>[];
    /**
    * get life scope of container.
    *
    * @returns {LifeScope}
    * @memberof IContainer
    */
    getLifeScope(): LifeScope;
    /**
     * use modules.
     *
     * @param {...Modules[]} modules
     * @returns {this}
     * @memberof Container
     */
    use(...modules: Modules[]): this;
    /**
     * async use modules.
     *
     * @param {...LoadType[]} modules load modules.
     * @returns {Promise<Type<any>[]>}  types loaded.
     * @memberof IContainer
     */
    loadModule(...modules: LoadType[]): Promise<Type<any>[]>;
    /**
     * invoke method async.
     *
     * @template T
     * @param {any} target
     * @param {string} propertyKey
     * @param {*} [instance]
     * @param {...ParamProviders[]} providers
     * @returns {Promise<T>}
     * @memberof Container
     */
    invoke<T>(target: any, propertyKey: string, instance?: any, ...providers: ParamProviders[]): Promise<T>;
    /**
     * invoke method.
     *
     * @template T
     * @param {any} target
     * @param {string} propertyKey
     * @param {*} [instance]
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    syncInvoke<T>(target: Token<any>, propertyKey: string, instance?: any, ...providers: ParamProviders[]): T;
    createSyncParams(params: IParameter[], ...providers: ParamProviders[]): any[];
    createParams(params: IParameter[], ...providers: ParamProviders[]): Promise<any[]>;
    protected cacheDecorator<T>(map: Map<string, ActionComponent>, action: ActionComponent): void;
    protected init(): void;
    protected getSingleton(): Map<Token<any>, any>;
    protected registerFactory<T>(token: Token<T>, value?: Factory<T>, singleton?: boolean): void;
    protected createCustomFactory<T>(key: SymbolType<T>, factory?: ToInstance<T>, singleton?: boolean): (...providers: ParamProviders[]) => any;
    protected bindTypeFactory<T>(key: SymbolType<T>, ClassT?: Type<T>, singleton?: boolean): void;
    static getClassAnnations(): any;
}
