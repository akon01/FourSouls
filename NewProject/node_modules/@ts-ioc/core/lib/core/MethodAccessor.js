"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var actions_1 = require("./actions");
var utils_1 = require("../utils");
var providers_1 = require("../providers");
/**
 * method accessor
 *
 * @export
 * @class MethodAccessor
 * @implements {IMethodAccessor}
 */
var MethodAccessor = /** @class */ (function () {
    function MethodAccessor(container) {
        this.container = container;
    }
    MethodAccessor.prototype.invoke = function (target, propertyKey, instance) {
        var providers = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            providers[_i - 3] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, targetClass, actionData, lifeScope, parameters, paramInstances;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (providers_1.isProvider(instance)) {
                            providers.unshift(instance);
                            instance = undefined;
                        }
                        if (utils_1.isToken(target)) {
                            if (utils_1.isNullOrUndefined(instance)) {
                                targetClass = this.container.getTokenImpl(target);
                                instance = (_a = this.container).resolve.apply(_a, [target].concat(providers));
                            }
                            else {
                                targetClass = utils_1.lang.getClass(instance) || this.container.getTokenImpl(target);
                            }
                            utils_1.lang.assert(targetClass, target.toString() + ' is not implements by any class.');
                        }
                        else {
                            targetClass = utils_1.lang.getClass(target);
                            instance = target;
                        }
                        utils_1.lang.assertExp(instance && utils_1.isFunction(instance[propertyKey]), "type: " + targetClass + " has no method " + propertyKey.toString() + ".");
                        actionData = {
                            target: instance,
                            targetType: targetClass,
                            propertyKey: propertyKey,
                        };
                        lifeScope = this.container.getLifeScope();
                        lifeScope.execute(actionData, actions_1.LifeState.onInit, actions_1.CoreActions.bindParameterProviders);
                        providers = providers.concat(actionData.execResult);
                        parameters = lifeScope.getMethodParameters(targetClass, instance, propertyKey);
                        return [4 /*yield*/, this.createParams.apply(this, [parameters].concat(providers))];
                    case 1:
                        paramInstances = _b.sent();
                        return [2 /*return*/, instance[propertyKey].apply(instance, paramInstances)];
                }
            });
        });
    };
    MethodAccessor.prototype.syncInvoke = function (target, propertyKey, instance) {
        var providers = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            providers[_i - 3] = arguments[_i];
        }
        var _a;
        var targetClass;
        if (providers_1.isProvider(instance)) {
            providers.unshift(instance);
            instance = undefined;
        }
        if (utils_1.isToken(target)) {
            targetClass = this.container.getTokenImpl(target);
            utils_1.lang.assert(targetClass, target.toString() + ' is not implements by any class.');
            if (utils_1.isNullOrUndefined(instance)) {
                instance = (_a = this.container).resolve.apply(_a, [target].concat(providers));
            }
        }
        else {
            targetClass = utils_1.lang.getClass(target);
            instance = target;
        }
        utils_1.lang.assertExp(instance && utils_1.isFunction(instance[propertyKey]), "type: " + targetClass + " has no method " + propertyKey.toString() + ".");
        var actionData = {
            target: instance,
            targetType: targetClass,
            propertyKey: propertyKey,
        };
        var lifeScope = this.container.getLifeScope();
        lifeScope.execute(actionData, actions_1.LifeState.onInit, actions_1.CoreActions.bindParameterProviders);
        providers = providers.concat(actionData.execResult);
        var parameters = lifeScope.getMethodParameters(targetClass, instance, propertyKey);
        var paramInstances = this.createSyncParams.apply(this, [parameters].concat(providers));
        return instance[propertyKey].apply(instance, paramInstances);
    };
    MethodAccessor.prototype.createSyncParams = function (params) {
        var _this = this;
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        var _a;
        var providerMap = (_a = this.container.getProviderParser()).parse.apply(_a, providers);
        return params.map(function (param, index) {
            if (param.name && providerMap.has(param.name)) {
                return providerMap.resolve(param.name);
            }
            else if (utils_1.isToken(param.type)) {
                if (providerMap.has(param.type)) {
                    return providerMap.resolve(param.type);
                }
                return _this.container.resolve(param.type, providerMap);
            }
            else {
                return undefined;
            }
        });
    };
    MethodAccessor.prototype.createParams = function (params) {
        var _this = this;
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        var _a;
        var providerMap = (_a = this.container.getProviderParser()).parse.apply(_a, providers);
        return Promise.all(params.map(function (param, index) {
            if (param.name && providerMap.has(param.name)) {
                return providerMap.resolve(param.name);
            }
            else if (utils_1.isToken(param.type)) {
                if (providerMap.has(param.type)) {
                    return providerMap.resolve(param.type);
                }
                return _this.container.resolve(param.type, providerMap);
            }
            else {
                return undefined;
            }
        }));
    };
    MethodAccessor.getClassAnnations = function () {
        return { "name": "MethodAccessor", "params": { "constructor": ["container"], "invoke": ["target", "propertyKey", "instance", "providers"], "syncInvoke": ["target", "propertyKey", "instance", "providers"], "createSyncParams": ["params", "providers"], "createParams": ["params", "providers"] } };
    };
    return MethodAccessor;
}());
exports.MethodAccessor = MethodAccessor;

//# sourceMappingURL=../sourcemaps/core/MethodAccessor.js.map
