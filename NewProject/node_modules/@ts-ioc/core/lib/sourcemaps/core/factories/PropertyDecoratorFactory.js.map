{"version":3,"sources":["core/factories/PropertyDecoratorFactory.ts"],"names":[],"mappings":";;AACA,uDAAuF;AACvF,iDAAgD;AAChD,qCAAyD;AA6BzD;;;;;;;;;GASG;AACH,SAAgB,mBAAmB,CAA6B,IAAY,EAAE,OAAyB,EAAE,eAAoC;IACzI,IAAI,eAAe,GAAG,CAAC,UAAC,IAAkB;QACtC,IAAI,OAAO,EAAE;YACT,OAAO,CAAC,IAAI,CAAC,CAAC;SACjB;QACD,IAAI,CAAC,IAAI,CAAI;YACT,UAAU,EAAE,UAAC,GAAG,IAAK,OAAA,yBAAiB,CAAC,GAAG,CAAC,EAAtB,CAAsB;YAC3C,KAAK,EAAE,UAAC,GAAG,IAAK,OAAA,eAAO,CAAC,GAAG,CAAC,EAAZ,CAAY;YAC5B,WAAW,EAAE,UAAC,QAAQ,EAAE,GAAG;gBACvB,QAAQ,CAAC,QAAQ,GAAG,GAAG,CAAC;YAC5B,CAAC;SACJ,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;IACH,IAAI,SAAS,GAAG,kCAAe,CAAI,IAAI,EAAE,eAAe,EAAE,eAAe,CAAC,CAAC;IAC3E,SAAS,CAAC,aAAa,GAAG,6BAAa,CAAC,QAAQ,CAAC;IACjD,OAAO,SAAS,CAAC;AACrB,CAAC;AAhBD,kDAgBC","file":"../../../core/factories/PropertyDecoratorFactory.js","sourcesContent":["import { PropertyMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { isToken, isProvideMetadata } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { Token } from '../../types';\r\n\r\n/**\r\n * property decorator.\r\n *\r\n * @export\r\n * @interface IPropertyDecorator\r\n */\r\nexport interface IPropertyDecorator<T extends PropertyMetadata> {\r\n    /**\r\n     * define property decorator with param.\r\n     *\r\n     * @param {Token<T>} provider define provider to resolve value to the property.\r\n     */\r\n    (provider: Token<any>): PropertyDecorator;\r\n    /**\r\n     * define property decorator with metadata map.\r\n     * @param {T} [metadata] define matadata map to resolve value to the property.\r\n     */\r\n    (metadata?: T): PropertyDecorator;\r\n    /**\r\n     * define property decorator.\r\n     */\r\n    (target: object, propertyKey: string | symbol): void;\r\n}\r\n\r\n\r\n/**\r\n * create property decorator.\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns\r\n */\r\nexport function createPropDecorator<T extends PropertyMetadata>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): IPropertyDecorator<T> {\r\n    let propPropAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            isMetadata: (arg) => isProvideMetadata(arg),\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provider = arg;\r\n            }\r\n        });\r\n    });\r\n    let decorator = createDecorator<T>(name, propPropAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Property;\r\n    return decorator;\r\n}\r\n\r\n"]}