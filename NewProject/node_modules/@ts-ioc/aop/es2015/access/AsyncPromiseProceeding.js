"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@ts-ioc/core");
const IAdvisorProceeding_1 = require("./IAdvisorProceeding");
const ReturningType_1 = require("./ReturningType");
const NonePointcut_1 = require("../decorators/NonePointcut");
let AsyncPromiseProceeding = class AsyncPromiseProceeding {
    constructor() {
    }
    proceeding(joinPoint, ...actions) {
        if (joinPoint.returning) {
            actions.forEach((action => {
                joinPoint.returning = joinPoint.returning.then((val) => {
                    joinPoint.returningValue = val;
                    return Promise.resolve(action(joinPoint))
                        .then(() => {
                        return joinPoint.returningValue;
                    });
                });
            }));
        }
    }
    static getClassAnnations() {
        return { "name": "AsyncPromiseProceeding", "params": { "constructor": [], "proceeding": ["joinPoint", "actions"] } };
    }
};
AsyncPromiseProceeding = tslib_1.__decorate([
    NonePointcut_1.NonePointcut(),
    core_1.Singleton(IAdvisorProceeding_1.AdvisorProceedingToken, ReturningType_1.ReturningType.promise),
    tslib_1.__metadata("design:paramtypes", [])
], AsyncPromiseProceeding);
exports.AsyncPromiseProceeding = AsyncPromiseProceeding;

//# sourceMappingURL=../sourcemaps/access/AsyncPromiseProceeding.js.map
