{"version":3,"sources":["IContainer.ts"],"names":[],"mappings":";;AAMA,6CAA4C;AAM5C;;;GAGG;AACU,QAAA,cAAc,GAAG,IAAI,yBAAW,CAAa,eAAe,CAAC,CAAC;AAE3E;;;;;GAKG;AACH,IAAY,SAyBX;AAzBD,WAAY,SAAS;IACjB;;OAEG;IACH,+CAAW,CAAA;IACX;;OAEG;IACH,iDAAiB,CAAA;IACjB;;OAEG;IACH,6CAAe,CAAA;IACf;;OAEG;IACH,2CAA0B,CAAA;IAC1B;;OAEG;IACH,+CAA0B,CAAA;IAC1B;;OAEG;IACH,uCAAiC,CAAA;AACrC,CAAC,EAzBW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAyBpB","file":"../IContainer.js","sourcesContent":["import {\r\n    Type, Token, Factory, SymbolType, Modules,\r\n    LoadType, ReferenceToken, RefTokenFac, RefTarget, ClassType, InstanceFactory\r\n} from './types';\r\nimport { IMethodAccessor } from './IMethodAccessor';\r\nimport { LifeScope } from './LifeScope';\r\nimport { InjectToken } from './InjectToken';\r\nimport { IContainerBuilder } from './IContainerBuilder';\r\nimport { IResolver, IResolverContainer } from './IResolver';\r\nimport { ResolverChain } from './resolves';\r\nimport { ParamProviders, IProviderParser, ProviderTypes } from './providers';\r\n\r\n/**\r\n * IContainer token.\r\n * it is a symbol id, you can use  @Inject, @Autowried or @Param to get container instance in yourself class.\r\n */\r\nexport const ContainerToken = new InjectToken<IContainer>('DI_IContainer');\r\n\r\n/**\r\n * resove way\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum ResoveWay {\r\n    /**\r\n     * current container.\r\n     */\r\n    current = 1,\r\n    /**\r\n     * traverse all curr node children.\r\n     */\r\n    traverse = 1 << 1,\r\n    /**\r\n     * bubble up all parent.\r\n     */\r\n    bubble = 1 << 2,\r\n    /**\r\n     * current and children.\r\n     */\r\n    nodes = current | traverse,\r\n    /**\r\n     * current and bubble.\r\n     */\r\n    routeup = current | bubble,\r\n    /**\r\n     *  traverse of curr node, children.\r\n     */\r\n    all = current | traverse | bubble\r\n}\r\n\r\n/**\r\n * container interface.\r\n *\r\n * @export\r\n * @interface IContainer\r\n */\r\nexport interface IContainer extends IMethodAccessor, IResolverContainer {\r\n\r\n    /**\r\n     * get or set parent container.\r\n     *\r\n     * @type {IContainer}\r\n     * @memberof IContainer\r\n     */\r\n    parent: IContainer;\r\n\r\n    /**\r\n     * children containers.\r\n     *\r\n     * @returns {IContainer[]}\r\n     * @memberof IContainer\r\n     */\r\n    children: IContainer[];\r\n\r\n    /**\r\n     * get root container.\r\n     *\r\n     * @returns {IContainer}\r\n     * @memberof IContainer\r\n     */\r\n    getRoot(): IContainer;\r\n\r\n    /**\r\n     * get provider parser.\r\n     *\r\n     * @returns {IProviderParser}\r\n     * @memberof IContainer\r\n     */\r\n    getProviderParser(): IProviderParser;\r\n\r\n    /**\r\n     * resolve chain.\r\n     *\r\n     * @type {ResolverChain}\r\n     * @memberof IContainer\r\n     */\r\n    getResolvers(): ResolverChain;\r\n\r\n    /**\r\n     * get container builder of this container.\r\n     *\r\n     * @returns {IContainerBuilder}\r\n     * @memberof IContainer\r\n     */\r\n    getBuilder(): IContainerBuilder;\r\n\r\n    /**\r\n     * current container has register.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} key\r\n     * @returns {boolean}\r\n     * @memberof IContainer\r\n     */\r\n    hasRegister<T>(key: Token<T>): boolean;\r\n\r\n    /**\r\n     * Retrieves an instance from the container based on the provided token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    get<T>(token: Token<T>, alias?: string, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * resolve token value in this container only.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    resolveValue<T>(token: Token<T>, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * resolve first token when not null.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>[]} tokens\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    resolveFirst<T>(tokens: Token<any>[], ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {(RefTarget | RefTarget[])} [target] service refrence target.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], target: RefTarget | RefTarget[], ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {(RefTarget | RefTarget[])} [target] service refrence target.\r\n     * @param {RefTokenFac<T>} toRefToken\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], target: RefTarget | RefTarget[], toRefToken: RefTokenFac<T>, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {(RefTarget | RefTarget[])} [target] service refrence target.\r\n     * @param {(boolean | Token<T>)} defaultToken\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], target: RefTarget | RefTarget[], defaultToken: boolean | Token<T>, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {(RefTarget | RefTarget[])} [target] service refrence target.\r\n     * @param {RefTokenFac<T>} toRefToken\r\n     * @param {(boolean | Token<T>)} defaultToken\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], target: RefTarget | RefTarget[], toRefToken: RefTokenFac<T>, defaultToken: boolean | Token<T>, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get target reference service.\r\n     *\r\n     * @template T\r\n     * @param {ReferenceToken<T>} [refToken] reference service Registration Injector\r\n     * @param {(RefTarget | RefTarget[])} target  the service reference to.\r\n     * @param {Token<T>} [defaultToken] default service token.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getRefService<T>(refToken: ReferenceToken<T>, target: RefTarget | RefTarget[], defaultToken?: Token<T> | Token<any>[], ...providers: ParamProviders[]): T\r\n\r\n    /**\r\n     * get all service extends type.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n     * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getServices<T>(type: ClassType<T> | ((token: ClassType<T>) => boolean), resway?: ResoveWay, ...providers: ParamProviders[]): T[];\r\n\r\n    /**\r\n    * get all private services of target extends class `type`.\r\n    * @template T\r\n    * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n    * @param {(ClassType<any> | ClassType<any>[])} [target] service private of target.\r\n    * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n    * @param {...ParamProviders[]} providers\r\n    * @returns {T}\r\n    * @memberof IContainer\r\n    */\r\n    getServices<T>(type: Token<T> | ((token: ClassType<T>) => boolean), target: Token<any> | Token<any>[], resway?: ResoveWay, ...providers: ParamProviders[]): T[];\r\n\r\n    /**\r\n    * get all servies extends class `type` and all private services of target extends class `type`.\r\n    *\r\n    * @template T\r\n    * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n    * @param {(ClassType<any> | ClassType<any>[])} [target] service private of target.\r\n    * @param {boolean} both if true, will get all server and target private service of class extends `type` .\r\n    * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n    * @param {...ParamProviders[]} providers\r\n    * @returns {T}\r\n    * @memberof IContainer\r\n    */\r\n    getServices<T>(type: Token<T> | ((token: ClassType<T>) => boolean), target: Token<any> | Token<any>[], both: boolean, resway?: ResoveWay, ...providers: ParamProviders[]): T[];\r\n\r\n\r\n    /**\r\n     * iterator all service extends type.\r\n     *\r\n     * @template T\r\n     * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express\r\n     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n     * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    iteratorServices<T>(\r\n        express: (tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean,\r\n        type: ClassType<T> | ((token: ClassType<T>) => boolean),\r\n        resway?: ResoveWay,\r\n        ...providers: ParamProviders[]): void;\r\n\r\n    /**\r\n    * iterator all private services of target extends class `type`.\r\n    * @template T\r\n    * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express\r\n    * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n    * @param {(ClassType<any> | ClassType<any>[])} [target] service private of target.\r\n    * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n    * @param {...ParamProviders[]} providers\r\n    * @returns {T}\r\n    * @memberof IContainer\r\n    */\r\n    iteratorServices<T>(\r\n        express: (tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean,\r\n        type: Token<T> | ((token: ClassType<T>) => boolean),\r\n        target: Token<any> | Token<any>[],\r\n        resway?: ResoveWay,\r\n        ...providers: ParamProviders[]): void;\r\n\r\n    /**\r\n    * iterator all servies extends class `type` and all private services of target extends class `type`.\r\n    *\r\n    * @template T\r\n    * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express\r\n    * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n    * @param {(ClassType<any> | ClassType<any>[])} [target] service private of target.\r\n    * @param {boolean} both if true, will get all server and target private service of class extends `type` .\r\n    * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n    * @param {...ParamProviders[]} providers\r\n    * @returns {T}\r\n    * @memberof IContainer\r\n    */\r\n    iteratorServices<T>(\r\n        express: (tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean,\r\n        type: Token<T> | ((token: ClassType<T>) => boolean),\r\n        target: Token<any> | Token<any>[],\r\n        both: boolean,\r\n        resway?: ResoveWay,\r\n        ...providers: ParamProviders[]): void;\r\n\r\n\r\n    /**\r\n     * register type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {Factory<T>} [value]\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    register<T>(token: Token<T>, value?: Factory<T>): this;\r\n\r\n    /**\r\n     * register stingleton type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {Factory<T>} value\r\n     * @returns {this}\r\n     * @memberOf IContainer\r\n     */\r\n    registerSingleton<T>(token: Token<T>, value?: Factory<T>): this;\r\n\r\n    /**\r\n     * register value.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} value\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    registerValue<T>(token: Token<T>, value: T): this;\r\n\r\n    /**\r\n     * unregister value.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    unregisterValue<T>(token: Token<T>): this;\r\n\r\n    /**\r\n     * bind provider\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} provide\r\n     * @param {Token<T> | Factory<T>} provider\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindProvider<T>(provide: Token<T>, provider: Token<T> | Factory<T>): this;\r\n\r\n    /**\r\n     * bind providers.\r\n     *\r\n     * @param {...ProviderTypes[]} providers\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindProviders(...providers: ProviderTypes[]): this;\r\n\r\n    /**\r\n     * bind providers for only target class.\r\n     *\r\n     * @param {Token<any>} target\r\n     * @param {...ProviderTypes[]} providers\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindProviders<T>(target: Token<T>, ...providers: ProviderTypes[]): this;\r\n\r\n    /**\r\n     * bind providers for only target class.\r\n     *\r\n     * @param {Token<any>} target\r\n     * @param {(mapTokenKey: Token<any>) => void} onceBinded\r\n     * @param {...ProviderTypes[]} providers\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindProviders<T>(target: Token<T>, onceBinded: (mapTokenKey: Token<any>) => void, ...providers: ProviderTypes[]): this;\r\n\r\n    /**\r\n     * bind provider ref to target.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>} target\r\n     * @param {Token<T>} provide\r\n     * @param {(Token<T> | Factory<T>)} provider\r\n     * @param {string} [alias]\r\n     * @param {(refToken: Token<T>) => void} [onceBinded]\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindRefProvider<T>(target: Token<any>, provide: Token<T>, provider: Token<T> | Factory<T>, alias?: string, onceBinded?: (refToken: Token<T>) => void): this;\r\n\r\n    /**\r\n     * clear cache.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @memberof IContainer\r\n     */\r\n    clearCache(targetType: Type<any>);\r\n\r\n    /**\r\n     * get token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} target\r\n     * @param {string} [alias]\r\n     * @returns {Token<T>}\r\n     * @memberof IContainer\r\n     */\r\n    getToken<T>(target: Token<T>, alias?: string): Token<T>;\r\n\r\n    /**\r\n     * get tocken key.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {SymbolType<T>}\r\n     * @memberof IContainer\r\n     */\r\n    getTokenKey<T>(token: Token<T>, alias?: string): SymbolType<T>;\r\n\r\n    /**\r\n     * get token provider.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @returns {Type<T>}\r\n     * @memberof IContainer\r\n     */\r\n    getTokenProvider<T>(token: Token<T>): Type<T>;\r\n\r\n    /**\r\n     * iterate token  in  token class chain.  return false will break iterate.\r\n     *\r\n     * @param {RefTarget} target\r\n     * @param {(token: Token<any>, classProviders?: Token<any>[]) => boolean} express\r\n     * @memberof IContainer\r\n     */\r\n    forInRefTarget(target: RefTarget, express: (token: Token<any>, classProviders?: Token<any>[]) => boolean): void;\r\n\r\n    /**\r\n     * get token implement class and base classes.\r\n     *\r\n     * @param {Token<any>} token\r\n     * @param {boolean} [chain] get all base classes or only impletment class. default true.\r\n     * @returns {Token<any>[]}\r\n     * @memberof IContainer\r\n     */\r\n    getTokenClassChain(token: Token<any>, chain?: boolean): Token<any>[];\r\n\r\n    /**\r\n     * get life scope of container.\r\n     *\r\n     * @returns {LifeScope}\r\n     * @memberof IContainer\r\n     */\r\n    getLifeScope(): LifeScope;\r\n\r\n    /**\r\n     * use modules.\r\n     *\r\n     * @param {...Modules[]} modules\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    use(...modules: Modules[]): this;\r\n\r\n    /**\r\n     * load modules.\r\n     *\r\n     * @param {...LoadType[]} modules load modules.\r\n     * @returns {Promise<Type<any>[]>}  types loaded.\r\n     * @memberof IContainer\r\n     */\r\n    loadModule(...modules: LoadType[]): Promise<Type<any>[]>;\r\n\r\n    /**\r\n     * iterator all resovlers.\r\n     *\r\n     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean} callbackfn if callbackfn return false will break iterator.\r\n     * @param {boolean} [bubble=true]\r\n     * @memberof IContainer\r\n     */\r\n    iterator(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean, resway?: ResoveWay): void | boolean;\r\n\r\n}\r\n"]}