'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib_1 = _interopDefault(require('tslib'));
var reflectMetadata = _interopDefault(require('reflect-metadata'));

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var lang_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

// use core-js in browser.
/**
 * map base.
 *
 * @export
 * @class MapBase
 * @template K
 * @template V
 */
class MapBase {
    constructor() {
        this.map = new Map();
    }
    get size() {
        return this.map.size;
    }
    clear() {
        this.map.clear();
    }
    delete(key) {
        return this.map.delete(key);
    }
    get(key) {
        return this.map.get(key);
    }
    has(key) {
        return this.map.has(key);
    }
    set(key, value) {
        this.map.set(key, value);
        return this;
    }
    keys() {
        return Array.from(this.map.keys());
    }
    values() {
        return Array.from(this.map.values());
    }
    static getClassAnnations() {
        return { "name": "MapBase", "params": { "constructor": [], "clear": [], "delete": ["key"], "get": ["key"], "has": ["key"], "set": ["key", "value"], "keys": [], "values": [] } };
    }
}
exports.MapBase = MapBase;
/**
 * map set  for tsioc old version.
 *
 * @export
 * @class MapSet
 * @template K
 * @template V
 */
class MapSet extends MapBase {
    constructor() {
        super();
    }
    forEach(callbackfn, thisArg) {
        this.map.forEach(callbackfn, thisArg);
    }
    static getClassAnnations() {
        return { "name": "MapSet", "params": { "constructor": [], "forEach": ["callbackfn", "thisArg"] } };
    }
}
exports.MapSet = MapSet;
/**
 * lang utils
 */
var lang;
(function (lang) {
    /**
     * assert param is right or not.
     *
     * @export
     * @param {*} param
     * @param {(string | Function)} msg
     */
    function assert(param, msg) {
        if (typeCheck.isNullOrUndefined(param)) {
            throw new Error(typeCheck.isFunction(msg) ? msg(param) : msg);
        }
    }
    lang.assert = assert;
    /**
     * check assert param invalid by express
     *
     * @export
     * @param {(boolean | (() => boolean))} express
     * @param {(string | Function)} msg
     */
    function assertExp(express, msg) {
        if (!(typeCheck.isFunction(express) ? express() : express)) {
            throw new Error(typeCheck.isFunction(msg) ? msg() : msg);
        }
    }
    lang.assertExp = assertExp;
    /**
     * get object keys.
     *
     * @param {*} target
     * @returns {string[]}
     */
    function keys(target) {
        if (typeCheck.isObject(target)) {
            if (typeCheck.isFunction(Object.keys)) {
                return Object.keys(target);
            }
        }
        return [];
    }
    lang.keys = keys;
    /**
     * values of target object.
     *
     * @export
     * @param {*} target
     * @returns {any[]}
     */
    function values(target) {
        if (typeCheck.isObject(target)) {
            if (typeCheck.isFunction(Object.values)) {
                return Object.values(target);
            }
            else {
                return keys(target).map(n => target[n]);
            }
        }
        return [];
    }
    lang.values = values;
    /**
     * assign
     *
     * @export
     * @template T
     * @param {T} target
     * @param {...any[]} source
     * @returns {T}
     */
    function assign(target, source1, source2, sources) {
        if (sources && sources.length) {
            sources.unshift(source2 || {});
            sources.unshift(source1 || {});
            return Object.assign(target, ...sources);
        }
        else if (source2) {
            return Object.assign(target, source1 || {}, source2);
        }
        else {
            return Object.assign(target, source1 || {});
        }
    }
    lang.assign = assign;
    /**
     * create an new object from target object omit some field.
     *
     * @export
     * @param {ObjectMap<any>} target
     * @param {...string[]} fields
     * @returns {*}
     */
    function omit(target, ...fields) {
        if (typeCheck.isObject(target)) {
            let result = {};
            keys(target).forEach(key => {
                if (fields.indexOf(key) < 0) {
                    result[key] = target[key];
                }
            });
            return result;
        }
        else {
            return target;
        }
    }
    lang.omit = omit;
    /**
     * object has field or not.
     *
     * @export
     * @param {ObjectMap<any>} target
     * @returns
     */
    function hasField(target) {
        return keys(target).length > 0;
    }
    lang.hasField = hasField;
    /**
     * for in opter for object or array.
     *
     * @export
     * @template T
     * @param {(ObjectMap<T> | T[])} target
     * @param {(item: T, idx?: number|string) => void|boolean} iterator
     */
    function forIn(target, iterator) {
        if (typeCheck.isArray(target)) {
            target.some((it, idx) => iterator(it, idx) === false);
        }
        else if (typeCheck.isObject(target)) {
            keys(target).some((key, idx) => iterator(target[key], key) === false);
        }
    }
    lang.forIn = forIn;
    /**
     * find
     *
     * @template T
     * @param {(ObjectMap<T> | T[])} target
     * @param {((item: T, idx?: number | string) => boolean)} express
     */
    function find(target, express) {
        let item;
        forIn(target, (it, idx) => {
            if (!item) {
                if (express(it, idx)) {
                    item = it;
                    return false;
                }
                return true;
            }
            else {
                return true;
            }
        });
    }
    lang.find = find;
    /**
     * first.
     *
     * @export
     * @template T
     * @param {T[]} list
     * @returns {T}
     */
    function first(list) {
        if (typeCheck.isArray(list) && list.length) {
            return list[0];
        }
        return null;
    }
    lang.first = first;
    /**
     * last.
     *
     * @export
     * @template T
     * @param {T[]} list
     * @returns {T}
     */
    function last(list) {
        if (typeCheck.isArray(list) && list.length) {
            return list[list.length - 1];
        }
        return null;
    }
    lang.last = last;
    /**
     * get class annations.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns
     */
    function getClassAnnations(target) {
        return typeCheck.isFunction(target.getClassAnnations) ? target.getClassAnnations() : target.classAnnations;
    }
    lang.getClassAnnations = getClassAnnations;
    /**
     * target has class annations or not.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {boolean}
     */
    function hasClassAnnations(target) {
        if (typeCheck.isFunction(target.getClassAnnations)) {
            return true;
        }
        return target.classAnnations && typeCheck.isString(target.classAnnations.name) && target.classAnnations.name.length > 0;
    }
    lang.hasClassAnnations = hasClassAnnations;
    /**
     * get calss of object.
     *
     * @export
     * @param {*} target
     * @returns {Type<any>}
     */
    function getClass(target) {
        if (typeCheck.isNullOrUndefined(target)) {
            return null;
        }
        if (typeCheck.isClass(target)) {
            return target;
        }
        return target.constructor || target.prototype.constructor;
    }
    lang.getClass = getClass;
    /**
     * get class name.
     *
     * @export
     * @param {AbstractType<any>} target
     * @returns {string}
     */
    function getClassName(target) {
        let classType = typeCheck.isFunction(target) ? target : getClass(target);
        if (!typeCheck.isFunction(classType)) {
            return '';
        }
        if (/^[a-z]$/.test(classType.name)) {
            let classAnnations = getClassAnnations(classType);
            return classAnnations ? classAnnations.name : classType.name;
        }
        return classType.name;
    }
    lang.getClassName = getClassName;
    /**
     * get target type parent class.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {ClassType<any>}
     */
    function getParentClass(target) {
        let p = Reflect.getPrototypeOf(target.prototype);
        return typeCheck.isClass(p) ? p : p.constructor;
    }
    lang.getParentClass = getParentClass;
    /**
     * get all parent class in chain.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {ClassType<any>[]}
     */
    function getClassChain(target) {
        let types = [];
        forInClassChain(target, type => {
            types.push(type);
        });
        return types;
    }
    lang.getClassChain = getClassChain;
    /**
     * iterate base classes of target in chain. return false will break iterate.
     *
     * @export
     * @param {Type<any>} target
     * @param {(token: Type<any>) => any} express
     */
    function forInClassChain(target, express) {
        while (typeCheck.isClassType(target) && target !== Object) {
            if (express(target) === false) {
                break;
            }
            target = getParentClass(target);
        }
    }
    lang.forInClassChain = forInClassChain;
    /**
     * target is extends class of baseClass or not.
     *
     * @export
     * @param {Token<any>} target
     * @param {(ClassType<any> | ((type: ClassType<any>) => boolean))} baseClass
     * @returns {boolean}
     */
    function isExtendsClass(target, baseClass) {
        let isExtnds = false;
        if (typeCheck.isClassType(target)) {
            forInClassChain(target, t => {
                if (typeCheck.isClassType(baseClass)) {
                    isExtnds = t === baseClass;
                }
                else {
                    isExtnds = baseClass(t);
                }
                return !isExtnds;
            });
        }
        return isExtnds;
    }
    lang.isExtendsClass = isExtendsClass;
})(lang = exports.lang || (exports.lang = {}));


});

unwrapExports(lang_1);
var lang_2 = lang_1.MapBase;
var lang_3 = lang_1.MapSet;
var lang_4 = lang_1.lang;

var typeCheck = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * check target is function or not.
 *
 * @export
 * @param {*} target
 * @returns
 */
function isFunction(target) {
    if (!target) {
        return false;
    }
    return typeof target === 'function';
}
exports.isFunction = isFunction;
/**
 * check Abstract class with @Abstract or not
 *
 * @export
 * @param {*} target
 * @returns {target is AbstractType<any>}
 */
function isAbstractClass(target) {
    return classCheck(target) && Reflect.hasOwnMetadata('@Abstract', target);
}
exports.isAbstractClass = isAbstractClass;
/**
 * check target is class or not.
 *
 * @export
 * @param {*} target
 * @returns {target is Type<any>}
 */
function isClass(target) {
    return classCheck(target) && (!Reflect.hasOwnMetadata('@Abstract', target));
}
exports.isClass = isClass;
function isClassType(target) {
    return classCheck(target);
}
exports.isClassType = isClassType;
function classCheck(target) {
    if (!isFunction(target)) {
        return false;
    }
    if (target.prototype) {
        if (!target.name || target.name === 'Object') {
            return false;
        }
        let type = target;
        // for uglify
        if (/^[a-z]$/.test(type.name)) {
            if (lang_1.lang.hasClassAnnations(type)) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (lang_1.lang.hasClassAnnations(type)) {
                return true;
            }
            if (!/^[A-Z@]/.test(target.name)) {
                return false;
            }
        }
        // for IE 8, 9
        if (!isNodejsEnv() && /MSIE [6-9]/.test(navigator.userAgent)) {
            return true;
        }
        try {
            target.arguments && target.caller;
            return false;
        }
        catch (e) {
            return true;
        }
    }
    return false;
}
/**
 * is run in nodejs or not.
 *
 * @export
 * @returns {boolean}
 */
function isNodejsEnv() {
    return (typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined');
}
exports.isNodejsEnv = isNodejsEnv;
/**
 * check target is token or not.
 *
 * @export
 * @param {*} target
 * @returns {target is Token<any>}
 */
function isToken(target) {
    if (!target) {
        return false;
    }
    if (isString(target) || isSymbol(target) || classCheck(target) || (target instanceof Registration_1.Registration)) {
        return true;
    }
    return false;
}
exports.isToken = isToken;
/**
 * is target promise or not. now check is es6 Promise only.
 *
 * @export
 * @param {*} target
 * @returns {target is Promise<any>}
 */
function isPromise(target) {
    if (!target) {
        return false;
    }
    let type = target.constructor || target.prototype.constructor;
    if (type && type.name === 'Promise') {
        return true;
    }
    return false;
}
exports.isPromise = isPromise;
/**
 * is target rxjs observable or not.
 *
 * @export
 * @param {*} target
 * @returns {boolean}
 */
function isObservable(target) {
    if (!target && !isObject(target)) {
        return false;
    }
    let type = target.constructor || target.prototype.constructor;
    if (type && type.name === 'Observable') {
        return true;
    }
    return false;
}
exports.isObservable = isObservable;
/**
 * is target base object or not.
 * eg. {}, have not self constructor;
 * @export
 * @param {*} target
 * @returns {target is Promise<any>}
 */
function isBaseObject(target) {
    if (!target) {
        return false;
    }
    if (target.constructor && target.constructor.name === 'Object') {
        return true;
    }
    return false;
}
exports.isBaseObject = isBaseObject;
/**
 * is metadata object or not.
 *
 * @export
 * @param {*} target
 * @param {...(string|string[])[]} props
 * @returns {boolean}
 */
function isMetadataObject(target, ...props) {
    if (!isBaseObject(target)) {
        return false;
    }
    if (props.length) {
        return lang_1.lang.keys(target).some(n => props.some(ps => isString(ps) ? ps === n : ps.indexOf(n) > 0));
    }
    return true;
}
exports.isMetadataObject = isMetadataObject;
/**
 * is reftarget options or not.
 *
 * @export
 * @param {*} target
 * @returns {target is IRefTarget}
 */
function isRefTarget(target) {
    if (isBaseObject(target) !== true) {
        return false;
    }
    return isToken(target.target);
}
exports.isRefTarget = isRefTarget;
/**
 * check object is class metadata or not.
 *
 * @export
 * @param {*} target
 * @param {...(string | string[])[]} extendsProps
 * @returns {boolean}
 */
function isClassMetadata(target, ...extendsProps) {
    return isMetadataObject(target, ...extendsProps.concat(['singleton', 'provide', 'alias', 'type']));
}
exports.isClassMetadata = isClassMetadata;
/**
 * check object is property metadata or not.
 *
 * @export
 * @param {*} target
 * @param {...(string | string[])[]} extendsProps
 * @returns {boolean}
 */
function isProvideMetadata(target, ...extendsProps) {
    return isMetadataObject(target, ...extendsProps.concat(['type', 'provider']));
}
exports.isProvideMetadata = isProvideMetadata;
/**
 * check target is string or not.
 *
 * @export
 * @param {*} target
 * @returns {target is string}
 */
function isString(target) {
    return typeof target === 'string';
}
exports.isString = isString;
/**
 * check target is boolean or not.
 *
 * @export
 * @param {*} target
 * @returns {target is boolean}
 */
function isBoolean(target) {
    return typeof target === 'boolean' || (target === true || target === false);
}
exports.isBoolean = isBoolean;
/**
 * check target is number or not.
 *
 * @export
 * @param {*} target
 * @returns {target is number}
 */
function isNumber(target) {
    return typeof target === 'number';
}
exports.isNumber = isNumber;
/**
 * check target is undefined or not.
 *
 * @export
 * @param {*} target
 * @returns {target is undefined}
 */
function isUndefined(target) {
    return typeof target === 'undefined' || target === undefined;
}
exports.isUndefined = isUndefined;
/**
 * check target is unll or not.
 *
 * @export
 * @param {*} target
 * @returns {target is null}
 */
function isNull(target) {
    return target === null;
}
exports.isNull = isNull;
/**
 * is target null or undefined.
 *
 * @export
 * @param {*} target
 * @returns {boolean}
 */
function isNullOrUndefined(target) {
    return isNull(target) || isUndefined(target);
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * check target is array or not.
 *
 * @export
 * @param {*} target
 * @returns {target is Array<any>}
 */
function isArray(target) {
    return Array.isArray(target);
}
exports.isArray = isArray;
/**
 * check target is object or not.
 *
 * @export
 * @param {*} target
 * @returns {target is object}
 */
function isObject(target) {
    if (isNullOrUndefined(target)) {
        return false;
    }
    let type = typeof target;
    return type === 'object' || type === 'function';
}
exports.isObject = isObject;
/**
 * is custom class type instance or not.
 *
 * @export
 * @param {*} target
 * @returns {boolean}
 */
function isTypeObject(target) {
    if (isNullOrUndefined(target)) {
        return false;
    }
    if (typeof target !== 'object') {
        return false;
    }
    let type = lang_1.lang.getClass(target);
    if (isBaseType(type)) {
        return false;
    }
    return true;
}
exports.isTypeObject = isTypeObject;
/**
 * check target is date or not.
 *
 * @export
 * @param {*} target
 * @returns {target is Date}
 */
function isDate(target) {
    return isObject(target) && target instanceof Date;
}
exports.isDate = isDate;
/**
 * check target is symbol or not.
 *
 * @export
 * @param {*} target
 * @returns {target is Symbol}
 */
function isSymbol(target) {
    return typeof target === 'symbol' || (isObject(target) && /^Symbol\(/.test(target.toString()));
}
exports.isSymbol = isSymbol;
/**
 * check target is regexp or not.
 *
 * @export
 * @param {*} target
 * @returns {target is RegExp}
 */
function isRegExp(target) {
    return target && target instanceof RegExp;
}
exports.isRegExp = isRegExp;
/**
 * is base type or not.
 *
 * @export
 * @param {*} target
 * @returns {boolean}
 */
function isBaseType(target) {
    if (!isFunction(target)) {
        return false;
    }
    return target === Object
        || target === Boolean
        || target === String
        || target === Number
        || target === Date;
}
exports.isBaseType = isBaseType;


});

unwrapExports(typeCheck);
var typeCheck_1 = typeCheck.isFunction;
var typeCheck_2 = typeCheck.isAbstractClass;
var typeCheck_3 = typeCheck.isClass;
var typeCheck_4 = typeCheck.isClassType;
var typeCheck_5 = typeCheck.isNodejsEnv;
var typeCheck_6 = typeCheck.isToken;
var typeCheck_7 = typeCheck.isPromise;
var typeCheck_8 = typeCheck.isObservable;
var typeCheck_9 = typeCheck.isBaseObject;
var typeCheck_10 = typeCheck.isMetadataObject;
var typeCheck_11 = typeCheck.isRefTarget;
var typeCheck_12 = typeCheck.isClassMetadata;
var typeCheck_13 = typeCheck.isProvideMetadata;
var typeCheck_14 = typeCheck.isString;
var typeCheck_15 = typeCheck.isBoolean;
var typeCheck_16 = typeCheck.isNumber;
var typeCheck_17 = typeCheck.isUndefined;
var typeCheck_18 = typeCheck.isNull;
var typeCheck_19 = typeCheck.isNullOrUndefined;
var typeCheck_20 = typeCheck.isArray;
var typeCheck_21 = typeCheck.isObject;
var typeCheck_22 = typeCheck.isTypeObject;
var typeCheck_23 = typeCheck.isDate;
var typeCheck_24 = typeCheck.isSymbol;
var typeCheck_25 = typeCheck.isRegExp;
var typeCheck_26 = typeCheck.isBaseType;

var PromiseUtil_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * defer
 *
 * @export
 * @class Defer
 * @template T
 */
class Defer {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    static create(then) {
        let defer = new Defer();
        if (then) {
            defer.promise = defer.promise.then(then);
            return defer;
        }
        else {
            return defer;
        }
    }
    static getClassAnnations() {
        return { "name": "Defer", "params": { "create": ["then"], "constructor": [] } };
    }
}
exports.Defer = Defer;
/**
 * promise util.
 */
var PromiseUtil;
(function (PromiseUtil) {
    /**
     * create defer.
     *
     * @export
     * @template T
     * @param {((val: T) => T | PromiseLike<T>)} [then]
     * @returns {Defer<T>}
     */
    function defer(then) {
        return Defer.create(then);
    }
    PromiseUtil.defer = defer;
    /**
     * foreach opter for promises.
     *
     * @export
     * @template T
     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises
     * @param {Express<T, any>} express
     * @param {T} [defVal]
     * @returns
     */
    function forEach(promises, express, defVal) {
        let defer = new Defer();
        let pf = Promise.resolve(defVal);
        let length = promises ? promises.length : 0;
        if (length) {
            promises.forEach((p, idx) => {
                pf = pf.then(v => typeCheck.isFunction(p) ? p(v) : p)
                    .then(data => {
                    if (express(data) === false) {
                        defer.resolve('complete');
                        return Promise.reject('complete');
                    }
                    else if (idx === length - 1) {
                        defer.resolve('complete');
                        return Promise.reject('complete');
                    }
                    return data;
                });
            });
            pf.catch(err => {
                return err;
            });
        }
        else {
            defer.reject('array empty.');
        }
        return defer.promise;
    }
    PromiseUtil.forEach = forEach;
    /**
     * run promise step by step.
     *
     * @export
     * @template T
     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises
     * @returns
     */
    function step(promises) {
        let result = Promise.resolve(null);
        promises.forEach(p => {
            result = result.then(v => typeCheck.isFunction(p) ? p(v) : p);
        });
        return result;
    }
    PromiseUtil.step = step;
    /**
     * find first validate value from promises.
     *
     * @export
     * @template T
     * @param {(...(T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises
     * @param {Express<T, boolean>} validate
     * @returns
     */
    function find(promises, filter, defVal) {
        let defer = new Defer();
        forEach(promises, val => {
            if (filter(val)) {
                defer.resolve(val);
                return false;
            }
            return true;
        }, defVal)
            .then(() => defer.resolve(null))
            .catch(() => {
            defer.resolve(null);
        });
        return defer.promise;
    }
    PromiseUtil.find = find;
    /**
     * run action in chain.
     *
     * @export
     * @template T
     * @param {ActionHandle<T>[]} handles
     * @param {T} ctx
     * @param {() => Promise<void>} [next]
     * @returns {Promise<void>}
     */
    function runInChain(handles, ctx, next) {
        let index = -1;
        return dispatch(0);
        function dispatch(idx) {
            if (idx <= index) {
                return Promise.reject('next called mutiple times');
            }
            index = idx;
            let handle = idx < handles.length ? handles[idx] : null;
            if (idx === handles.length) {
                handle = next;
            }
            if (!handle) {
                return Promise.resolve();
            }
            try {
                return Promise.resolve(handle(ctx, dispatch.bind(null, idx + 1)));
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
    }
    PromiseUtil.runInChain = runInChain;
})(PromiseUtil = exports.PromiseUtil || (exports.PromiseUtil = {}));


});

unwrapExports(PromiseUtil_1);
var PromiseUtil_2 = PromiseUtil_1.Defer;
var PromiseUtil_3 = PromiseUtil_1.PromiseUtil;

var utils = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(typeCheck, exports);
tslib_1.__exportStar(lang_1, exports);
tslib_1.__exportStar(PromiseUtil_1, exports);


});

unwrapExports(utils);

var Registration_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * is registration class or not.
 *
 * @export
 * @param {*} target
 * @returns
 */
function isRegistrationClass(target) {
    if (utils.isClass(target)) {
        return target.isIocRegClass === true;
    }
    return false;
}
exports.isRegistrationClass = isRegistrationClass;
/**
 * inject token.
 * @export
 * @class Registration
 * @template T
 */
class Registration {
    /**
     * Creates an instance of Registration.
     * @param {(Token<T> | Token<any>)} provideType
     * @param {string} desc
     * @memberof Registration
     */
    constructor(provideType, desc) {
        this.type = '';
        this.init(provideType, desc);
    }
    init(provideType, desc) {
        if (provideType instanceof Registration) {
            if (desc) {
                this.classType = provideType.toString();
                this.desc = desc;
            }
            else {
                this.classType = provideType.getProvide();
                this.desc = provideType.getDesc();
            }
        }
        else {
            this.classType = provideType;
            this.desc = desc;
        }
    }
    /**
     * get provide.
     *
     * @returns {SymbolType<any>}
     * @memberof Registration
     */
    getProvide() {
        return this.classType;
    }
    /**
     * get class.
     *
     * @returns
     * @memberof Registration
     */
    getClass() {
        if (utils.isClass(this.classType)) {
            return this.classType;
        }
        return null;
    }
    /**
     * get desc.
     *
     * @returns
     * @memberof Registration
     */
    getDesc() {
        return this.desc;
    }
    /**
     * to string.
     *
     * @returns {string}
     * @memberof Registration
     */
    toString() {
        return this.format(this);
    }
    format(reg) {
        if (reg instanceof Registration) {
            let name = '';
            if (utils.isFunction(reg.classType)) {
                name = `{${utils.lang.getClassName(reg.classType)}}`;
            }
            else if (reg.classType) {
                name = reg.classType.toString();
            }
            return [reg.type, name, reg.desc].filter(n => n).join('_');
        }
        else if (utils.isFunction(reg)) {
            return `{${utils.lang.getClassName(reg)}}`;
        }
        else if (reg) {
            return reg.toString();
        }
        return '';
    }
    static getClassAnnations() {
        return { "name": "Registration", "params": { "constructor": ["provideType", "desc"], "init": ["provideType", "desc"], "getProvide": [], "getClass": [], "getDesc": [], "toString": [], "format": ["reg"] } };
    }
}
Registration.isIocRegClass = true;
exports.Registration = Registration;


});

unwrapExports(Registration_1);
var Registration_2 = Registration_1.isRegistrationClass;
var Registration_3 = Registration_1.Registration;

var InjectToken_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * inject token.
 *
 * @export
 * @class InjectToken
 * @extends {Registration<T>}
 * @template T
 */
class InjectToken extends Registration_1.Registration {
    constructor(desc) {
        super(desc, '');
    }
    static getClassAnnations() {
        return { "name": "InjectToken", "params": { "constructor": ["desc"] } };
    }
}
exports.InjectToken = InjectToken;


});

unwrapExports(InjectToken_1);
var InjectToken_2 = InjectToken_1.InjectToken;

var IContainer = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * IContainer token.
 * it is a symbol id, you can use  @Inject, @Autowried or @Param to get container instance in yourself class.
 */
exports.ContainerToken = new InjectToken_1.InjectToken('DI_IContainer');
/**
 * resove way
 *
 * @export
 * @enum {number}
 */
var ResoveWay;
(function (ResoveWay) {
    /**
     * current container.
     */
    ResoveWay[ResoveWay["current"] = 1] = "current";
    /**
     * traverse all curr node children.
     */
    ResoveWay[ResoveWay["traverse"] = 2] = "traverse";
    /**
     * bubble up all parent.
     */
    ResoveWay[ResoveWay["bubble"] = 4] = "bubble";
    /**
     * current and children.
     */
    ResoveWay[ResoveWay["nodes"] = 3] = "nodes";
    /**
     * current and bubble.
     */
    ResoveWay[ResoveWay["routeup"] = 5] = "routeup";
    /**
     *  traverse of curr node, children.
     */
    ResoveWay[ResoveWay["all"] = 7] = "all";
})(ResoveWay = exports.ResoveWay || (exports.ResoveWay = {}));


});

unwrapExports(IContainer);
var IContainer_1 = IContainer.ContainerToken;
var IContainer_2 = IContainer.ResoveWay;

var types = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * reference target level.
 *
 * @export
 * @enum {number}
 */
var RefTagLevel;
(function (RefTagLevel) {
    /**
     * ref taget self only
     */
    RefTagLevel[RefTagLevel["self"] = 1] = "self";
    /**
     * ref taget provider.
     */
    RefTagLevel[RefTagLevel["providers"] = 2] = "providers";
    /**
     * self provider
     */
    RefTagLevel[RefTagLevel["selfProviders"] = 3] = "selfProviders";
    /**
     * ref target class chain.
     */
    RefTagLevel[RefTagLevel["chain"] = 4] = "chain";
    /**
     * self chain.
     */
    RefTagLevel[RefTagLevel["selfChain"] = 5] = "selfChain";
    /**
     * chain providers.
     */
    RefTagLevel[RefTagLevel["chainProviders"] = 6] = "chainProviders";
    /**
     * ref all.
     */
    RefTagLevel[RefTagLevel["all"] = 7] = "all";
})(RefTagLevel = exports.RefTagLevel || (exports.RefTagLevel = {}));
/**
 * State of type in ioc.
 *
 * @export
 * @enum {number}
 */
var IocState;
(function (IocState) {
    IocState["design"] = "design";
    IocState["runtime"] = "runtime";
})(IocState = exports.IocState || (exports.IocState = {}));
/**
 * iterate way.
 *
 * @export
 * @enum {number}
 */
var Mode;
(function (Mode) {
    /**
     * route up. iterate in parents.
     */
    Mode[Mode["route"] = 1] = "route";
    /**
     * iterate in children.
     */
    Mode[Mode["children"] = 2] = "children";
    /**
     * iterate as tree map. node first
     */
    Mode[Mode["traverse"] = 3] = "traverse";
    /**
     * iterate as tree map. node last
     */
    Mode[Mode["traverseLast"] = 4] = "traverseLast";
})(Mode = exports.Mode || (exports.Mode = {}));


});

unwrapExports(types);
var types_1 = types.RefTagLevel;
var types_2 = types.IocState;
var types_3 = types.Mode;

var IMethodAccessor = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * IMethodAccessor interface symbol.
 * it is a symbol id, you can register yourself MethodAccessor for this.
 */
exports.MethodAccessorToken = new InjectToken_1.InjectToken('DI_IMethodAccessor');


});

unwrapExports(IMethodAccessor);
var IMethodAccessor_1 = IMethodAccessor.MethodAccessorToken;

var NullComponent_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * null component.
 *
 * @export
 * @class NullComponent
 * @implements {IComponent}
 */
class NullComponent {
    isEmpty() {
        return true;
    }
    add(action) {
        return this;
    }
    remove(action) {
        return this;
    }
    find(express, mode) {
        return exports.NullNode;
    }
    filter(express, mode) {
        return [];
    }
    each(express, mode) {
    }
    trans(express) {
    }
    transAfter(express) {
    }
    routeUp(express) {
    }
    equals(node) {
        return node === exports.NullNode;
    }
    empty() {
        return exports.NullNode;
    }
    static getClassAnnations() {
        return { "name": "NullComponent", "params": { "isEmpty": [], "add": ["action"], "remove": ["action"], "find": ["express", "mode"], "filter": ["express", "mode"], "each": ["express", "mode"], "trans": ["express"], "transAfter": ["express"], "routeUp": ["express"], "equals": ["node"], "empty": [] } };
    }
}
exports.NullComponent = NullComponent;
/**
 * Null node
 */
exports.NullNode = new NullComponent();


});

unwrapExports(NullComponent_1);
var NullComponent_2 = NullComponent_1.NullComponent;
var NullComponent_3 = NullComponent_1.NullNode;

var GComposite_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * generics composite
 *
 * @export
 * @class GComposite
 * @implements {GComponent<T>}
 * @template T
 */
class GComposite {
    constructor(name) {
        this.name = name;
        this.children = [];
    }
    add(node) {
        node.parent = this;
        this.children.push(node);
        return this;
    }
    remove(node) {
        let component;
        if (utils.isString(node)) {
            component = this.find(cmp => utils.isString(node) ? cmp.name === node : cmp.equals(node));
        }
        else if (node) {
            component = node;
        }
        else {
            component = this;
        }
        if (!component.parent) {
            return this;
        }
        else if (this.equals(component.parent)) {
            this.children.splice(this.children.indexOf(component), 1);
            component.parent = null;
            return this;
        }
        else {
            component.parent.remove(component);
            return null;
        }
    }
    find(express, mode) {
        let component;
        this.each(item => {
            if (component) {
                return false;
            }
            let isFinded = utils.isFunction(express) ? express(item) : express === (item);
            if (isFinded) {
                component = item;
                return false;
            }
            return true;
        }, mode);
        return (component || this.empty());
    }
    filter(express, mode) {
        let nodes = [];
        this.each(item => {
            if (express(item)) {
                nodes.push(item);
            }
        }, mode);
        return nodes;
    }
    each(iterate, mode) {
        mode = mode || types.Mode.traverse;
        let r;
        switch (mode) {
            case types.Mode.route:
                r = this.routeUp(iterate);
                break;
            case types.Mode.children:
                r = this.eachChildren(iterate);
                break;
            case types.Mode.traverse:
                r = this.trans(iterate);
                break;
            case types.Mode.traverseLast:
                r = this.transAfter(iterate);
                break;
            default:
                r = this.trans(iterate);
                break;
        }
        return r;
    }
    eachChildren(iterate) {
        (this.children || []).forEach(item => {
            return iterate(item);
        });
    }
    /**
     *do express work in routing.
     *
     *@param {Express<T, void | boolean>} express
     *
     *@memberOf IComponent
     */
    routeUp(iterate) {
        let curr = this;
        if (iterate(curr) === false) {
            return false;
        }
        
        if (this.parent && this.parent.routeUp) {
            return this.parent.routeUp(iterate);
        }
    }
    /**
     *translate all sub context to do express work.
     *
     *@param {Express<T, void | boolean>} express
     *
     *@memberOf IComponent
     */
    trans(express) {
        let curr = this;
        if (express(curr) === false) {
            return false;
        }
        let children = this.children || [];
        for (let i = 0; i < children.length; i++) {
            let result = children[i].trans(express);
            if (result === false) {
                return result;
            }
        }
        return true;
    }
    transAfter(express) {
        let children = this.children || [];
        for (let i = 0; i < children.length; i++) {
            let result = children[i].transAfter(express);
            if (result === false) {
                return false;
            }
        }
        let curr = this;
        if (express(curr) === false) {
            return false;
        }
        return true;
    }
    equals(node) {
        return this === node;
    }
    empty() {
        return NullComponent_1.NullNode;
    }
    isEmpty() {
        return this.equals(this.empty());
    }
    static getClassAnnations() {
        return { "name": "GComposite", "params": { "constructor": ["name"], "add": ["node"], "remove": ["node"], "find": ["express", "mode"], "filter": ["express", "mode"], "each": ["iterate", "mode"], "eachChildren": ["iterate"], "routeUp": ["iterate"], "trans": ["express"], "transAfter": ["express"], "equals": ["node"], "empty": [], "isEmpty": [] } };
    }
}
exports.GComposite = GComposite;


});

unwrapExports(GComposite_1);
var GComposite_2 = GComposite_1.GComposite;

var Composite_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * compoiste.
 *
 * @export
 * @class Composite
 * @implements {IComponent}
 */
class Composite extends GComposite_1.GComposite {
    constructor(name) {
        super(name);
    }
    find(express, mode) {
        return super.find(express, mode);
    }
    filter(express, mode) {
        return super.filter(express, mode);
    }
    each(express, mode) {
        return super.each(express, mode);
    }
    eachChildren(express) {
        super.eachChildren(express);
    }
    static getClassAnnations() {
        return { "name": "Composite", "params": { "constructor": ["name"], "find": ["express", "mode"], "filter": ["express", "mode"], "each": ["express", "mode"], "eachChildren": ["express"] } };
    }
}
exports.Composite = Composite;


});

unwrapExports(Composite_1);
var Composite_2 = Composite_1.Composite;

var components = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(Composite_1, exports);
tslib_1.__exportStar(GComposite_1, exports);
tslib_1.__exportStar(NullComponent_1, exports);


});

unwrapExports(components);

var NullAction = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Null action.
 *
 * @class NullActionClass
 * @extends {NullComponent}
 * @implements {ActionComponent}
 */
class NullActionClass extends components.NullComponent {
    insert(action, index) {
        return this;
    }
    execute(container, data, name) {
    }
    empty() {
        return exports.NullAction;
    }
    static getClassAnnations() {
        return { "name": "NullActionClass", "params": { "insert": ["action", "index"], "execute": ["container", "data", "name"], "empty": [] } };
    }
}
/**
 * Null Action
 */
exports.NullAction = new NullActionClass();


});

unwrapExports(NullAction);
var NullAction_1 = NullAction.NullAction;

var ActionComposite_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * action composite
 *
 * @export
 * @class ActionComposite
 * @extends {GComposite<ActionComponent>}
 * @implements {ActionComponent}
 */
class ActionComposite extends components.GComposite {
    constructor(name) {
        super(name);
        this.children = [];
    }
    insert(node, index) {
        node.parent = this;
        if (index < 0) {
            index = 0;
        }
        else if (index >= this.children.length) {
            index = this.children.length - 1;
        }
        this.children.splice(index, 0, node);
        return this;
    }
    execute(container, data, name) {
        if (name) {
            this.find(it => it.name === name)
                .execute(container, data);
        }
        else {
            this.trans(action => {
                if (action instanceof ActionComposite) {
                    action.working(container, data);
                }
            });
        }
    }
    empty() {
        return NullAction.NullAction;
    }
    working(container, data) {
        // do nothing.
    }
    static getClassAnnations() {
        return { "name": "ActionComposite", "params": { "constructor": ["name"], "insert": ["node", "index"], "execute": ["container", "data", "name"], "empty": [], "working": ["container", "data"] } };
    }
}
exports.ActionComposite = ActionComposite;


});

unwrapExports(ActionComposite_1);
var ActionComposite_2 = ActionComposite_1.ActionComposite;

var LifeState_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * life state.
 *
 * @export
 * @enum {number}
 */
var LifeState;
(function (LifeState) {
    /**
     * before create constructor Args
     */
    LifeState["beforeCreateArgs"] = "beforeCreateArgs";
    /**
     * before constructor advice action.
     */
    LifeState["beforeConstructor"] = "beforeConstructor";
    /**
     * after constructor advice action.
     */
    LifeState["afterConstructor"] = "afterConstructor";
    /**
     * on init.
     */
    LifeState["onInit"] = "onInit";
    /**
     * after init.
     */
    LifeState["AfterInit"] = "AfterInit";
})(LifeState = exports.LifeState || (exports.LifeState = {}));


});

unwrapExports(LifeState_1);
var LifeState_2 = LifeState_1.LifeState;

var CoreActions_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * cores decorator actions
 *
 * @export
 */
var CoreActions;
(function (CoreActions) {
    /**
     * the action bind parameter type form metadata.
     */
    CoreActions["bindParameterType"] = "bindParameterType";
    /**
     * the action bind Property type from metadata.
     */
    CoreActions["bindPropertyType"] = "bindPropertyType";
    /**
     * inject property action.
     */
    CoreActions["injectProperty"] = "injectProperty";
    /**
     * class provider bind action.
     */
    CoreActions["bindProvider"] = "bindProvider";
    /**
     * bind parameter provider action.
     */
    CoreActions["bindParameterProviders"] = "bindParameterProviders";
    /**
     * cache action.
     */
    CoreActions["cache"] = "cache";
    /**
     * component init action.  after constructor befor property inject.
     */
    CoreActions["componentBeforeInit"] = "componentBeforeInit";
    /**
     * component on init hooks. after property inject.
     */
    CoreActions["componentInit"] = "componentInit";
    /**
     * component after init hooks. after component init.
     */
    CoreActions["componentAfterInit"] = "componentAfterInit";
    /**
     * singleton action.
     */
    CoreActions["singletion"] = "singletion";
    /**
     * autorun action.
     */
    CoreActions["autorun"] = "autorun";
    /**
     * method autorun action.
     */
    CoreActions["methodAutorun"] = "methodAutorun";
})(CoreActions = exports.CoreActions || (exports.CoreActions = {}));


});

unwrapExports(CoreActions_1);
var CoreActions_2 = CoreActions_1.CoreActions;

var ArgsIterator_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * args iterator.s
 *
 * @export
 * @class ArgsIterator
 */
class ArgsIterator {
    constructor(args) {
        this.args = args;
        this.idx = -1;
        this.metadata = null;
    }
    isCompeted() {
        return this.idx >= this.args.length;
    }
    end() {
        this.idx = this.args.length;
    }
    next(express) {
        this.idx++;
        if (this.isCompeted()) {
            return null;
        }
        let arg = this.args[this.idx];
        if (express.isMetadata && express.isMetadata(arg)) {
            this.metadata = utils.lang.assign(this.metadata || {}, arg);
            this.end();
        }
        else if (express.match(arg)) {
            this.metadata = this.metadata || {};
            express.setMetadata(this.metadata, arg);
        }
        else if (utils.isMetadataObject(arg)) { // when match failed then check is base metadata.
            this.metadata = utils.lang.assign(this.metadata || {}, arg);
            this.end();
        }
        else {
            this.end();
        }
    }
    getArgs() {
        return this.args;
    }
    getMetadata() {
        return this.metadata;
    }
    static getClassAnnations() {
        return { "name": "ArgsIterator", "params": { "constructor": ["args"], "isCompeted": [], "end": [], "next": ["express"], "getArgs": [], "getMetadata": [] } };
    }
}
exports.ArgsIterator = ArgsIterator;


});

unwrapExports(ArgsIterator_1);
var ArgsIterator_2 = ArgsIterator_1.ArgsIterator;

var DecoratorType_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * decorator type category.
 *
 * @export
 * @enum {number}
 */
var DecoratorType;
(function (DecoratorType) {
    /**
     * Class decorator
     */
    DecoratorType[DecoratorType["Class"] = 1] = "Class";
    /**
     * Parameter decorator
     */
    DecoratorType[DecoratorType["Parameter"] = 2] = "Parameter";
    /**
     * Property decorator
     */
    DecoratorType[DecoratorType["Property"] = 4] = "Property";
    /**
     * Method decorator
     */
    DecoratorType[DecoratorType["Method"] = 8] = "Method";
    /**
     * decorator for any where.
     */
    DecoratorType[DecoratorType["All"] = 15] = "All";
})(DecoratorType = exports.DecoratorType || (exports.DecoratorType = {}));


});

unwrapExports(DecoratorType_1);
var DecoratorType_2 = DecoratorType_1.DecoratorType;

var DecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




exports.ParamerterName = 'paramerter_names';
/**
 * create dectorator for class params props methods.
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {*}
 */
function createDecorator(name, adapter, metadataExtends) {
    let metaName = `@${name}`;
    let factory = (...args) => {
        let metadata = null;
        if (args.length < 1) {
            return (...args) => {
                return storeMetadata(name, metaName, args, metadata, metadataExtends);
            };
        }
        metadata = argsToMetadata(args, adapter);
        if (metadata) {
            return (...args) => {
                return storeMetadata(name, metaName, args, metadata, metadataExtends);
            };
        }
        else {
            if (args.length === 1) {
                if (!utils.isClass(args[0])) {
                    return (...args) => {
                        return storeMetadata(name, metaName, args, metadata, metadataExtends);
                    };
                }
            }
        }
        return storeMetadata(name, metaName, args, metadata, metadataExtends);
    };
    factory.toString = () => metaName;
    factory.decoratorType = DecoratorType_1.DecoratorType.All;
    return factory;
}
exports.createDecorator = createDecorator;
function argsToMetadata(args, adapter) {
    let metadata = null;
    if (args.length) {
        if (adapter) {
            let iterator = new ArgsIterator_1.ArgsIterator(args);
            adapter(iterator);
            metadata = iterator.getMetadata();
        }
        else if (args.length === 1 && utils.isMetadataObject(args[0])) {
            metadata = args[0];
        }
    }
    return metadata;
}
function storeMetadata(name, metaName, args, metadata, metadataExtends) {
    let target;
    switch (args.length) {
        case 1:
            target = args[0];
            if (utils.isClass(target) || utils.isAbstractClass(target)) {
                setTypeMetadata(name, metaName, target, metadata, metadataExtends);
                return target;
            }
            break;
        case 2:
            target = args[0];
            let propertyKey = args[1];
            setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);
            break;
        case 3:
            if (utils.isNumber(args[2])) {
                target = args[0];
                let propertyKey = args[1];
                let parameterIndex = args[2];
                setParamMetadata(name, metaName, target, propertyKey, parameterIndex, metadata, metadataExtends);
            }
            else if (utils.isUndefined(args[2])) {
                target = args[0];
                let propertyKey = args[1];
                setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);
            }
            else {
                target = args[0];
                let propertyKey = args[1];
                let descriptor = args[2];
                setMethodMetadata(name, metaName, target, propertyKey, descriptor, metadata, metadataExtends);
                return descriptor;
            }
            break;
        default:
            throw new Error(`Invalid @${name} Decorator declaration.`);
    }
}
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getClassDecorators(target) {
    return Reflect.getOwnMetadataKeys(target)
        .filter(d => {
        if (!(d && utils.isString(d))) {
            return false;
        }
        if (!/^@/.test(d)) {
            return false;
        }
        return !/__\w+$/.test(d);
    });
}
exports.getClassDecorators = getClassDecorators;
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getMethodDecorators(target) {
    return Reflect.getMetadataKeys(target)
        .filter(d => d && utils.isString(d) && /^@\S+__method$/.test(d))
        .map(d => d.replace(/__method$/ig, ''));
}
exports.getMethodDecorators = getMethodDecorators;
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getPropDecorators(target) {
    return Reflect.getMetadataKeys(target)
        .filter(d => d && utils.isString(d) && /^@\S+__props$/.test(d))
        .map(d => d.replace(/__props$/ig, ''));
}
exports.getPropDecorators = getPropDecorators;
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getParamDecorators(target, propertyKey) {
    return ((propertyKey && propertyKey !== 'constructor') ? Reflect.getMetadataKeys(target, propertyKey) : Reflect.getOwnMetadataKeys(utils.lang.getClass(target)) || [])
        .filter(d => d && utils.isString(d) && /^@\S+__params$/.test(d))
        .map((d) => d.replace(/__params$/ig, ''));
}
exports.getParamDecorators = getParamDecorators;
/**
 * get all class metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns
 */
function getTypeMetadata(decorator, target) {
    let annotations = Reflect.getOwnMetadata(utils.isFunction(decorator) ? decorator.toString() : decorator, target);
    annotations = utils.isArray(annotations) ? annotations : [];
    return annotations;
}
exports.getTypeMetadata = getTypeMetadata;
/**
 * get own class metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns
 */
function getOwnTypeMetadata(decorator, target) {
    let annotations = Reflect.getOwnMetadata(utils.isFunction(decorator) ? decorator.toString() : decorator, target);
    annotations = utils.isArray(annotations) ? annotations : [];
    return annotations;
}
exports.getOwnTypeMetadata = getOwnTypeMetadata;
/**
 * has class decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @returns {boolean}
 */
function hasClassMetadata(decorator, target) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasMetadata(name, target);
}
exports.hasClassMetadata = hasClassMetadata;
/**
 * has own class decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @returns {boolean}
 */
function hasOwnClassMetadata(decorator, target) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasOwnMetadata(name, target);
}
exports.hasOwnClassMetadata = hasOwnClassMetadata;
function setTypeMetadata(name, metaName, target, metadata, metadataExtends) {
    let annotations = getOwnTypeMetadata(metaName, target).slice(0);
    let typeMetadata = (metadata || {});
    if (!typeMetadata.type) {
        typeMetadata.type = target;
    }
    typeMetadata.decorator = name;
    if (metadataExtends) {
        metadataExtends(typeMetadata);
    }
    annotations.unshift(typeMetadata);
    setParamerterNames(target);
    Reflect.defineMetadata(metaName, annotations, target);
}
let methodMetadataExt = '__method';
/**
 * get all method metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getMethodMetadata(decorator, target) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    let meta = Reflect.getMetadata(name + methodMetadataExt, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getMetadata(name + methodMetadataExt, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getMethodMetadata = getMethodMetadata;
/**
 * get own method metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getOwnMethodMetadata(decorator, target) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    let meta = Reflect.getOwnMetadata(name + methodMetadataExt, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getOwnMetadata(name + methodMetadataExt, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getOwnMethodMetadata = getOwnMethodMetadata;
/**
 * has own method decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
function hasOwnMethodMetadata(decorator, target, propertyKey) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    if (propertyKey) {
        let meta = getOwnMethodMetadata(name, target);
        return meta && meta.hasOwnProperty(propertyKey);
    }
    else {
        return Reflect.hasOwnMetadata(name + methodMetadataExt, target);
    }
}
exports.hasOwnMethodMetadata = hasOwnMethodMetadata;
/**
 * has method decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
function hasMethodMetadata(decorator, target, propertyKey) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    if (propertyKey) {
        let meta = getMethodMetadata(name, target);
        return meta && meta.hasOwnProperty(propertyKey);
    }
    else {
        return Reflect.hasMetadata(name + methodMetadataExt, target);
    }
}
exports.hasMethodMetadata = hasMethodMetadata;
function setMethodMetadata(name, metaName, target, propertyKey, descriptor, metadata, metadataExtends) {
    let meta = utils.lang.assign({}, getOwnMethodMetadata(metaName, target));
    meta[propertyKey] = meta[propertyKey] || [];
    let methodMeadata = (metadata || {});
    methodMeadata.decorator = name;
    methodMeadata.propertyKey = propertyKey;
    // methodMeadata.descriptor = descriptor;
    if (metadataExtends) {
        metadataExtends(methodMeadata);
    }
    meta[propertyKey].unshift(methodMeadata);
    Reflect.defineMetadata(metaName + methodMetadataExt, meta, target.constructor);
}
let propertyMetadataExt = '__props';
/**
 * get all property metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getPropertyMetadata(decorator, target) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    let meta = Reflect.getMetadata(name + propertyMetadataExt, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getMetadata(name + propertyMetadataExt, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getPropertyMetadata = getPropertyMetadata;
/**
 * get own property metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getOwnPropertyMetadata(decorator, target) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    let meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getOwnPropertyMetadata = getOwnPropertyMetadata;
/**
 * has property decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
function hasPropertyMetadata(decorator, target, propertyKey) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    if (propertyKey) {
        let meta = getPropertyMetadata(name, target);
        return meta && meta.hasOwnProperty(propertyKey);
    }
    else {
        return Reflect.hasMetadata(name + propertyMetadataExt, target);
    }
}
exports.hasPropertyMetadata = hasPropertyMetadata;
function setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends) {
    let meta = utils.lang.assign({}, getOwnPropertyMetadata(metaName, target));
    let propmetadata = (metadata || {});
    propmetadata.propertyKey = propertyKey;
    propmetadata.decorator = name;
    if (!propmetadata.type) {
        let t = Reflect.getMetadata('design:type', target, propertyKey);
        if (!t) {
            // Needed to support react native inheritance
            t = Reflect.getMetadata('design:type', target.constructor, propertyKey);
        }
        propmetadata.type = t;
    }
    if (metadataExtends) {
        metadataExtends(propmetadata);
    }
    if (!meta[propertyKey] || !utils.isArray(meta[propertyKey])) {
        meta[propertyKey] = [];
    }
    meta[propertyKey].unshift(propmetadata);
    Reflect.defineMetadata(metaName + propertyMetadataExt, meta, target.constructor);
}
let paramsMetadataExt = '__params';
/**
 * get paramerter metadata of one specail decorator in target method.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {T[][]}
 */
function getParamMetadata(decorator, target, propertyKey) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    let parameters = Reflect.getMetadata(name + paramsMetadataExt, target, propertyKey);
    parameters = utils.isArray(parameters) ? parameters : [];
    return parameters;
}
exports.getParamMetadata = getParamMetadata;
/**
 * get own paramerter metadata of one specail decorator in target method.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {T[][]}
 */
function getOwnParamMetadata(decorator, target, propertyKey) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    let parameters = Reflect.getOwnMetadata(name + paramsMetadataExt, target, propertyKey);
    parameters = utils.isArray(parameters) ? parameters : [];
    return parameters;
}
exports.getOwnParamMetadata = getOwnParamMetadata;
/**
 * has param decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {boolean}
 */
function hasParamMetadata(decorator, target, propertyKey) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasMetadata(name + paramsMetadataExt, target, propertyKey);
}
exports.hasParamMetadata = hasParamMetadata;
/**
 * has param decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {boolean}
 */
function hasOwnParamMetadata(decorator, target, propertyKey) {
    let name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasOwnMetadata(name + paramsMetadataExt, target, propertyKey);
}
exports.hasOwnParamMetadata = hasOwnParamMetadata;
function setParamMetadata(name, metaName, target, propertyKey, parameterIndex, metadata, metadataExtends) {
    let parameters = getOwnParamMetadata(metaName, target, propertyKey).slice(0);
    // there might be gaps if some in between parameters do not have annotations.
    // we pad with nulls.
    while (parameters.length <= parameterIndex) {
        parameters.push(null);
    }
    parameters[parameterIndex] = parameters[parameterIndex] || [];
    let paramMeadata = (metadata || {});
    if (!paramMeadata.type) {
        let t = Reflect.getOwnMetadata('design:type', target, propertyKey);
        if (!t) {
            // Needed to support react native inheritance
            t = Reflect.getOwnMetadata('design:type', target.constructor, propertyKey);
        }
        paramMeadata.type = t;
    }
    paramMeadata.propertyKey = propertyKey;
    paramMeadata.decorator = name;
    paramMeadata.index = parameterIndex;
    if (metadataExtends) {
        metadataExtends(paramMeadata);
    }
    parameters[parameterIndex].unshift(paramMeadata);
    Reflect.defineMetadata(metaName + paramsMetadataExt, parameters, target, propertyKey);
}
function getParamerterNames(target) {
    let meta = Reflect.getMetadata(exports.ParamerterName, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getMetadata(exports.ParamerterName, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getParamerterNames = getParamerterNames;
function getOwnParamerterNames(target) {
    let meta = Reflect.getOwnMetadata(exports.ParamerterName, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getOwnMetadata(exports.ParamerterName, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getOwnParamerterNames = getOwnParamerterNames;
function setParamerterNames(target) {
    let meta = utils.lang.assign({}, getParamerterNames(target));
    let descriptors = Object.getOwnPropertyDescriptors(target.prototype);
    let isUglify = /^[a-z]/.test(target.name);
    let anName = '';
    let classAnnations = utils.lang.getClassAnnations(target);
    if (classAnnations && classAnnations.params) {
        anName = classAnnations.name;
        meta = utils.lang.assign(meta, classAnnations.params);
    }
    if (!isUglify && target.name !== anName) {
        utils.lang.forIn(descriptors, (item, name) => {
            if (name !== 'constructor') {
                if (item.value) {
                    meta[name] = getParamNames(item.value);
                }
                if (item.set) {
                    meta[name] = getParamNames(item.set);
                }
            }
        });
        meta['constructor'] = getParamNames(target.prototype.constructor);
    }
    Reflect.defineMetadata(exports.ParamerterName, meta, target);
}
exports.setParamerterNames = setParamerterNames;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;
function getParamNames(func) {
    if (!utils.isFunction(func)) {
        return [];
    }
    let fnStr = func.toString().replace(STRIP_COMMENTS, '');
    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
    if (result === null) {
        result = [];
    }
    return result;
}


});

unwrapExports(DecoratorFactory);
var DecoratorFactory_1 = DecoratorFactory.ParamerterName;
var DecoratorFactory_2 = DecoratorFactory.createDecorator;
var DecoratorFactory_3 = DecoratorFactory.getClassDecorators;
var DecoratorFactory_4 = DecoratorFactory.getMethodDecorators;
var DecoratorFactory_5 = DecoratorFactory.getPropDecorators;
var DecoratorFactory_6 = DecoratorFactory.getParamDecorators;
var DecoratorFactory_7 = DecoratorFactory.getTypeMetadata;
var DecoratorFactory_8 = DecoratorFactory.getOwnTypeMetadata;
var DecoratorFactory_9 = DecoratorFactory.hasClassMetadata;
var DecoratorFactory_10 = DecoratorFactory.hasOwnClassMetadata;
var DecoratorFactory_11 = DecoratorFactory.getMethodMetadata;
var DecoratorFactory_12 = DecoratorFactory.getOwnMethodMetadata;
var DecoratorFactory_13 = DecoratorFactory.hasOwnMethodMetadata;
var DecoratorFactory_14 = DecoratorFactory.hasMethodMetadata;
var DecoratorFactory_15 = DecoratorFactory.getPropertyMetadata;
var DecoratorFactory_16 = DecoratorFactory.getOwnPropertyMetadata;
var DecoratorFactory_17 = DecoratorFactory.hasPropertyMetadata;
var DecoratorFactory_18 = DecoratorFactory.getParamMetadata;
var DecoratorFactory_19 = DecoratorFactory.getOwnParamMetadata;
var DecoratorFactory_20 = DecoratorFactory.hasParamMetadata;
var DecoratorFactory_21 = DecoratorFactory.hasOwnParamMetadata;
var DecoratorFactory_22 = DecoratorFactory.getParamerterNames;
var DecoratorFactory_23 = DecoratorFactory.getOwnParamerterNames;
var DecoratorFactory_24 = DecoratorFactory.setParamerterNames;

var ClassDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * create class decorator
 *
 * @export
 * @template T metadata type.
 * @param {string} name decorator name.
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {*}
 */
function createClassDecorator(name, adapter, metadataExtends) {
    let classAdapter = ((args) => {
        if (adapter) {
            adapter(args);
        }
        args.next({
            match: (arg) => arg && (utils.isSymbol(arg) || utils.isString(arg) || (utils.isObject(arg) && arg instanceof Registration_1.Registration)),
            setMetadata: (metadata, arg) => {
                metadata.provide = arg;
            }
        });
        args.next({
            match: (arg) => utils.isString(arg),
            setMetadata: (metadata, arg) => {
                metadata.alias = arg;
            }
        });
        args.next({
            match: (arg) => utils.isBoolean(arg) || utils.isNumber(arg) || utils.isToken(arg),
            setMetadata: (metadata, arg) => {
                if (utils.isBoolean(arg)) {
                    metadata.singleton = arg;
                }
                else if (utils.isNumber(arg)) {
                    metadata.expires = arg;
                }
                else if (utils.isToken(arg)) {
                    metadata.refs = { target: arg, provide: metadata.provide || metadata.type, alias: metadata.alias };
                }
            }
        });
        args.next({
            match: (arg) => utils.isToken(arg),
            setMetadata: (metadata, arg) => {
                metadata.expires = arg;
            }
        });
    });
    let decorator = DecoratorFactory.createDecorator(name, classAdapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Class;
    return decorator;
}
exports.createClassDecorator = createClassDecorator;


});

unwrapExports(ClassDecoratorFactory);
var ClassDecoratorFactory_1 = ClassDecoratorFactory.createClassDecorator;

var MethodDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * create method decorator.
 *
 * @export
 * @template T metadata type.
 * @param {string} name decorator name.
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns
 */
function createMethodDecorator(name, adapter, metadataExtends) {
    let methodAdapter = (args) => {
        if (adapter) {
            adapter(args);
        }
        args.next({
            match: (arg) => utils.isArray(arg),
            setMetadata: (metadata, arg) => {
                metadata.providers = arg;
            }
        });
    };
    let decorator = DecoratorFactory.createDecorator(name, methodAdapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Method;
    return decorator;
}
exports.createMethodDecorator = createMethodDecorator;


});

unwrapExports(MethodDecoratorFactory);
var MethodDecoratorFactory_1 = MethodDecoratorFactory.createMethodDecorator;

var ParamDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * create parameter decorator.
 *
 * @export
 * @template T metadata type.
 * @param {string} name decorator name.
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns
 */
function createParamDecorator(name, adapter, metadataExtends) {
    let paramAdapter = ((args) => {
        if (adapter) {
            adapter(args);
        }
        args.next({
            isMetadata: (arg) => utils.isProvideMetadata(arg, 'index'),
            match: (arg) => utils.isToken(arg),
            setMetadata: (metadata, arg) => {
                metadata.provider = arg;
            }
        });
        // args.next<T>({
        //     match: (arg) => isString(arg),
        //     setMetadata: (metadata, arg) => {
        //         metadata.alias = arg;
        //     }
        // });
    });
    let decorator = DecoratorFactory.createDecorator(name, paramAdapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Parameter;
    return decorator;
}
exports.createParamDecorator = createParamDecorator;


});

unwrapExports(ParamDecoratorFactory);
var ParamDecoratorFactory_1 = ParamDecoratorFactory.createParamDecorator;

var PropertyDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * create property decorator.
 *
 * @export
 * @template T metadata type.
 * @param {string} name decorator name.
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns
 */
function createPropDecorator(name, adapter, metadataExtends) {
    let propPropAdapter = ((args) => {
        if (adapter) {
            adapter(args);
        }
        args.next({
            isMetadata: (arg) => utils.isProvideMetadata(arg),
            match: (arg) => utils.isToken(arg),
            setMetadata: (metadata, arg) => {
                metadata.provider = arg;
            }
        });
    });
    let decorator = DecoratorFactory.createDecorator(name, propPropAdapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Property;
    return decorator;
}
exports.createPropDecorator = createPropDecorator;


});

unwrapExports(PropertyDecoratorFactory);
var PropertyDecoratorFactory_1 = PropertyDecoratorFactory.createPropDecorator;

var ParamPropDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * create parameter or property decorator
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {IParamPropDecorator<T>}
 */
function createParamPropDecorator(name, adapter, metadataExtends) {
    let paramPropAdapter = ((args) => {
        if (adapter) {
            adapter(args);
        }
        args.next({
            isMetadata: (arg) => utils.isProvideMetadata(arg, 'index'),
            match: (arg) => utils.isToken(arg),
            setMetadata: (metadata, arg) => {
                metadata.provider = arg;
            }
        });
        // args.next<T>({
        //     match: (arg) => isString(arg),
        //     setMetadata: (metadata, arg) => {
        //         metadata.alias = arg;
        //     }
        // });
    });
    let decorator = DecoratorFactory.createDecorator(name, paramPropAdapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Property | DecoratorType_1.DecoratorType.Parameter;
    return decorator;
}
exports.createParamPropDecorator = createParamPropDecorator;


});

unwrapExports(ParamPropDecoratorFactory);
var ParamPropDecoratorFactory_1 = ParamPropDecoratorFactory.createParamPropDecorator;

var ClassMethodDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * create decorator for class and method.
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {IClassMethodDecorator<T>}
 */
function createClassMethodDecorator(name, adapter, metadataExtends) {
    let decorator = DecoratorFactory.createDecorator(name, adapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Class | DecoratorType_1.DecoratorType.Method;
    return decorator;
}
exports.createClassMethodDecorator = createClassMethodDecorator;


});

unwrapExports(ClassMethodDecoratorFactory);
var ClassMethodDecoratorFactory_1 = ClassMethodDecoratorFactory.createClassMethodDecorator;

var MethodPropDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * create method or property decorator
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {IMethodPropDecorator<T>}
 */
function createMethodPropDecorator(name, adapter, metadataExtends) {
    let decorator = DecoratorFactory.createDecorator(name, adapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Method | DecoratorType_1.DecoratorType.Property;
    return decorator;
}
exports.createMethodPropDecorator = createMethodPropDecorator;


});

unwrapExports(MethodPropDecoratorFactory);
var MethodPropDecoratorFactory_1 = MethodPropDecoratorFactory.createMethodPropDecorator;

var MethodPropParamDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * create method, property or parameter decorator.
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {IMethodPropParamDecorator<T>}
 */
function createMethodPropParamDecorator(name, adapter, metadataExtends) {
    let decorator = DecoratorFactory.createDecorator(name, adapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Method | DecoratorType_1.DecoratorType.Property | DecoratorType_1.DecoratorType.Parameter;
    return decorator;
}
exports.createMethodPropParamDecorator = createMethodPropParamDecorator;


});

unwrapExports(MethodPropParamDecoratorFactory);
var MethodPropParamDecoratorFactory_1 = MethodPropParamDecoratorFactory.createMethodPropParamDecorator;

var factories = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(ArgsIterator_1, exports);
tslib_1.__exportStar(DecoratorType_1, exports);
tslib_1.__exportStar(DecoratorFactory, exports);
tslib_1.__exportStar(ClassDecoratorFactory, exports);
tslib_1.__exportStar(MethodDecoratorFactory, exports);
tslib_1.__exportStar(ParamDecoratorFactory, exports);
tslib_1.__exportStar(PropertyDecoratorFactory, exports);
tslib_1.__exportStar(ParamPropDecoratorFactory, exports);
tslib_1.__exportStar(ClassMethodDecoratorFactory, exports);
tslib_1.__exportStar(MethodPropDecoratorFactory, exports);
tslib_1.__exportStar(MethodPropParamDecoratorFactory, exports);


});

unwrapExports(factories);

var InjectReference_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Reference registration.
 *
 * @export
 * @class RefRegistration
 * @extends {Registration<T>}
 * @template T
 */
class RefRegistration extends Registration_1.Registration {
    constructor(provideType, desc) {
        super(provideType, desc);
        this.type = 'Ref';
    }
    static getClassAnnations() {
        return { "name": "RefRegistration", "params": { "constructor": ["provideType", "desc"] } };
    }
}
exports.RefRegistration = RefRegistration;
/**
 * inject reference.
 *
 * @export
 * @class InjectReference
 * @extends {Registration<T>}
 * @template T
 */
class InjectReference extends Registration_1.Registration {
    constructor(provideType, target) {
        super(provideType, '');
        this.target = target;
    }
    init(provideType) {
        this.classType = this.format(provideType);
    }
    /**
     * to string.
     *
     * @returns {string}
     * @memberof Registration
     */
    toString() {
        let key = super.toString();
        let target = this.format(this.target);
        return `Ref ${key} for ${target}`;
    }
    static getClassAnnations() {
        return { "name": "InjectReference", "params": { "constructor": ["provideType", "target"], "init": ["provideType"], "toString": [] } };
    }
}
exports.InjectReference = InjectReference;
/**
 * is inject reference token or not.
 *
 * @export
 * @template T
 * @param {*} target
 * @returns {target is InjectReference<T>}
 */
function isInjectReference(target) {
    if (!target) {
        return false;
    }
    return target instanceof InjectReference || (utils.isString(target) && /^Ref\s+[\w\{\}]+\sfor/.test(target));
}
exports.isInjectReference = isInjectReference;
/**
 * inject class provides token.
 *
 * @export
 * @class InjectClassProvidesToken
 * @extends {RefRegistration<IClassProvides>}
 */
class InjectClassProvidesToken extends RefRegistration {
    constructor(provideType) {
        super(provideType, 'class_provides');
    }
    static getClassAnnations() {
        return { "name": "InjectClassProvidesToken", "params": { "constructor": ["provideType"] } };
    }
}
exports.InjectClassProvidesToken = InjectClassProvidesToken;


});

unwrapExports(InjectReference_1);
var InjectReference_2 = InjectReference_1.RefRegistration;
var InjectReference_3 = InjectReference_1.InjectReference;
var InjectReference_4 = InjectReference_1.isInjectReference;
var InjectReference_5 = InjectReference_1.InjectClassProvidesToken;

var BindProviderAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * bind provider action. for binding a factory to an token.
 *
 * @export
 * @class BindProviderAction
 * @extends {ActionComposite}
 */
class BindProviderAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.bindProvider);
    }
    working(container, data) {
        let type = data.targetType;
        let raiseContainer = data.raiseContainer;
        let lifeScope = container.getLifeScope();
        let matchs = lifeScope.getClassDecorators(type, surm => surm.actions.includes(CoreActions_1.CoreActions.bindProvider));
        let clpds = new InjectReference_1.InjectClassProvidesToken(type);
        // has binding.
        let classPds = raiseContainer.resolveValue(clpds) || { provides: [clpds.toString()], decors: [] };
        if (classPds.decors.length) {
            matchs = matchs.filter(d => classPds.decors.indexOf(d.name) < 0);
        }
        if (matchs.length < 1) {
            data.execResult = classPds.provides;
            return;
        }
        matchs.forEach(surm => {
            let metadata = factories.getOwnTypeMetadata(surm.name, type);
            classPds.decors.push(surm.name);
            if (Array.isArray(metadata) && metadata.length > 0) {
                // bind all provider.
                metadata.forEach(c => {
                    if (!c) {
                        return;
                    }
                    if (c.provide) {
                        let provide = raiseContainer.getToken(c.provide, c.alias);
                        classPds.provides.push(provide);
                        raiseContainer.bindProvider(provide, c.type);
                    }
                    if (c.refs && c.refs.target) {
                        raiseContainer.bindRefProvider(c.refs.target, c.refs.provide ? c.refs.provide : c.type, c.type, c.refs.provide ? c.refs.alias : '', tk => classPds.provides.push(tk));
                    }
                    // class private provider.
                    if (c.providers && c.providers.length) {
                        raiseContainer.bindProviders(c.type, refKey => classPds.provides.push(refKey), ...c.providers);
                    }
                });
            }
        });
        raiseContainer.bindProvider(clpds, classPds);
        data.execResult = classPds.provides;
    }
    static getClassAnnations() {
        return { "name": "BindProviderAction", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.BindProviderAction = BindProviderAction;


});

unwrapExports(BindProviderAction_1);
var BindProviderAction_2 = BindProviderAction_1.BindProviderAction;

var BindParameterTypeAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * bind parameter type action.
 *
 * @export
 * @class BindParameterTypeAction
 * @extends {ActionComposite}
 */
class BindParameterTypeAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.bindParameterType);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        let target = data.target;
        let type = data.targetType;
        let propertyKey = data.propertyKey;
        let lifeScope = container.getLifeScope();
        let designParams;
        if (target && propertyKey) {
            designParams = Reflect.getMetadata('design:paramtypes', target, propertyKey) || [];
        }
        else {
            designParams = Reflect.getMetadata('design:paramtypes', type) || [];
        }
        designParams = designParams.slice(0);
        designParams.forEach(dtype => {
            if (lifeScope.isVaildDependence(dtype)) {
                if (!container.has(dtype)) {
                    container.register(dtype);
                }
            }
        });
        let matchs = lifeScope.getParameterDecorators(target || type, propertyKey, surm => surm.actions.includes(CoreActions_1.CoreActions.bindParameterType));
        matchs.forEach(surm => {
            let parameters = (target || propertyKey !== 'constructor') ? factories.getParamMetadata(surm.name, target, propertyKey) : factories.getOwnParamMetadata(surm.name, type);
            if (utils.isArray(parameters) && parameters.length) {
                parameters.forEach(params => {
                    let parm = (utils.isArray(params) && params.length > 0) ? params[0] : null;
                    if (parm && parm.index >= 0) {
                        if (lifeScope.isVaildDependence(parm.provider)) {
                            if (!container.has(parm.provider, parm.alias)) {
                                container.register(container.getToken(parm.provider, parm.alias));
                            }
                        }
                        if (lifeScope.isVaildDependence(parm.type)) {
                            if (!container.has(parm.type)) {
                                container.register(parm.type);
                            }
                        }
                        let token = parm.provider ? container.getTokenKey(parm.provider, parm.alias) : parm.type;
                        if (token) {
                            designParams[parm.index] = token;
                        }
                    }
                });
            }
        });
        data.execResult = designParams;
    }
    static getClassAnnations() {
        return { "name": "BindParameterTypeAction", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.BindParameterTypeAction = BindParameterTypeAction;


});

unwrapExports(BindParameterTypeAction_1);
var BindParameterTypeAction_2 = BindParameterTypeAction_1.BindParameterTypeAction;

var BindPropertyTypeAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * bind property type action. to get the property autowride token of Type calss.
 *
 * @export
 * @class SetPropAction
 * @extends {ActionComposite}
 */
class BindPropertyTypeAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.bindPropertyType);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        let type = data.targetType;
        let lifeScope = container.getLifeScope();
        let matchs = lifeScope.getPropertyDecorators(type, surm => surm.actions.includes(CoreActions_1.CoreActions.bindPropertyType));
        let list = [];
        matchs.forEach(surm => {
            let propMetadata = factories.getPropertyMetadata(surm.name, type);
            for (let n in propMetadata) {
                list = list.concat(propMetadata[n]);
            }
            list = list.filter(n => !!n);
            list.forEach(prop => {
                if (lifeScope.isVaildDependence(prop.provider)) {
                    if (!container.has(prop.provider, prop.alias)) {
                        container.register(container.getToken(prop.provider, prop.alias));
                    }
                }
                if (lifeScope.isVaildDependence(prop.type)) {
                    if (!container.has(prop.type)) {
                        container.register(prop.type);
                    }
                }
            });
        });
        data.execResult = list;
    }
    static getClassAnnations() {
        return { "name": "BindPropertyTypeAction", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.BindPropertyTypeAction = BindPropertyTypeAction;


});

unwrapExports(BindPropertyTypeAction_1);
var BindPropertyTypeAction_2 = BindPropertyTypeAction_1.BindPropertyTypeAction;

var Provider_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 *  provider, to dynamic resovle instance of params in run time.
 *
 * @export
 * @class Provider
 */
class Provider {
    constructor(type, value) {
        this.type = type;
        this.value = value;
    }
    /**
     * resolve provider value.
     *
     * @template T
     * @param {IContainer} container
     * @param {ProviderTypes[]} providers
     * @returns {T}
     * @memberof Provider
     */
    resolve(container, ...providers) {
        if (utils.isUndefined(this.value)) {
            return container.has(this.type) ? container.resolve(this.type, ...providers) : null;
        }
        else {
            return this.value;
        }
    }
    /**
     * create provider.
     *
     * @static
     * @param {Token<any>} type
     * @param {(any)} value
     * @returns Provider
     * @memberof Provider
     */
    static create(type, value) {
        return new Provider(type, value);
    }
    /**
     * create extends provider.
     *
     * @static
     * @param {Token<any>} token
     * @param {(any)} value
     * @param {Express2<any, ExtendsProvider, void>} [extendsTarget]
     * @returns {ExtendsProvider}
     * @memberof Provider
     */
    static createExtends(token, value, extendsTarget) {
        return new ExtendsProvider(token, value, extendsTarget);
    }
    /**
     * create invoked provider.
     *
     * @static
     * @param {Token<any>} token
     * @param {string} method
     * @param {(any)} [value]
     * @returns {InvokeProvider}
     * @memberof Provider
     */
    static createInvoke(token, method, value) {
        return new InvokeProvider(token, method, value);
    }
    /**
     * create param provider.
     *
     * @static
     * @param {Token<any>} token
     * @param {(any)} value
     * @param {number} [index]
     * @param {string} [method]
     * @returns {ParamProvider}
     * @memberof Provider
     */
    static createParam(token, value, index, method) {
        return new ParamProvider(token, value, index, method);
    }
    static getClassAnnations() {
        return { "name": "Provider", "params": { "constructor": ["type", "value"], "resolve": ["container", "providers"], "create": ["type", "value"], "createExtends": ["token", "value", "extendsTarget"], "createInvoke": ["token", "method", "value"], "createParam": ["token", "value", "index", "method"] } };
    }
}
exports.Provider = Provider;
/**
 * InvokeProvider
 *
 * @export
 * @class InvokeProvider
 * @extends {Provider}
 */
class InvokeProvider extends Provider {
    constructor(type, method, value) {
        super(type, value);
        this.method = method;
    }
    resolve(container, ...providers) {
        if (this.method) {
            return container.syncInvoke(this.type, this.method, ...providers);
        }
        return super.resolve(container, ...providers);
    }
    static getClassAnnations() {
        return { "name": "InvokeProvider", "params": { "constructor": ["type", "method", "value"], "resolve": ["container", "providers"] } };
    }
}
exports.InvokeProvider = InvokeProvider;
/**
 * param provider.
 *
 * @export
 * @interface ParamProvider
 */
class ParamProvider extends InvokeProvider {
    constructor(token, value, index, method) {
        super(token, method, value);
        this.index = index;
    }
    /**
     * resolve param
     *
     * @template T
     * @param {IContainer} container
     * @param {...ProviderTypes[]} providers
     * @returns {T}
     * @memberof ParamProvider
     */
    resolve(container, ...providers) {
        return super.resolve(container, ...providers);
    }
    static getClassAnnations() {
        return { "name": "ParamProvider", "params": { "constructor": ["token", "value", "index", "method"], "resolve": ["container", "providers"] } };
    }
}
exports.ParamProvider = ParamProvider;
/**
 * Provider enable exntends target with provider in dynamic.
 *
 * @export
 * @class ExtendsProvider
 * @extends {Provider}
 */
class ExtendsProvider extends Provider {
    constructor(token, value, extendsTarget) {
        super(token, value);
        this.extendsTarget = extendsTarget;
    }
    resolve(container, ...providers) {
        return super.resolve(container, ...providers);
    }
    extends(target) {
        if (utils.isObject(target) && utils.isFunction(this.extendsTarget)) {
            this.extendsTarget(target, this);
        }
    }
    static getClassAnnations() {
        return { "name": "ExtendsProvider", "params": { "constructor": ["token", "value", "extendsTarget"], "resolve": ["container", "providers"], "extends": ["target"] } };
    }
}
exports.ExtendsProvider = ExtendsProvider;


});

unwrapExports(Provider_1);
var Provider_2 = Provider_1.Provider;
var Provider_3 = Provider_1.InvokeProvider;
var Provider_4 = Provider_1.ParamProvider;
var Provider_5 = Provider_1.ExtendsProvider;

var ProviderMap_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



// use core-js in browser.
exports.ProviderMapToken = new InjectToken_1.InjectToken('DI_ProviderMap');
/**
 * Provider Map.
 *
 * note: object map provider can not resolve token.
 *
 * @export
 * @class Providers
 */
class ProviderMap extends utils.MapBase {
    constructor(container) {
        super();
        this.container = container;
    }
    /**
     * has provide or not.
     *
     * @param {(Token<any> | number)} provide
     * @returns {boolean}
     * @memberof ProviderMap
     */
    has(provide) {
        return this.map.has(this.getTokenKey(provide));
    }
    provides() {
        return this.keys().filter(k => utils.isToken(k));
    }
    /**
     * get token key.
     *
     * @param {(Token<any> | number)} token
     * @returns {(SymbolType<any> | number)}
     * @memberof ProviderMap
     */
    getTokenKey(token) {
        if (utils.isToken(token)) {
            return this.container.getTokenKey(token);
        }
        return token;
    }
    /**
     * get token factory.
     *
     * @template T
     * @param {(Token<T> | number)} provide
     * @returns {InstanceFactory<T>}
     * @memberof ProviderMap
     */
    get(provide) {
        return this.map.get(this.getTokenKey(provide));
    }
    getTokenImpl(token, resway) {
        return this.container.getTokenImpl(token, resway);
    }
    unregister(token, resway) {
        let key = this.getTokenKey(token);
        if (this.map.has(key)) {
            this.map.delete(key);
        }
        return this;
    }
    /**
     * add and bind token provider.
     *
     * @template T
     * @param {(Token<T> | number)} provide
     * @param {(Token<T> | Factory<T>)} provider
     * @returns {this}
     * @memberof ProviderMap
     */
    add(provide, provider) {
        let key = this.getTokenKey(provide);
        if (utils.isUndefined(key)) {
            return this;
        }
        let factory;
        if (utils.isToken(provider) && this.container.has(provider)) {
            factory = (...providers) => {
                return this.container.resolve(provider, ...providers);
            };
        }
        else {
            if (utils.isFunction(provider)) {
                factory = provider;
            }
            else {
                factory = () => {
                    return provider;
                };
            }
        }
        if (factory) {
            this.map.set(key, factory);
        }
        return this;
    }
    /**
     * resolve instance via provide token.
     *
     * @template T
     * @param {Token<T>} provide
     * @param {...ProviderTypes[]} providers
     * @returns {T}
     * @memberof ProviderMap
     */
    resolve(provide, resway, ...providers) {
        let key = this.getTokenKey(provide);
        let way;
        if (utils.isNumber(resway)) {
            way = resway;
        }
        else {
            if (resway) {
                providers.unshift(resway);
            }
            way = IContainer.ResoveWay.current;
        }
        if ((way & IContainer.ResoveWay.current) && this.map.has(key)) {
            let provider = this.map.get(key);
            return utils.isFunction(provider) ? provider(...providers) : null;
        }
        return null;
    }
    forEach(callbackfn) {
        this.map.forEach((fac, key) => {
            !utils.isNumber(key) && callbackfn(key, fac, this);
        });
    }
    /**
     * copy provider map.
     *
     * @param {ProviderMap} map
     * @returns
     * @memberof ProviderMap
     */
    copy(map) {
        if (!map) {
            return this;
        }
        this.map.forEach((fac, key) => {
            this.map.set(key, fac);
        });
        return this;
    }
    static getClassAnnations() {
        return { "name": "ProviderMap", "params": { "constructor": ["container"], "has": ["provide"], "provides": [], "getTokenKey": ["token"], "get": ["provide"], "getTokenImpl": ["token", "resway"], "unregister": ["token", "resway"], "add": ["provide", "provider"], "resolve": ["provide", "resway", "providers"], "forEach": ["callbackfn"], "copy": ["map"] } };
    }
}
exports.ProviderMap = ProviderMap;
/**
 * object is provider map or not.
 *
 * @export
 * @param {object} target
 * @returns {target is ProviderMap}
 */
function isProviderMap(target) {
    if (!utils.isObject(target)) {
        return false;
    }
    return target instanceof ProviderMap;
}
exports.isProviderMap = isProviderMap;


});

unwrapExports(ProviderMap_1);
var ProviderMap_2 = ProviderMap_1.ProviderMapToken;
var ProviderMap_3 = ProviderMap_1.ProviderMap;
var ProviderMap_4 = ProviderMap_1.isProviderMap;

var IProviderParser = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Providers parser token.
 */
exports.ProviderParserToken = new InjectToken_1.InjectToken('DI_IProviderParser');


});

unwrapExports(IProviderParser);
var IProviderParser_1 = IProviderParser.ProviderParserToken;

var ProviderParser_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * provider matcher. use to find custome providers in resolve.
 *
 * note: object map provider can not resolve token.
 *
 * @export
 * @class ProviderMatcher
 * @implements {IProviderMatcher}
 */
class ProviderParser {
    constructor(container) {
        this.container = container;
    }
    parse(...providers) {
        if (providers.length === 1 && ProviderMap_1.isProviderMap(providers[0])) {
            return providers[0];
        }
        let map = this.container.resolve(ProviderMap_1.ProviderMapToken);
        providers.forEach((p, index) => {
            if (utils.isUndefined(p) || utils.isNull(p)) {
                return;
            }
            if (ProviderMap_1.isProviderMap(p)) {
                map.copy(p);
            }
            else if (p instanceof Provider_1.Provider) {
                if (p instanceof Provider_1.ParamProvider) {
                    if (!p.type && utils.isNumber(p.index)) {
                        map.add(p.index, (...providers) => p.resolve(this.container, ...providers));
                    }
                    else {
                        map.add(p.type, (...providers) => p.resolve(this.container, ...providers));
                    }
                }
                else {
                    map.add(p.type, (...providers) => p.resolve(this.container, ...providers));
                }
            }
            else if (utils.isClass(p)) {
                if (!this.container.has(p)) {
                    this.container.register(p);
                }
                map.add(p, p);
            }
            else if (utils.isBaseObject(p)) {
                let pr = p;
                let isobjMap = false;
                if (utils.isToken(pr.provide)) {
                    if (utils.isArray(pr.deps) && pr.deps.length) {
                        pr.deps.forEach(d => {
                            if (utils.isClass(d) && !this.container.has(d)) {
                                this.container.register(d);
                            }
                        });
                    }
                    if (!utils.isUndefined(pr.useValue)) {
                        map.add(pr.provide, () => pr.useValue);
                    }
                    else if (utils.isClass(pr.useClass)) {
                        if (!this.container.has(pr.useClass)) {
                            this.container.register(pr.useClass);
                        }
                        map.add(pr.provide, pr.useClass);
                    }
                    else if (utils.isFunction(pr.useFactory)) {
                        map.add(pr.provide, (...providers) => {
                            let args = [];
                            if (utils.isArray(pr.deps) && pr.deps.length) {
                                args = pr.deps.map(d => {
                                    if (utils.isToken(d)) {
                                        return this.container.resolve(d, ...providers);
                                    }
                                    else {
                                        return d;
                                    }
                                });
                            }
                            return pr.useFactory.apply(pr, args);
                        });
                    }
                    else if (utils.isToken(pr.useExisting)) {
                        map.add(pr.provide, (...providers) => this.container.resolve(pr.useExisting, ...providers));
                    }
                    else {
                        isobjMap = true;
                    }
                }
                else {
                    isobjMap = true;
                }
                if (isobjMap) {
                    utils.lang.forIn(p, (val, name) => {
                        if (name && utils.isString(name)) {
                            // object map can not resolve token. set all fileld as value factory.
                            map.add(name, () => val);
                        }
                    });
                }
            }
            else if (utils.isFunction(p)) {
                map.add(name, () => p);
            }
        });
        return map;
    }
    static getClassAnnations() {
        return { "name": "ProviderParser", "params": { "constructor": ["container"], "parse": ["providers"] } };
    }
}
exports.ProviderParser = ProviderParser;
function isProvider(target) {
    return ProviderMap_1.isProviderMap(target) || utils.isBaseObject(target) || target instanceof Provider_1.Provider;
}
exports.isProvider = isProvider;


});

unwrapExports(ProviderParser_1);
var ProviderParser_2 = ProviderParser_1.ProviderParser;
var ProviderParser_3 = ProviderParser_1.isProvider;

var providers = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(Provider_1, exports);
tslib_1.__exportStar(ProviderMap_1, exports);
tslib_1.__exportStar(IProviderParser, exports);
tslib_1.__exportStar(ProviderParser_1, exports);


});

unwrapExports(providers);

var InjectPropertyAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * inject property value action, to inject property value for resolve instance.
 *
 * @export
 * @class SetPropAction
 * @extends {ActionComposite}
 */
class InjectPropertyAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.injectProperty);
    }
    working(container, data) {
        if (!data.execResult) {
            this.parent.find(act => act.name === CoreActions_1.CoreActions.bindPropertyType).execute(container, data);
        }
        if (data.target && data.execResult && data.execResult.length) {
            let providerMap = data.providerMap;
            data.injecteds = data.injecteds || {};
            data.execResult.forEach((prop, idx) => {
                if (prop && !data.injecteds[prop.propertyKey]) {
                    let token = prop.provider ? container.getToken(prop.provider, prop.alias) : prop.type;
                    let pdrMap = container.get(new InjectReference_1.InjectReference(providers.ProviderMap, data.targetType));
                    if (token === IContainer.ContainerToken) {
                        Object.defineProperty(data.target, prop.propertyKey, { enumerable: false, writable: true });
                    }
                    if (pdrMap && pdrMap.has(token)) {
                        data.target[prop.propertyKey] = pdrMap.resolve(token, providerMap);
                        data.injecteds[prop.propertyKey] = true;
                    }
                    else if (providerMap && providerMap.has(token)) {
                        data.target[prop.propertyKey] = providerMap.resolve(token, providerMap);
                        data.injecteds[prop.propertyKey] = true;
                    }
                    else if (container.has(token)) {
                        data.target[prop.propertyKey] = container.resolve(token, providerMap);
                        data.injecteds[prop.propertyKey] = true;
                    }
                }
            });
        }
    }
    static getClassAnnations() {
        return { "name": "InjectPropertyAction", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.InjectPropertyAction = InjectPropertyAction;


});

unwrapExports(InjectPropertyAction_1);
var InjectPropertyAction_2 = InjectPropertyAction_1.InjectPropertyAction;

var BindParameterProviderAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * bind parameters action.
 *
 * @export
 * @class BindParameterProviderAction
 * @extends {ActionComposite}
 */
class BindParameterProviderAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.bindParameterProviders);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        let type = data.targetType;
        let propertyKey = data.propertyKey;
        let lifeScope = container.getLifeScope();
        let matchs = lifeScope.getMethodDecorators(type, surm => surm.actions.includes(CoreActions_1.CoreActions.bindParameterProviders) && factories.hasOwnMethodMetadata(surm.name, type));
        let providers = [];
        matchs.forEach(surm => {
            let methodmtas = factories.getOwnMethodMetadata(surm.name, type);
            let metadatas = methodmtas[propertyKey];
            if (metadatas && utils.isArray(metadatas) && metadatas.length > 0) {
                metadatas.forEach(meta => {
                    if (meta.providers && meta.providers.length > 0) {
                        providers = providers.concat(meta.providers);
                    }
                });
            }
        });
        data.execResult = providers;
    }
    static getClassAnnations() {
        return { "name": "BindParameterProviderAction", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.BindParameterProviderAction = BindParameterProviderAction;


});

unwrapExports(BindParameterProviderAction_1);
var BindParameterProviderAction_2 = BindParameterProviderAction_1.BindParameterProviderAction;

var ComponentBeforeInitAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * component before init action, to run @Component decorator class before init hooks.
 *
 * @export
 * @class ComponentBeforeInitAction
 * @extends {ActionComposite}
 */
class ComponentBeforeInitAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.componentBeforeInit);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.targetType && data.target) {
            if (container.getLifeScope().hasDecorator(data.targetType, factories.DecoratorType.Class, surm => surm.actions.includes(CoreActions_1.CoreActions.componentBeforeInit))) {
                let component = data.target;
                if (utils.isFunction(component.beforeInit)) {
                    container.syncInvoke(data.target || data.targetType, 'beforeInit', data.target);
                }
            }
        }
    }
    static getClassAnnations() {
        return { "name": "ComponentBeforeInitAction", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.ComponentBeforeInitAction = ComponentBeforeInitAction;


});

unwrapExports(ComponentBeforeInitAction_1);
var ComponentBeforeInitAction_2 = ComponentBeforeInitAction_1.ComponentBeforeInitAction;

var ComponentInitAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * component before init action, to run @Component decorator class before init hooks.
 *
 * @export
 * @class ComponentInitAction
 * @extends {ActionComposite}
 */
class ComponentInitAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.componentInit);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.targetType && data.target) {
            if (container.getLifeScope().hasDecorator(data.targetType, factories.DecoratorType.Class, surm => surm.actions.includes(CoreActions_1.CoreActions.componentInit))) {
                let component = data.target;
                if (utils.isFunction(component.onInit)) {
                    container.syncInvoke(data.target || data.targetType, 'onInit', data.target);
                }
            }
        }
    }
    static getClassAnnations() {
        return { "name": "ComponentInitAction", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.ComponentInitAction = ComponentInitAction;


});

unwrapExports(ComponentInitAction_1);
var ComponentInitAction_2 = ComponentInitAction_1.ComponentInitAction;

var ComponentAfterInitAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * component after init action, to run @Component decorator class after init hooks.
 *
 * @export
 * @class ComponentAfterInitAction
 * @extends {ActionComposite}
 */
class ComponentAfterInitAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.componentAfterInit);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.targetType && data.target) {
            if (container.getLifeScope().hasDecorator(data.targetType, factories.DecoratorType.Class, surm => surm.actions.includes(CoreActions_1.CoreActions.componentAfterInit))) {
                let component = data.target;
                if (utils.isFunction(component.afterInit)) {
                    container.syncInvoke(data.target || data.targetType, 'afterInit', data.target);
                }
            }
        }
    }
    static getClassAnnations() {
        return { "name": "ComponentAfterInitAction", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.ComponentAfterInitAction = ComponentAfterInitAction;


});

unwrapExports(ComponentAfterInitAction_1);
var ComponentAfterInitAction_2 = ComponentAfterInitAction_1.ComponentAfterInitAction;

var ICacheManager = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * ICacheManager interface token.
 * it is a token id, you can register yourself ICacheManager for this.
 */
exports.CacheManagerToken = new InjectToken_1.InjectToken('DI_ICacheManager');


});

unwrapExports(ICacheManager);
var ICacheManager_1 = ICacheManager.CacheManagerToken;

var CacheAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * cache action. To cache instance of Token. define cache expires in decorator.
 *
 * @export
 * @class CacheAction
 * @extends {ActionComposite}
 */
class CacheAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.cache);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return data;
        }
        if (data.singleton || !data.targetType || !utils.isClass(data.targetType)) {
            return data;
        }
        let cacheManager = container.get(ICacheManager.CacheManagerToken);
        if (data.target) {
            if (!cacheManager.hasCache(data.targetType)) {
                let cacheMetadata = this.getCacheMetadata(container, data);
                if (cacheMetadata) {
                    cacheManager.cache(data.targetType, data.target, cacheMetadata.expires);
                }
            }
        }
        else {
            let target = cacheManager.get(data.targetType);
            if (target) {
                let cacheMetadata = this.getCacheMetadata(container, data);
                if (cacheMetadata) {
                    cacheManager.cache(data.targetType, target, cacheMetadata.expires);
                    data.execResult = target;
                }
            }
        }
        return data;
    }
    getCacheMetadata(container, data) {
        let lifeScope = container.getLifeScope();
        let matchs = lifeScope.getClassDecorators(data.targetType);
        let cacheMetadata;
        for (let i = 0; i < matchs.length; i++) {
            let surm = matchs[i];
            let metadata = factories.getOwnTypeMetadata(surm.name, data.targetType);
            if (Array.isArray(metadata) && metadata.length > 0) {
                cacheMetadata = metadata.find(c => c && utils.isNumber(c.expires) && c.expires > 0);
                if (cacheMetadata) {
                    break;
                }
            }
        }
        return cacheMetadata;
    }
    static getClassAnnations() {
        return { "name": "CacheAction", "params": { "constructor": [], "working": ["container", "data"], "getCacheMetadata": ["container", "data"] } };
    }
}
exports.CacheAction = CacheAction;


});

unwrapExports(CacheAction_1);
var CacheAction_2 = CacheAction_1.CacheAction;

var SingletonAction = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * singleton action, to set the factory of Token as singleton.
 *
 * @export
 * @class SingletionAction
 * @extends {ActionComposite}
 */
class SingletionAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.singletion);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.tokenKey && data.target && data.singleton) {
            container.registerValue(data.tokenKey, data.target);
        }
    }
    static getClassAnnations() {
        return { "name": "SingletionAction", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.SingletionAction = SingletionAction;


});

unwrapExports(SingletonAction);
var SingletonAction_1 = SingletonAction.SingletionAction;

var AutoRun = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Autorun decorator, for class or method.  use to define the class auto run (via a method or not) after registered.
 *
 * @Autorun
 */
exports.Autorun = factories.createClassMethodDecorator('Autorun', args => {
    args.next({
        isMetadata: (arg) => utils.isClassMetadata(arg, 'autorun'),
        match: (arg) => utils.isString(arg) || utils.isNumber(arg),
        setMetadata: (metadata, arg) => {
            if (utils.isString(arg)) {
                metadata.autorun = arg;
            }
            else {
                metadata.order = arg;
            }
        }
    });
}, (metadata) => {
    metadata.singleton = true;
    return metadata;
});


});

unwrapExports(AutoRun);
var AutoRun_1 = AutoRun.Autorun;

var IocExt = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.
 *
 * @IocExt
 */
exports.IocExt = factories.createClassDecorator('IocExt', args => {
    args.next({
        isMetadata: (arg) => utils.isClassMetadata(arg, 'autorun'),
        match: (arg) => utils.isString(arg),
        setMetadata: (metadata, arg) => {
            metadata.autorun = arg;
        }
    });
}, (metadata) => {
    metadata.singleton = true;
    return metadata;
});
exports.IocModule = exports.IocExt;


});

unwrapExports(IocExt);
var IocExt_1 = IocExt.IocExt;
var IocExt_2 = IocExt.IocModule;

var AutorunAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });






/**
 * Inject DrawType action.
 *
 * @export
 * @class SetPropAction
 * @extends {ActionComposite}
 */
class AutorunAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.autorun);
    }
    getDecorator() {
        return [IocExt.IocExt, AutoRun.Autorun];
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.tokenKey && data.targetType) {
            let decorators = this.getDecorator();
            decorators.forEach(decorator => {
                if (factories.hasClassMetadata(decorator, data.targetType)) {
                    let metas = factories.getTypeMetadata(decorator, data.targetType);
                    let meta = metas.find(it => !!it.autorun);
                    if (!meta && metas.length) {
                        meta = metas[0];
                    }
                    if (meta) {
                        let instance = container.get(data.tokenKey);
                        if (instance && meta.autorun && utils.isFunction(instance[meta.autorun])) {
                            container.syncInvoke(instance, meta.autorun);
                        }
                    }
                }
            });
        }
    }
    static getClassAnnations() {
        return { "name": "AutorunAction", "params": { "constructor": [], "getDecorator": [], "working": ["container", "data"] } };
    }
}
exports.AutorunAction = AutorunAction;


});

unwrapExports(AutorunAction_1);
var AutorunAction_2 = AutorunAction_1.AutorunAction;

var actions = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(ActionComposite_1, exports);
tslib_1.__exportStar(LifeState_1, exports);
tslib_1.__exportStar(CoreActions_1, exports);
tslib_1.__exportStar(NullAction, exports);
tslib_1.__exportStar(BindProviderAction_1, exports);
tslib_1.__exportStar(BindParameterTypeAction_1, exports);
tslib_1.__exportStar(BindPropertyTypeAction_1, exports);
tslib_1.__exportStar(InjectPropertyAction_1, exports);
tslib_1.__exportStar(BindParameterProviderAction_1, exports);
tslib_1.__exportStar(ComponentBeforeInitAction_1, exports);
tslib_1.__exportStar(ComponentInitAction_1, exports);
tslib_1.__exportStar(ComponentAfterInitAction_1, exports);
tslib_1.__exportStar(CacheAction_1, exports);
tslib_1.__exportStar(SingletonAction, exports);
tslib_1.__exportStar(AutorunAction_1, exports);


});

unwrapExports(actions);

var basic = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * define the property enumerable of not.
 *
 * @export
 * @param {boolean} value
 * @returns
 */
function enumerable(value) {
    return function (target, propertyKey, descriptor) {
        if (descriptor) {
            descriptor.enumerable = value;
        }
        else {
            descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || { writable: true };
            descriptor.enumerable = value;
            Object.defineProperty(target, propertyKey, descriptor);
        }
    };
}
exports.enumerable = enumerable;
function configurable(value) {
    return function (target, propertyKey, descriptor) {
        if (descriptor) {
            descriptor.configurable = value;
        }
        else {
            descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || { writable: true };
            descriptor.configurable = value;
            Object.defineProperty(target, propertyKey, descriptor);
        }
    };
}
exports.configurable = configurable;
/**
 * define class is sealed.
 *
 * @param {Function} constructor
 */
function sealed(constructor) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}
exports.sealed = sealed;


});

unwrapExports(basic);
var basic_1 = basic.enumerable;
var basic_2 = basic.configurable;
var basic_3 = basic.sealed;

var Component = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Component decorator, define for class. use to define the class. it can setting provider to some token, singleton or not. it will execute  [`ComponentLifecycle`]
 *
 * @Component
 */
exports.Component = factories.createClassDecorator('Component');


});

unwrapExports(Component);
var Component_1 = Component.Component;

var Injectable = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Injectable decorator, define for class.  use to define the class. it can setting provider to some token, singleton or not.
 *
 * @Injectable
 */
exports.Injectable = factories.createClassDecorator('Injectable');


});

unwrapExports(Injectable);
var Injectable_1 = Injectable.Injectable;

var Refs = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Refs decorator, for class. use to define the class as service of target.
 *
 * @Refs
 */
exports.Refs = factories.createDecorator('Refs', ((args) => {
    args.next({
        match: arg => utils.isToken(arg),
        setMetadata: (metadata, arg) => {
            metadata.refs = { target: arg };
        }
    });
    args.next({
        match: arg => utils.isToken(arg),
        setMetadata: (metadata, arg) => {
            metadata.refs.provide = arg;
        }
    });
    args.next({
        match: arg => utils.isString(arg),
        setMetadata: (metadata, arg) => {
            metadata.refs.alias = arg;
        }
    });
}));


});

unwrapExports(Refs);
var Refs_1 = Refs.Refs;

var Providers = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Providers decorator, for class. use to add ref service to the class.
 *
 * @Providers
 */
exports.Providers = factories.createDecorator('Providers', ((args) => {
    args.next({
        match: arg => utils.isArray(arg),
        setMetadata: (metadata, arg) => {
            metadata.providers = arg;
        }
    });
}));


});

unwrapExports(Providers);
var Providers_1 = Providers.Providers;

var Inject = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Inject decorator, for property or param, use to auto wried type instance or value to the instance of one class with the decorator.
 *
 * @Inject
 */
exports.Inject = factories.createParamPropDecorator('Inject');


});

unwrapExports(Inject);
var Inject_1 = Inject.Inject;

var AutoWried = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * AutoWired decorator, for property or param. use to auto wried type instance or value to the instance of one class with the decorator.
 *
 * @AutoWired
 */
exports.AutoWired = factories.createParamPropDecorator('AutoWired');


});

unwrapExports(AutoWried);
var AutoWried_1 = AutoWried.AutoWired;

var Param = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * param decorator, define for parameter. use to auto wried type instance or value to the instance of one class with the decorator.
 *
 * @Param
 */
exports.Param = factories.createParamDecorator('Param');


});

unwrapExports(Param);
var Param_1 = Param.Param;

var Method = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * method decorator.
 *
 * @Method
 */
exports.Method = factories.createMethodDecorator('Method');


});

unwrapExports(Method);
var Method_1 = Method.Method;

var Singleton = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Singleton decorator, for class. use to define the class is singleton.
 *
 * @Singleton
 */
exports.Singleton = factories.createClassDecorator('Singleton', null, (metadata) => {
    metadata.singleton = true;
    return metadata;
});


});

unwrapExports(Singleton);
var Singleton_1 = Singleton.Singleton;

var Abstract = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Abstract decorator. define for class.
 *
 * @Abstract
 */
exports.Abstract = factories.createClassDecorator('Abstract');


});

unwrapExports(Abstract);
var Abstract_1 = Abstract.Abstract;

var decorators = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(basic, exports);
tslib_1.__exportStar(Component, exports);
tslib_1.__exportStar(Injectable, exports);
tslib_1.__exportStar(Refs, exports);
tslib_1.__exportStar(Providers, exports);
tslib_1.__exportStar(Inject, exports);
tslib_1.__exportStar(AutoWried, exports);
tslib_1.__exportStar(Param, exports);
tslib_1.__exportStar(Method, exports);
tslib_1.__exportStar(Singleton, exports);
tslib_1.__exportStar(Abstract, exports);
tslib_1.__exportStar(AutoRun, exports);
tslib_1.__exportStar(IocExt, exports);


});

unwrapExports(decorators);

var IRecognizer = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * IRecognizer interface token.
 * it is a token id, you can register yourself IRecognizer for this.
 */
exports.RecognizerToken = new InjectToken_1.InjectToken('DI_IRecognizer');


});

unwrapExports(IRecognizer);
var IRecognizer_1 = IRecognizer.RecognizerToken;

var MethodAutorun_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * Inject DrawType action.
 *
 * @export
 * @class SetPropAction
 * @extends {ActionComposite}
 */
class MethodAutorun extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.methodAutorun);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.target && data.targetType) {
            if (factories.hasMethodMetadata(decorators.Autorun, data.targetType)) {
                let metas = factories.getMethodMetadata(decorators.Autorun, data.targetType);
                let lastmetas = [];
                let idx = utils.lang.keys(metas).length;
                utils.lang.forIn(metas, (mm, key) => {
                    if (mm && mm.length) {
                        let m = mm[0];
                        m.autorun = key;
                        idx++;
                        if (!utils.isNumber(m.order)) {
                            m.order = idx;
                        }
                        lastmetas.push(m);
                    }
                });
                lastmetas.sort((au1, au2) => {
                    return au1.order - au1.order;
                }).forEach(aut => {
                    container.syncInvoke(data.target || data.targetType, aut.autorun, data.target);
                });
            }
        }
    }
    static getClassAnnations() {
        return { "name": "MethodAutorun", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.MethodAutorun = MethodAutorun;


});

unwrapExports(MethodAutorun_1);
var MethodAutorun_2 = MethodAutorun_1.MethodAutorun;

var ActionFactory_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * action factory.
 *
 * @export
 * @class ActionFactory
 */
class ActionFactory {
    /**
     * create action by action type. type in 'CoreActions'
     *
     * @param {string} type
     * @returns {ActionComponent}
     * @memberof ActionFactory
     */
    create(type) {
        let action;
        switch (type) {
            case actions.CoreActions.bindParameterType:
                action = new actions.BindParameterTypeAction();
                break;
            case actions.CoreActions.bindPropertyType:
                action = new actions.BindPropertyTypeAction();
                break;
            case actions.CoreActions.injectProperty:
                action = new actions.InjectPropertyAction();
                break;
            case actions.CoreActions.bindProvider:
                action = new actions.BindProviderAction();
                break;
            case actions.CoreActions.bindParameterProviders:
                action = new actions.BindParameterProviderAction();
                break;
            case actions.CoreActions.componentInit:
                action = new actions.ComponentInitAction();
                break;
            case actions.CoreActions.componentBeforeInit:
                action = new actions.ComponentBeforeInitAction();
                break;
            case actions.CoreActions.componentAfterInit:
                action = new actions.ComponentAfterInitAction();
                break;
            case actions.CoreActions.cache:
                action = new actions.CacheAction();
                break;
            case actions.CoreActions.singletion:
                action = new actions.SingletionAction();
                break;
            case actions.CoreActions.autorun:
                action = new actions.AutorunAction();
                break;
            case actions.CoreActions.methodAutorun:
                action = new MethodAutorun_1.MethodAutorun();
                break;
            default:
                action = new actions.ActionComposite(type);
                break;
        }
        return action;
    }
    static getClassAnnations() {
        return { "name": "ActionFactory", "params": { "create": ["type"] } };
    }
}
exports.ActionFactory = ActionFactory;


});

unwrapExports(ActionFactory_1);
var ActionFactory_2 = ActionFactory_1.ActionFactory;

var IMetaAccessor = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * application service token.
 *
 * @export
 * @class InjectMetaAccessorToken
 * @extends {Registration<MetaAccessor<T>>}
 * @template T
 */
class InjectMetaAccessorToken extends InjectReference_1.RefRegistration {
    constructor(type) {
        super(type, 'metaAccessor');
    }
    static getClassAnnations() {
        return { "name": "InjectMetaAccessorToken", "params": { "constructor": ["type"] } };
    }
}
exports.InjectMetaAccessorToken = InjectMetaAccessorToken;
/**
 * MetaAccessor token.
 */
exports.MetaAccessorToken = new InjectMetaAccessorToken(Object);


});

unwrapExports(IMetaAccessor);
var IMetaAccessor_1 = IMetaAccessor.InjectMetaAccessorToken;
var IMetaAccessor_2 = IMetaAccessor.MetaAccessorToken;

var DefaultLifeScope_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });







/**
 * default implement life scope.
 *
 * @export
 * @class DefaultLifeScope
 * @implements {LifeScope}
 */
class DefaultLifeScope {
    constructor(container) {
        this.container = container;
        this.decorators = [];
        this.buildAction();
    }
    addAction(action, ...nodepaths) {
        let parent = this.action;
        nodepaths.forEach(pathname => {
            parent = parent.find(act => act.name === pathname);
        });
        if (parent) {
            parent.add(action);
        }
        return this;
    }
    registerDecorator(decorator, ...actions$$2) {
        let type = this.getDecoratorType(decorator);
        return this.registerCustomDecorator(decorator, type, ...actions$$2);
    }
    registerCustomDecorator(decorator, type, ...actions$$2) {
        let types$$2 = this.toActionName(type);
        let name = decorator.toString();
        if (!this.decorators.some(d => d.name === name)) {
            this.decorators.push({
                name: name,
                types: types$$2,
                actions: actions$$2
            });
        }
        return this;
    }
    execute(data, ...names) {
        names = names.filter(n => !!n);
        let act = this.action;
        names.forEach(name => {
            act = act.find(itm => itm.name === name);
        });
        if (act) {
            act.execute(this.container, data);
        }
    }
    routeExecute(data, ...names) {
        this.execute(data, ...names);
        let container = this.container.parent;
        while (container) {
            container.getLifeScope().execute(utils.lang.assign({}, data), ...names);
            container = container.parent;
        }
    }
    hasDecorator(target, dtype, match) {
        let decors;
        switch (dtype) {
            case factories.DecoratorType.Class:
                decors = factories.getClassDecorators(target);
                break;
            case factories.DecoratorType.Property:
                decors = factories.getPropDecorators(target);
                break;
            case factories.DecoratorType.Parameter:
                decors = factories.getParamDecorators(target);
                break;
            case factories.DecoratorType.Method:
                decors = factories.getMethodDecorators(target);
                break;
        }
        if (decors) {
            return decors.some(dec => this.decorators.some(d => d.name === dec && match(d)));
        }
        return false;
    }
    getClassDecorators(type, match) {
        return factories.getClassDecorators(type)
            .map(dec => this.decorators.find(d => d.name === dec))
            .filter(d => d && (match ? match(d) : true));
    }
    getMethodDecorators(type, match) {
        return factories.getMethodDecorators(type)
            .map(dec => this.decorators.find(d => d.name === dec))
            .filter(d => d && (match ? match(d) : true));
    }
    getPropertyDecorators(type, match) {
        return factories.getPropDecorators(type)
            .map(dec => this.decorators.find(d => d.name === dec))
            .filter(d => d && (match ? match(d) : true));
    }
    getParameterDecorators(target, propertyKey, match) {
        return factories.getParamDecorators(target, propertyKey)
            .map(dec => this.decorators.find(d => d.name === dec))
            .filter(d => d && (match ? match(d) : true));
    }
    getDecoratorType(decirator) {
        return decirator.decoratorType || factories.DecoratorType.All;
    }
    /**
     * is vaildate dependence type or not. dependence type must with class decorator.
     *
     * @template T
     * @param {Type<T>} target
     * @returns {boolean}
     * @memberof Container
     */
    isVaildDependence(target) {
        if (!target) {
            return false;
        }
        if (!utils.isClass(target)) {
            return false;
        }
        if (utils.isAbstractClass(target)) {
            return false;
        }
        return this.getClassDecorators(target).length > 0;
    }
    getAtionByName(name) {
        return this.action.find(action => action.name === name);
    }
    getClassAction() {
        return this.getAtionByName(this.toActionName(factories.DecoratorType.Class));
    }
    getMethodAction() {
        return this.getAtionByName(this.toActionName(factories.DecoratorType.Method));
    }
    getPropertyAction() {
        return this.getAtionByName(this.toActionName(factories.DecoratorType.Property));
    }
    getParameterAction() {
        return this.getAtionByName(this.toActionName(factories.DecoratorType.Parameter));
    }
    /**
     * get constructor parameters metadata.
     *
     * @template T
     * @param {Type<T>} type
     * @returns {IParameter[]}
     * @memberof IContainer
     */
    getConstructorParameters(type) {
        return this.getParameters(type);
    }
    /**
     * get method params metadata.
     *
     * @template T
     * @param {Type<T>} type
     * @param {T} instance
     * @param {(string | symbol)} propertyKey
     * @returns {IParameter[]}
     * @memberof IContainer
     */
    getMethodParameters(type, instance, propertyKey) {
        return this.getParameters(type, instance, propertyKey);
    }
    /**
     * get paramerter names.
     *
     * @template T
     * @param {Type<T>} type
     * @param {string} propertyKey
     * @returns {string[]}
     * @memberof DefaultLifeScope
     */
    getParamerterNames(type, propertyKey) {
        let metadata = factories.getOwnParamerterNames(type);
        let paramNames = [];
        if (metadata && metadata.hasOwnProperty(propertyKey)) {
            paramNames = metadata[propertyKey];
        }
        if (!utils.isArray(paramNames)) {
            paramNames = [];
        }
        return paramNames;
    }
    isSingletonType(type) {
        if (factories.hasOwnClassMetadata(Singleton.Singleton, type)) {
            return true;
        }
        let metadata = this.container.get(IMetaAccessor.MetaAccessorToken).find(type, this.container, m => m.singleton === true);
        return !!metadata;
    }
    getMethodMetadatas(type, propertyKey) {
        let metadatas = [];
        this.getMethodDecorators(type)
            .forEach(dec => {
            let metas = factories.getOwnMethodMetadata(dec.name, type);
            if (metas.hasOwnProperty(propertyKey)) {
                metadatas = metadatas.concat(metas[propertyKey] || []);
            }
        });
        return metadatas;
    }
    filerDecorators(express) {
        return this.decorators.filter(express);
    }
    getParameters(type, instance, propertyKey) {
        propertyKey = propertyKey || 'constructor';
        let data = {
            target: instance,
            targetType: type,
            propertyKey: propertyKey
        };
        this.execute(data, actions.LifeState.onInit, actions.CoreActions.bindParameterType);
        let paramNames = this.getParamerterNames(type, propertyKey);
        if (data.execResult.length) {
            return data.execResult.map((typ, idx) => {
                return {
                    type: typ,
                    name: paramNames[idx]
                };
            });
        }
        else {
            return paramNames.map(name => {
                return {
                    name: name,
                    type: undefined
                };
            });
        }
    }
    getTypeDecorators(decType, match) {
        return this.filerDecorators(value => {
            let flag = (value.types || '').indexOf(decType) >= 0;
            if (flag && match) {
                flag = match(value);
            }
            return flag;
        });
    }
    buildAction() {
        let factory = new ActionFactory_1.ActionFactory();
        let action = factory.create('');
        action
            .add(factory.create(types.IocState.design)
            .add(factory.create(actions.CoreActions.bindProvider))
            .add(factory.create(actions.CoreActions.autorun)))
            .add(factory.create(types.IocState.runtime)
            .add(factory.create(actions.LifeState.beforeCreateArgs))
            .add(factory.create(actions.LifeState.beforeConstructor))
            .add(factory.create(actions.LifeState.afterConstructor))
            .add(factory.create(actions.LifeState.onInit)
            .add(factory.create(actions.CoreActions.componentBeforeInit))
            .add(factory.create(this.toActionName(factories.DecoratorType.Class)))
            .add(factory.create(this.toActionName(factories.DecoratorType.Method)))
            .add(factory.create(this.toActionName(factories.DecoratorType.Property))
            .add(factory.create(actions.CoreActions.bindPropertyType))
            .add(factory.create(actions.CoreActions.injectProperty)))
            .add(factory.create(this.toActionName(factories.DecoratorType.Parameter))
            .add(factory.create(actions.CoreActions.bindParameterType))
            .add(factory.create(actions.CoreActions.bindParameterProviders)))
            .add(factory.create(actions.CoreActions.componentInit)))
            .add(factory.create(actions.LifeState.AfterInit)
            .add(factory.create(actions.CoreActions.singletion))
            .add(factory.create(actions.CoreActions.componentAfterInit))
            .add(factory.create(actions.CoreActions.methodAutorun))))
            .add(factory.create(actions.CoreActions.cache));
        this.action = action;
    }
    toActionName(type) {
        let types$$2 = [];
        if (type & factories.DecoratorType.Class) {
            types$$2.push('ClassDecorator');
        }
        if (type & factories.DecoratorType.Method) {
            types$$2.push('MethodDecorator');
        }
        if (type & factories.DecoratorType.Property) {
            types$$2.push('PropertyDecorator');
        }
        if (type & factories.DecoratorType.Parameter) {
            types$$2.push('ParameterDecorator');
        }
        return types$$2.join(',');
    }
    static getClassAnnations() {
        return { "name": "DefaultLifeScope", "params": { "constructor": ["container"], "addAction": ["action", "nodepaths"], "registerDecorator": ["decorator", "actions"], "registerCustomDecorator": ["decorator", "type", "actions"], "execute": ["data", "names"], "routeExecute": ["data", "names"], "hasDecorator": ["target", "dtype", "match"], "getClassDecorators": ["type", "match"], "getMethodDecorators": ["type", "match"], "getPropertyDecorators": ["type", "match"], "getParameterDecorators": ["target", "propertyKey", "match"], "getDecoratorType": ["decirator"], "isVaildDependence": ["target"], "getAtionByName": ["name"], "getClassAction": [], "getMethodAction": [], "getPropertyAction": [], "getParameterAction": [], "getConstructorParameters": ["type"], "getMethodParameters": ["type", "instance", "propertyKey"], "getParamerterNames": ["type", "propertyKey"], "isSingletonType": ["type"], "getMethodMetadatas": ["type", "propertyKey"], "filerDecorators": ["express"], "getParameters": ["type", "instance", "propertyKey"], "getTypeDecorators": ["decType", "match"], "buildAction": [], "toActionName": ["type"] } };
    }
}
exports.DefaultLifeScope = DefaultLifeScope;


});

unwrapExports(DefaultLifeScope_1);
var DefaultLifeScope_2 = DefaultLifeScope_1.DefaultLifeScope;

var MetaAccessor_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * class metadata accessor.
 *
 * @export
 * @class MetaAccessor
 * @implements {IMetaAccessor<any>}
 */
class MetaAccessor {
    constructor() {
    }
    getDecorators(type) {
        return factories.getClassDecorators(type);
    }
    /**
     * get metadata config of target type. via decorators in order.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {IAnnotationMetadata<any>} [extConfig]
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>}
     * @memberof MetaAccessor
     */
    getMetadata(token, container, extConfig, decorFilter) {
        let type = utils.isClass(token) ? token : container.getTokenImpl(token);
        let cfg;
        if (utils.isClass(type)) {
            let decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            let classmeta = {};
            decors.forEach(decor => {
                let metas = factories.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    metas.forEach(meta => {
                        if (meta) {
                            classmeta = utils.lang.assign({}, classmeta, meta);
                        }
                    });
                }
            });
            cfg = classmeta;
        }
        if (cfg) {
            return utils.lang.assign({}, cfg, extConfig || {});
        }
        else {
            return extConfig || {};
        }
    }
    /**
     * find metadata accessor.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {Express<IAnnotationMetadata<any>, boolean>} filter
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>}
     * @memberof MetaAccessor
     */
    find(token, container, filter, decorFilter) {
        let type = utils.isClass(token) ? token : container.getTokenImpl(token);
        let metadata = null;
        if (utils.isClass(type)) {
            let decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            decors.some(decor => {
                let metas = factories.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    return metas.some(meta => {
                        if (meta && filter(meta)) {
                            metadata = meta;
                        }
                        return !!metadata;
                    });
                }
                return false;
            });
        }
        return metadata;
    }
    /**
     * filter metadata accessor.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {Express<IAnnotationMetadata<any>, boolean>} filter
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>[]}
     * @memberof MetaAccessor
     */
    filter(token, container, filter, decorFilter) {
        let type = utils.isClass(token) ? token : container.getTokenImpl(token);
        let metadatas = [];
        if (utils.isClass(type)) {
            let decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            decors.forEach(decor => {
                let metas = factories.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    metas.filter(meta => meta && filter(meta)).forEach(meta => {
                        metadatas.push(meta);
                    });
                }
            });
        }
        return metadatas;
    }
    /**
     * get token of metadata config.
     *
     * @param {IAnnotationMetadata<any>} config
     * @param {IContainer} [container] vaild token in container or not.
     * @returns {Token<any>}
     * @memberof MetadataManager
     */
    getToken(config, container) {
        let token = this.getTokenInConfig(config);
        if (this.validateToken(token, container)) {
            return token;
        }
        else {
            return null;
        }
    }
    /**
     * get module boot token from module configure.
     *
     * @param {IAnnotationMetadata<any>} config
     * @param {IContainer} [container]  vaild container.
     * @returns {Token<any>}
     * @memberof ModuelValidate
     */
    getBootToken(config, container) {
        let token = this.getBootTokenInConfig(config);
        if (this.validateToken(token, container)) {
            return token;
        }
        else {
            return null;
        }
    }
    validateToken(token, container) {
        return utils.isToken(token);
    }
    getTokenInConfig(config) {
        return config.token || config.type;
    }
    getBootTokenInConfig(config) {
        return config.bootstrap;
    }
    static getClassAnnations() {
        return { "name": "MetaAccessor", "params": { "constructor": [], "getDecorators": ["type"], "getMetadata": ["token", "container", "extConfig", "decorFilter"], "find": ["token", "container", "filter", "decorFilter"], "filter": ["token", "container", "filter", "decorFilter"], "getToken": ["config", "container"], "getBootToken": ["config", "container"], "validateToken": ["token", "container"], "getTokenInConfig": ["config"], "getBootTokenInConfig": ["config"] } };
    }
}
exports.MetaAccessor = MetaAccessor;


});

unwrapExports(MetaAccessor_1);
var MetaAccessor_2 = MetaAccessor_1.MetaAccessor;

var MethodAccessor_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * method accessor
 *
 * @export
 * @class MethodAccessor
 * @implements {IMethodAccessor}
 */
class MethodAccessor {
    constructor(container) {
        this.container = container;
    }
    invoke(target, propertyKey, instance, ...providers$$2) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let targetClass;
            if (providers.isProvider(instance)) {
                providers$$2.unshift(instance);
                instance = undefined;
            }
            if (utils.isToken(target)) {
                if (utils.isNullOrUndefined(instance)) {
                    targetClass = this.container.getTokenImpl(target);
                    instance = this.container.resolve(target, ...providers$$2);
                }
                else {
                    targetClass = utils.lang.getClass(instance) || this.container.getTokenImpl(target);
                }
                utils.lang.assert(targetClass, target.toString() + ' is not implements by any class.');
            }
            else {
                targetClass = utils.lang.getClass(target);
                instance = target;
            }
            utils.lang.assertExp(instance && utils.isFunction(instance[propertyKey]), `type: ${targetClass} has no method ${propertyKey.toString()}.`);
            let actionData = {
                target: instance,
                targetType: targetClass,
                propertyKey: propertyKey,
            };
            let lifeScope = this.container.getLifeScope();
            lifeScope.execute(actionData, actions.LifeState.onInit, actions.CoreActions.bindParameterProviders);
            providers$$2 = providers$$2.concat(actionData.execResult);
            let parameters = lifeScope.getMethodParameters(targetClass, instance, propertyKey);
            let paramInstances = yield this.createParams(parameters, ...providers$$2);
            return instance[propertyKey](...paramInstances);
        });
    }
    syncInvoke(target, propertyKey, instance, ...providers$$2) {
        let targetClass;
        if (providers.isProvider(instance)) {
            providers$$2.unshift(instance);
            instance = undefined;
        }
        if (utils.isToken(target)) {
            targetClass = this.container.getTokenImpl(target);
            utils.lang.assert(targetClass, target.toString() + ' is not implements by any class.');
            if (utils.isNullOrUndefined(instance)) {
                instance = this.container.resolve(target, ...providers$$2);
            }
        }
        else {
            targetClass = utils.lang.getClass(target);
            instance = target;
        }
        utils.lang.assertExp(instance && utils.isFunction(instance[propertyKey]), `type: ${targetClass} has no method ${propertyKey.toString()}.`);
        let actionData = {
            target: instance,
            targetType: targetClass,
            propertyKey: propertyKey,
        };
        let lifeScope = this.container.getLifeScope();
        lifeScope.execute(actionData, actions.LifeState.onInit, actions.CoreActions.bindParameterProviders);
        providers$$2 = providers$$2.concat(actionData.execResult);
        let parameters = lifeScope.getMethodParameters(targetClass, instance, propertyKey);
        let paramInstances = this.createSyncParams(parameters, ...providers$$2);
        return instance[propertyKey](...paramInstances);
    }
    createSyncParams(params, ...providers$$2) {
        let providerMap = this.container.getProviderParser().parse(...providers$$2);
        return params.map((param, index) => {
            if (param.name && providerMap.has(param.name)) {
                return providerMap.resolve(param.name);
            }
            else if (utils.isToken(param.type)) {
                if (providerMap.has(param.type)) {
                    return providerMap.resolve(param.type);
                }
                return this.container.resolve(param.type, providerMap);
            }
            else {
                return undefined;
            }
        });
    }
    createParams(params, ...providers$$2) {
        let providerMap = this.container.getProviderParser().parse(...providers$$2);
        return Promise.all(params.map((param, index) => {
            if (param.name && providerMap.has(param.name)) {
                return providerMap.resolve(param.name);
            }
            else if (utils.isToken(param.type)) {
                if (providerMap.has(param.type)) {
                    return providerMap.resolve(param.type);
                }
                return this.container.resolve(param.type, providerMap);
            }
            else {
                return undefined;
            }
        }));
    }
    static getClassAnnations() {
        return { "name": "MethodAccessor", "params": { "constructor": ["container"], "invoke": ["target", "propertyKey", "instance", "providers"], "syncInvoke": ["target", "propertyKey", "instance", "providers"], "createSyncParams": ["params", "providers"], "createParams": ["params", "providers"] } };
    }
}
exports.MethodAccessor = MethodAccessor;


});

unwrapExports(MethodAccessor_1);
var MethodAccessor_2 = MethodAccessor_1.MethodAccessor;

var CacheManager_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * cache manager.
 *
 * @export
 * @class CacheManager
 * @implements {ICacheManager}
 */
class CacheManager {
    constructor(container) {
        this.container = container;
        this.cacheTokens = new Map();
    }
    isChecking() {
        return !!this.timeout;
    }
    hasCache(targetType) {
        return this.cacheTokens.has(targetType);
    }
    cache(targetType, target, expires) {
        let cache;
        if (this.hasCache(targetType)) {
            cache = this.cacheTokens.get(targetType);
            cache.expires = Date.now() + expires;
        }
        else {
            cache = {
                target: target,
                expires: Date.now() + expires
            };
        }
        this.cacheTokens.set(targetType, cache);
        if (!this.isChecking()) {
            this.checkExpires();
        }
    }
    get(targetType, expires) {
        let result = null;
        if (!this.cacheTokens.has(targetType)) {
            return null;
        }
        let cache = this.cacheTokens.get(targetType);
        if (cache.expires <= Date.now()) {
            result = cache.target;
            if (utils.isNumber(expires) && expires > 0) {
                cache.expires = Date.now() + expires;
                this.cacheTokens.set(targetType, cache);
            }
        }
        else {
            this.destroy(targetType, cache.target);
        }
        return result;
    }
    checkExpires() {
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = 0;
        }
        if (this.cacheTokens.size > 0) {
            let timeoutCaches = [];
            this.cacheTokens.forEach((cache, targetType) => {
                if (cache.expires >= Date.now()) {
                    timeoutCaches.push(targetType);
                }
            });
            if (timeoutCaches.length) {
                timeoutCaches.forEach(targetType => {
                    this.destroy(targetType, this.cacheTokens.get(targetType).target);
                });
            }
            this.timeout = setTimeout(() => {
                this.checkExpires();
            }, 60000);
        }
    }
    destroy(targetType, target) {
        if (!this.hasCache(targetType)) {
            return;
        }
        if (!target) {
            target = this.cacheTokens.get(targetType).target;
        }
        try {
            let component = target;
            if (utils.isFunction(component.onDestroy)) {
                this.container.syncInvoke(target || targetType, 'onDestroy', target);
            }
            this.cacheTokens.delete(targetType);
        }
        catch (err) {
            console.error && console.error(err);
        }
    }
    static getClassAnnations() {
        return { "name": "CacheManager", "params": { "constructor": ["container"], "isChecking": [], "hasCache": ["targetType"], "cache": ["targetType", "target", "expires"], "get": ["targetType", "expires"], "checkExpires": [], "destroy": ["targetType", "target"] } };
    }
}
exports.CacheManager = CacheManager;


});

unwrapExports(CacheManager_1);
var CacheManager_2 = CacheManager_1.CacheManager;

var core = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(actions, exports);
tslib_1.__exportStar(decorators, exports);
tslib_1.__exportStar(factories, exports);
tslib_1.__exportStar(IRecognizer, exports);
tslib_1.__exportStar(ActionFactory_1, exports);
tslib_1.__exportStar(DefaultLifeScope_1, exports);
tslib_1.__exportStar(IMetaAccessor, exports);
tslib_1.__exportStar(MetaAccessor_1, exports);
tslib_1.__exportStar(MethodAccessor_1, exports);
tslib_1.__exportStar(CacheManager_1, exports);


});

unwrapExports(core);

var IContainerBuilder = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * ContainerBuilder interface token.
 * it is a token id, you can register yourself IContainerBuilder for this.
 */
exports.ContainerBuilderToken = new InjectToken_1.InjectToken('DI_IContainerBuilder');


});

unwrapExports(IContainerBuilder);
var IContainerBuilder_1 = IContainerBuilder.ContainerBuilderToken;

var LifeScope = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * life scope interface symbol.
 * it is a symbol id, you can register yourself MethodAccessor for this.
 */
exports.LifeScopeToken = new InjectToken_1.InjectToken('DI_LifeScope');


});

unwrapExports(LifeScope);
var LifeScope_1 = LifeScope.LifeScopeToken;

var ResolverChain_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 *  resolver chain token.
 */
exports.ResolverChainToken = new InjectToken_1.InjectToken('di_ResolverChain');
/**
 * resover chain.
 *
 * resove by setp.
 *
 * @export
 * @class ResolverChain
 * @implements {IResolver}
 */
class ResolverChain {
    constructor(container) {
        this.container = container;
        this.resolvers = [];
    }
    get size() {
        return this.resolvers.length + 1;
    }
    /**
     * reigister next resolver.
     *
     * @param {IResolver} resolver
     * @memberof ResolverChain
     */
    next(resolver) {
        if (!this.hasResolver(resolver)) {
            this.resolvers.push(resolver);
        }
    }
    /**
     * has resolver or not.
     *
     * @param {IResolver} resolver
     * @returns
     * @memberof ResolverChain
     */
    hasResolver(resolver) {
        if (resolver === this.container) {
            return true;
        }
        return this.resolvers.indexOf(resolver) >= 0;
    }
    /**
     * resove token via registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof ResolverChain
     */
    resolve(token, resway, ...providers$$2) {
        let key = this.container.getTokenKey(token, utils.isString(resway) ? resway : null);
        let way;
        if (utils.isNumber(resway)) {
            way = resway;
        }
        else {
            if (resway) {
                providers$$2.unshift(resway);
            }
            way = IContainer.ResoveWay.all;
        }
        let providerMap;
        if (providers$$2.length) {
            if (providers$$2.length === 1 && providers.isProviderMap(providers$$2[0])) {
                providerMap = providers$$2[0];
            }
            else {
                providerMap = this.container.getProviderParser().parse(...providers$$2);
            }
        }
        if (providerMap && providerMap.has(token)) {
            return providerMap.resolve(token, providerMap);
        }
        if ((way & IContainer.ResoveWay.current) && this.container.hasRegister(key)) {
            return this.container.resolveValue(key, providerMap);
        }
        if ((way & IContainer.ResoveWay.traverse)) {
            let resolver = this.resolvers.find(r => r.has(key, IContainer.ResoveWay.nodes));
            if (resolver) {
                return resolver.resolve(key, IContainer.ResoveWay.nodes, providerMap);
            }
        }
        if (this.container.parent && (way & IContainer.ResoveWay.bubble)) {
            return this.container.parent.resolve(key, resway, providerMap);
        }
        return null;
    }
    /**
     * unregister token in registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @memberof ResolverChain
     */
    unregister(token, resway) {
        resway = resway || IContainer.ResoveWay.all;
        let tokenKey = this.container.getTokenKey(token);
        if (resway & IContainer.ResoveWay.current) {
            this.container.unregisterValue(tokenKey);
        }
        if (resway & IContainer.ResoveWay.traverse) {
            this.resolvers.forEach((r) => {
                if (utils.isFunction(r.unregister)) {
                    r.unregister(tokenKey, IContainer.ResoveWay.nodes);
                }
            });
        }
        if ((resway & IContainer.ResoveWay.bubble) && this.container.parent) {
            this.container.parent.unregister(token, resway);
        }
        return this;
    }
    /**
     * get token implements class in the registered resolver chain.
     *
     * @template T
     * @param {Token<T>} token
     * @returns {Type<T>}
     * @memberof ResolverChain
     */
    getTokenImpl(token, resway) {
        if (utils.isClass(token)) {
            return token;
        }
        resway = resway || IContainer.ResoveWay.nodes;
        let tokenKey = this.container.getTokenKey(token);
        let provider;
        if (resway & IContainer.ResoveWay.current) {
            provider = this.container.getTokenProvider(tokenKey);
        }
        if (!provider && (resway & IContainer.ResoveWay.traverse)) {
            this.resolvers.some((r) => {
                if (!utils.isFunction(r.getTokenImpl)) {
                    return false;
                }
                provider = r.getTokenImpl(tokenKey, IContainer.ResoveWay.nodes);
                return !!provider;
            });
        }
        if (!provider && (resway & IContainer.ResoveWay.bubble) && this.container.parent) {
            provider = this.container.parent.getTokenImpl(token, resway);
        }
        return provider || null;
    }
    /**
     * has token or not in the registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @returns {boolean}
     * @memberof ResolverChain
     */
    has(token, aliasOrway) {
        let key = this.container.getTokenKey(token, utils.isString(aliasOrway) ? aliasOrway : null);
        let resway = utils.isNumber(aliasOrway) ? aliasOrway : IContainer.ResoveWay.all;
        if ((resway & IContainer.ResoveWay.current) && this.container.hasRegister(key)) {
            return true;
        }
        if ((resway & IContainer.ResoveWay.traverse) && this.resolvers.some(r => r.has(key, IContainer.ResoveWay.nodes))) {
            return true;
        }
        if ((resway & IContainer.ResoveWay.bubble) && this.container.parent) {
            return this.container.parent.has(token, resway);
        }
        return false;
    }
    /**
     * resolver chain to array.
     *
     * @returns {IResolver[]}
     * @memberof ResolverChain
     */
    toArray(resway = IContainer.ResoveWay.all) {
        if (resway & IContainer.ResoveWay.nodes) {
            return [this.container].concat(this.resolvers);
        }
        else if (resway & IContainer.ResoveWay.current) {
            return [this.container];
        }
        else if (resway & IContainer.ResoveWay.traverse) {
            return this.resolvers;
        }
        return [];
    }
    forEach(callbackfn) {
        if (this.container.forEach(callbackfn) === false) {
            return false;
        }
        return !this.resolvers.some((r) => {
            if (utils.isFunction(r.forEach)) {
                return r.forEach(callbackfn) === false;
            }
            return false;
        });
    }
    /**
     * iterator all resolvers.
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void} callbackfn
     * @memberof ResolverChain
     */
    iterator(callbackfn, resway = IContainer.ResoveWay.all) {
        if (resway & IContainer.ResoveWay.current) {
            if (this.container.forEach(callbackfn) === false) {
                return false;
            }
        }
        if (resway & IContainer.ResoveWay.traverse) {
            if (this.resolvers.some((r) => {
                if (utils.isFunction(r.forEach)) {
                    return r.forEach(callbackfn) === false;
                }
                return false;
            })) {
                return false;
            }
        }
        if (this.container.parent && (resway & IContainer.ResoveWay.bubble)) {
            return this.container.parent.iterator(callbackfn, resway);
        }
    }
    static getClassAnnations() {
        return { "name": "ResolverChain", "params": { "constructor": ["container"], "next": ["resolver"], "hasResolver": ["resolver"], "resolve": ["token", "resway", "providers"], "unregister": ["token", "resway"], "getTokenImpl": ["token", "resway"], "has": ["token", "aliasOrway"], "toArray": ["resway"], "forEach": ["callbackfn"], "iterator": ["callbackfn", "resway"] } };
    }
}
exports.ResolverChain = ResolverChain;


});

unwrapExports(ResolverChain_1);
var ResolverChain_2 = ResolverChain_1.ResolverChainToken;
var ResolverChain_3 = ResolverChain_1.ResolverChain;

var resolves = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(ResolverChain_1, exports);


});

unwrapExports(resolves);

var registerCores_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });






/**
 * register core for container.
 *
 * @export
 * @param {IContainer} container
 */
function registerCores(container) {
    container.registerSingleton(LifeScope.LifeScopeToken, () => new core.DefaultLifeScope(container));
    container.registerSingleton(ICacheManager.CacheManagerToken, () => new core.CacheManager(container));
    container.registerSingleton(resolves.ResolverChainToken, () => new resolves.ResolverChain(container));
    container.register(providers.ProviderMapToken, () => new providers.ProviderMap(container));
    container.bindProvider(providers.ProviderMap, providers.ProviderMapToken);
    container.registerSingleton(providers.ProviderParserToken, () => new providers.ProviderParser(container));
    container.registerSingleton(IMethodAccessor.MethodAccessorToken, () => new core.MethodAccessor(container));
    container.registerSingleton(core.MetaAccessorToken, core.MetaAccessor);
    let lifeScope = container.get(LifeScope.LifeScopeToken);
    lifeScope.registerDecorator(core.Injectable, core.CoreActions.bindProvider, core.CoreActions.cache);
    lifeScope.registerDecorator(core.Component, core.CoreActions.bindProvider, core.CoreActions.cache, core.CoreActions.componentBeforeInit, core.CoreActions.componentInit, core.CoreActions.componentAfterInit);
    lifeScope.registerDecorator(core.Singleton, core.CoreActions.bindProvider);
    lifeScope.registerDecorator(core.Refs, core.CoreActions.bindProvider);
    lifeScope.registerDecorator(core.Providers, core.CoreActions.bindProvider);
    lifeScope.registerDecorator(core.Abstract, core.CoreActions.bindProvider, core.CoreActions.cache);
    lifeScope.registerDecorator(core.AutoWired, core.CoreActions.bindParameterType, core.CoreActions.bindPropertyType);
    lifeScope.registerDecorator(core.Inject, core.CoreActions.bindParameterType, core.CoreActions.bindPropertyType);
    lifeScope.registerDecorator(core.Param, core.CoreActions.bindParameterType, core.CoreActions.bindPropertyType);
    lifeScope.registerDecorator(core.Method, core.CoreActions.bindParameterProviders);
    lifeScope.registerDecorator(core.Autorun, core.CoreActions.autorun, core.CoreActions.methodAutorun);
    lifeScope.registerDecorator(core.IocExt, core.CoreActions.autorun, core.CoreActions.componentBeforeInit, core.CoreActions.componentInit, core.CoreActions.componentAfterInit);
    container.register(Date, () => new Date());
    container.register(String, () => '');
    container.register(Number, () => Number.NaN);
    container.register(Boolean, () => undefined);
    container.register(Array, () => []);
}
exports.registerCores = registerCores;


});

unwrapExports(registerCores_1);
var registerCores_2 = registerCores_1.registerCores;

var Container_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });














/**
 * singleton reg token.
 */
const SingletonRegToken = '___IOC__Singleton___';
/**
 * Container
 *
 * @export
 * @class Container
 * @implements {IContainer}
 */
class Container {
    constructor() {
        // @enumerable(false)
        this.children = [];
        this.init();
    }
    get size() {
        return this.factories.size;
    }
    /**
     * get root container.
     *
     * @returns {IContainer}
     * @memberof Container
     */
    getRoot() {
        let root = this;
        while (root.parent) {
            root = root.parent;
        }
        return root;
    }
    getProviderParser() {
        if (!this.parser) {
            this.parser = this.resolveValue(providers.ProviderParserToken);
        }
        return this.parser;
    }
    /**
     * get container builder.
     *
     * @returns {IContainerBuilder}
     * @memberof Container
     */
    getBuilder() {
        return this.resolveValue(IContainerBuilder.ContainerBuilderToken);
    }
    /**
    * resolve token value in this container only.
    *
    * @template T
    * @param {Token<T>} token
    * @param {...ParamProviders[]} providers
    * @returns {T}
    * @memberof Container
    */
    getResolvers() {
        return this.resolveValue(resolves.ResolverChainToken);
    }
    /**
     * has register the token or not.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [aliasOrway]
     * @returns {boolean}
     * @memberof Container
     */
    has(token, aliasOrway) {
        return this.getResolvers().has(token, aliasOrway);
    }
    /**
     * has register type.
     *
     * @template T
     * @param {Token<T>} key
     * @returns
     * @memberof Container
     */
    hasRegister(key) {
        return this.factories.has(this.getTokenKey(key));
    }
    /**
     * Retrieves an instance from the container based on the provided token.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    get(token, alias, ...providers$$1) {
        return this.resolve(alias ? this.getTokenKey(token, alias) : token, ...providers$$1);
    }
    /**
     * resolve type instance with token and param provider.
     *
     * @template T
     * @param {Token<T>} token
     * @param {T} [notFoundValue]
     * @param {...ParamProviders[]} providers
     * @memberof Container
     */
    resolve(token, resway, ...providers$$1) {
        return this.getResolvers().resolve(token, resway, ...providers$$1);
    }
    /**
     * resolve first token when not null.
     *
     * @template T
     * @param {Token<T>[]} tokens
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    resolveFirst(tokens, ...providers$$1) {
        let inst;
        tokens.some(tk => {
            inst = this.resolve(tk, ...providers$$1);
            return inst !== null;
        });
        return inst;
    }
    /**
     * resolve token value in this container only.
     *
     * @template T
     * @param {Token<T>} token
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    resolveValue(token, ...providers$$1) {
        let key = this.getTokenKey(token);
        if (!this.hasRegister(key)) {
            return null;
        }
        let factory = this.factories.get(key);
        return factory(...providers$$1);
    }
    /**
     * get service or target reference service.
     *
     * @template T
     * @param {(Token<T> | Token<any>[])} token servive token.
     * @param {(RefTarget | RefTarget[])} [target] service refrence target.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    getService(token, target, toRefToken, defaultToken, ...providers$$1) {
        if (utils.isArray(target) || utils.isToken(target) || utils.isRefTarget(target) || utils.isTypeObject(target)) {
            let tokens = [];
            (utils.isArray(token) ? token : [token]).forEach(tk => {
                tokens.push(tk);
                if (!utils.isClass(tk)) {
                    tokens.push(this.getTokenImpl(tk));
                }
            });
            let fac;
            let defToken;
            let prds = [];
            if (utils.isBoolean(toRefToken)) {
                if (toRefToken) {
                    defToken = token;
                }
                else {
                    defToken = null;
                }
            }
            else if (utils.isToken(toRefToken)) {
                defToken = toRefToken;
            }
            else if (utils.isFunction(toRefToken)) {
                fac = toRefToken;
                if (utils.isBoolean(defaultToken)) {
                    if (defaultToken) {
                        defToken = token;
                    }
                    else {
                        defToken = null;
                    }
                }
                else if (utils.isToken(defaultToken)) {
                    defToken = defaultToken;
                }
                else if (defaultToken) {
                    prds.push(defaultToken);
                }
            }
            else if (toRefToken) {
                prds.unshift(toRefToken);
            }
            defToken = defToken === null ? null : (defToken || token);
            prds = prds.concat(providers$$1);
            return this.getRefService([
                ...tokens.map(tk => { return { service: tk, isPrivate: true }; }),
                ...fac ? [tk => fac(tk)] : [],
                ...tokens.map(t => (tk) => new InjectReference_1.InjectReference(t, tk))
            ], target, defToken, ...prds);
        }
        else {
            return this.resolveFirst(utils.isArray(token) ? token : [token], ...[target, toRefToken, defaultToken, ...providers$$1].filter(a => a));
        }
    }
    /**
     * get target reference service.
     *
     * @template T
     * @param {Type<Registration<T>>} [refToken] reference service Registration Injector
     * @param {RefTarget | RefTarget[]} target  the service reference to.
     * @param {Token<T>} [defaultToken] default service token.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    getRefService(refToken, target, defaultToken, ...providers$$1) {
        let service = null;
        (utils.isArray(target) ? target : [target])
            .some(tag => {
            this.forInRefTarget(tag, tk => {
                // exclude ref registration.
                if (InjectReference_1.isInjectReference(tk)) {
                    return true;
                }
                return !(utils.isArray(refToken) ? refToken : [refToken]).some(stk => {
                    let tokens = this.getRefToken(stk, tk);
                    return (utils.isArray(tokens) ? tokens : [tokens]).some(rtk => {
                        service = this.resolveRef(rtk, tk, ...providers$$1);
                        return service !== null;
                    });
                });
            });
            return service !== null;
        });
        if (!service && defaultToken) {
            service = this.resolveFirst(utils.isArray(defaultToken) ? defaultToken : [defaultToken], ...providers$$1);
        }
        return service;
    }
    /**
     * get all service extends type and reference target.
     *
     * @template T
     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.
     * @param {(Token<any> | Token<any>[])} [target] service refrence target.
     * @param {(boolean|ParamProviders)} [both]
     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    getServices(token, target, both, resway, ...providers$$1) {
        let services = [];
        this.iteratorServices((tk, fac, resolver, ...pds) => {
            services.push(fac(...pds));
        }, token, target, both, resway, ...providers$$1);
        return services;
    }
    /**
     * get all service extends type and reference target.
     *
     * @template T
     * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express
     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.
     * @param {(Token<any> | Token<any>[])} [target] service refrence target.
     * @param {(boolean|ParamProviders)} [both]
     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    iteratorServices(express, token, target, both, resway, ...providers$$1) {
        let withTag;
        let rway = IContainer.ResoveWay.all;
        let withBoth = false;
        let matchExp;
        if (utils.isToken(token)) {
            let type = utils.isClassType(token) ? token : this.getTokenImpl(token);
            matchExp = (tk) => utils.lang.isExtendsClass(tk, type);
        }
        else if (utils.isFunction(token)) {
            matchExp = token;
        }
        if (utils.isNumber(resway)) {
            rway = resway;
        }
        else {
            providers$$1.unshift(resway);
        }
        if (utils.isToken(target) || utils.isArray(target)) {
            withTag = true;
            if (utils.isBoolean(both)) {
                withBoth = both;
            }
            else if (utils.isNumber(both)) {
                rway = both;
            }
            else {
                providers$$1.unshift(both);
            }
            let tags = (utils.isArray(target) ? target : [target]).map(t => {
                if (utils.isClass(t)) {
                    return t;
                }
                else if (utils.isAbstractClass(t)) {
                    return t;
                }
                else {
                    return this.getTokenImpl(t);
                }
            });
            // target private service.
            this.getResolvers().toArray().some(resolver => {
                return tags.some(tg => {
                    let priMapTk = new InjectReference_1.InjectReference(providers.ProviderMap, tg);
                    if (resolver.has(priMapTk, IContainer.ResoveWay.nodes)) {
                        let priMap = resolver.resolve(priMapTk, IContainer.ResoveWay.nodes);
                        return priMap.keys().some(ptk => {
                            if (utils.isClassType(ptk) && matchExp(ptk)) {
                                return express(ptk, priMap.get(ptk), priMap, ...providers$$1) !== false;
                            }
                            return false;
                        });
                    }
                    return false;
                });
            });
        }
        else {
            if (utils.isNumber(target)) {
                rway = target;
            }
            else {
                providers$$1.unshift(target);
            }
            withTag = false;
        }
        if (!withTag || (withTag && withBoth)) {
            this.iterator((tk, fac, resolver) => {
                if (utils.isClassType(tk) && matchExp(tk)) {
                    return express(tk, fac, resolver, ...providers$$1);
                }
            }, rway);
        }
    }
    /**
     * iterator all registered factory
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean} callbackfn
     * @param {ResoveWay} [resway= ResoveWay.all]
     * @memberof Container
     */
    iterator(callbackfn, resway = IContainer.ResoveWay.all) {
        this.getResolvers().iterator(callbackfn, resway);
    }
    /**
     * iterator.
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>) => void | boolean} callbackfn
     * @memberof IExports
     */
    forEach(callbackfn) {
        return !Array.from(this.factories.keys()).some(tk => {
            return callbackfn(tk, this.factories.get(tk), this) === false;
        });
    }
    getRefToken(ref, tk) {
        if (Registration_1.isRegistrationClass(ref)) {
            return new ref(tk);
        }
        if (utils.isToken(ref)) {
            return ref;
        }
        if (utils.isFunction(ref)) {
            return ref(tk);
        }
        return ref;
    }
    resolveRef(refToken, target, ...providers$$1) {
        let tk;
        let isPrivate = false;
        if (utils.isToken(refToken)) {
            tk = refToken;
        }
        else {
            tk = refToken.service;
            isPrivate = refToken.isPrivate !== false;
        }
        if (!tk) {
            return null;
        }
        // resolve private first.
        if (utils.isClass(target) && !InjectReference_1.isInjectReference(tk)) {
            let pdrmap = this.resolve(new InjectReference_1.InjectReference(providers.ProviderMap, target));
            if (pdrmap && pdrmap.has(tk)) {
                return pdrmap.resolve(tk, ...providers$$1);
            }
        }
        // have not private registered.
        if (isPrivate) {
            return null;
        }
        return this.resolve(tk, ...providers$$1);
    }
    /**
     * get tocken key.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @returns {SymbolType<T>}
     * @memberof Container
     */
    getTokenKey(token, alias) {
        if (alias) {
            return new Registration_1.Registration(token, alias).toString();
        }
        else if (token instanceof Registration_1.Registration) {
            return token.toString();
        }
        return token;
    }
    /**
     * register type.
     * @abstract
     * @template T
     * @param {Token<T>} token
     * @param {T} [value]
     * @returns {this}
     * @memberOf Container
     */
    register(token, value) {
        this.registerFactory(token, value);
        return this;
    }
    /**
     * register stingleton type.
     * @abstract
     * @template T
     * @param {Token<T>} token
     * @param {Factory<T>} [value]
     * @returns {this}
     * @memberOf Container
     */
    registerSingleton(token, value) {
        this.registerFactory(token, value, true);
        return this;
    }
    /**
     * register value.
     *
     * @template T
     * @param {Token<T>} token
     * @param {T} value
     * @returns {this}
     * @memberof Container
     */
    registerValue(token, value) {
        let key = this.getTokenKey(token);
        this.getSingleton().set(key, value);
        if (!this.factories.has(key)) {
            this.factories.set(key, () => {
                return this.getSingleton().get(key);
            });
        }
        return this;
    }
    /**
     * bind provider.
     *
     * @template T
     * @param {Token<T>} provide
     * @param {Token<T>} provider
     * @returns {this}
     * @memberof Container
     */
    bindProvider(provide, provider) {
        let provideKey = this.getTokenKey(provide);
        let factory;
        if (utils.isToken(provider)) {
            factory = (...providers$$1) => {
                return this.resolve(provider, ...providers$$1);
            };
        }
        else {
            if (utils.isFunction(provider)) {
                factory = (...providers$$1) => {
                    return provider(this, ...providers$$1);
                };
            }
            else {
                factory = () => {
                    return provider;
                };
            }
        }
        if (utils.isClass(provider)) {
            if (!this.has(provider)) {
                this.register(provider);
            }
            this.provideTypes.set(provideKey, provider);
        }
        else if (utils.isToken(provider)) {
            let token = provider;
            while (this.provideTypes.has(token) && !utils.isClass(token)) {
                token = this.provideTypes.get(token);
                if (utils.isClass(token)) {
                    this.provideTypes.set(provideKey, token);
                    break;
                }
            }
        }
        this.factories.set(provideKey, factory);
        return this;
    }
    /**
     * bind providers for only target class.
     *
     * @param {Token<any>} target
     * @param {ParamProviders[]} providers
     * @param {(mapTokenKey: Token<any>) => void} [onceBinded]
     * @returns {this}
     * @memberof Container
     */
    bindProviders(target, onceBinded, ...providers$$1) {
        let tgt;
        let complete;
        let prods = providers$$1;
        if (utils.isFunction(onceBinded)) {
            complete = onceBinded;
        }
        else if (onceBinded) {
            prods.unshift(onceBinded);
        }
        if (utils.isToken(target)) {
            tgt = target;
        }
        else if (target) {
            tgt = null;
            prods.unshift(target);
        }
        let maps = this.getProviderParser().parse(...prods);
        if (tgt) {
            let refKey = new InjectReference_1.InjectReference(providers.ProviderMap, utils.isClass(tgt) ? tgt : this.getTokenImpl(tgt));
            if (this.hasRegister(refKey)) {
                this.resolveValue(refKey).copy(maps);
            }
            else {
                this.bindProvider(refKey, maps);
                complete && complete(refKey);
            }
        }
        else {
            maps.keys().forEach(key => {
                utils.isToken(key) && this.factories.set(key, (...prds) => maps.resolve(key, ...prds));
            });
        }
        return this;
    }
    /**
     * bind provider ref to target.
     *
     * @template T
     * @param {Token<any>} target
     * @param {Token<T>} provide
     * @param {(Token<T> | Factory<T>)} provider
     * @param {string} [alias]
     * @param {(refToken: Token<T>) => void} [onceBinded]
     * @returns {this}
     * @memberof Container
     */
    bindRefProvider(target, provide, provider, alias, onceBinded) {
        let refToken = new InjectReference_1.InjectReference(this.getTokenKey(provide, alias), target);
        this.bindProvider(refToken, provider);
        onceBinded && onceBinded(refToken);
        return this;
    }
    unregisterValue(token) {
        let key = this.getTokenKey(token);
        if (this.hasRegister(key)) {
            this.factories.delete(key);
            if (this.provideTypes.has(key)) {
                this.provideTypes.delete(key);
            }
            if (utils.isClass(key)) {
                this.clearCache(key);
            }
        }
        return this;
    }
    /**
     * unregister the token
     *
     * @template T
     * @param {Token<T>} token
     * @param {ResoveWay} [resway]
     * @returns {this}
     * @memberof Container
     */
    unregister(token, resway) {
        this.getResolvers().unregister(token, resway);
        return this;
    }
    /**
     * clear cache.
     *
     * @param {Type<any>} targetType
     * @memberof IContainer
     */
    clearCache(targetType) {
        this.resolveValue(ICacheManager.CacheManagerToken).destroy(targetType);
    }
    /**
     * get token.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @returns {Token<T>}
     * @memberof Container
     */
    getToken(token, alias) {
        if (alias) {
            return new Registration_1.Registration(token, alias);
        }
        return token;
    }
    getTokenProvider(token) {
        if (utils.isClass(token)) {
            return token;
        }
        let tokenKey = this.getTokenKey(token);
        if (this.provideTypes.has(tokenKey)) {
            return this.provideTypes.get(tokenKey);
        }
        return null;
    }
    /**
     * get token implements class type.
     *
     * @template T
     * @param {Token<T>} token
     * @param {boolean} [inchain]
     * @returns {Type<T>}
     * @memberof Container
     */
    getTokenImpl(token, resway) {
        return this.getResolvers().getTokenImpl(token, resway);
    }
    /**
     * iterate token  in  token class chain.  return false will break iterate.
     *
     * @param {RefTarget} target
     * @param {(token: Token<any>) => boolean} express
     * @memberof Container
     */
    forInRefTarget(target, express) {
        let type;
        let token;
        let level;
        if (utils.isToken(target)) {
            token = target;
            level = types.RefTagLevel.all;
        }
        else if (target) {
            if (utils.isRefTarget(target)) {
                token = target.target;
                level = target.level || types.RefTagLevel.self;
            }
            else if (utils.isTypeObject(target)) {
                token = utils.lang.getClass(target);
                level = types.RefTagLevel.all;
            }
        }
        if (!utils.isToken(token)) {
            return;
        }
        if (utils.isClassType(token)) {
            type = token;
            if (utils.isClass(type) && !this.has(type)) {
                this.use(type);
            }
        }
        else {
            type = this.getTokenImpl(token);
        }
        if (!utils.isClassType(token) || (types.RefTagLevel.self === level)) {
            express(token);
            return;
        }
        let inChain = (level & types.RefTagLevel.chain) > 0;
        let inProviders = (level & types.RefTagLevel.providers) > 0;
        utils.lang.forInClassChain(type, ty => {
            let tokens;
            if (inProviders) {
                let prdKey = new InjectReference_1.InjectClassProvidesToken(ty);
                let prds = this.get(prdKey);
                if (prds && prds.provides && prds.provides.length) {
                    let ppdkey = prdKey.toString();
                    let pmapKey = new InjectReference_1.InjectReference(providers.ProviderMap, ty).toString();
                    tokens = prds.provides.slice(1).filter(p => {
                        let key = this.getTokenKey(p);
                        return key !== ppdkey && key !== pmapKey;
                    });
                }
            }
            tokens = tokens || [];
            return !(tokens.concat(ty).some(tk => express(tk) === false)) && inChain;
        });
    }
    /**
     * get token implement class and base classes.
     *
     * @param {Token<any>} token
     * @returns {Token<any>[]}
     * @memberof Container
     */
    getTokenClassChain(token, chain = true) {
        let tokens = [];
        this.forInRefTarget(token, tk => {
            tokens.push(tk);
            return chain;
        });
        return tokens;
    }
    /**
    * get life scope of container.
    *
    * @returns {LifeScope}
    * @memberof IContainer
    */
    getLifeScope() {
        return this.get(LifeScope.LifeScopeToken);
    }
    /**
     * use modules.
     *
     * @param {...Modules[]} modules
     * @returns {this}
     * @memberof Container
     */
    use(...modules) {
        this.getBuilder().syncLoadModule(this, ...modules);
        return this;
    }
    /**
     * async use modules.
     *
     * @param {...LoadType[]} modules load modules.
     * @returns {Promise<Type<any>[]>}  types loaded.
     * @memberof IContainer
     */
    loadModule(...modules) {
        return this.getBuilder().loadModule(this, ...modules);
    }
    /**
     * invoke method async.
     *
     * @template T
     * @param {any} target
     * @param {string} propertyKey
     * @param {*} [instance]
     * @param {...ParamProviders[]} providers
     * @returns {Promise<T>}
     * @memberof Container
     */
    invoke(target, propertyKey, instance, ...providers$$1) {
        return this.resolveValue(IMethodAccessor.MethodAccessorToken).invoke(target, propertyKey, instance, ...providers$$1);
    }
    /**
     * invoke method.
     *
     * @template T
     * @param {any} target
     * @param {string} propertyKey
     * @param {*} [instance]
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    syncInvoke(target, propertyKey, instance, ...providers$$1) {
        return this.resolveValue(IMethodAccessor.MethodAccessorToken).syncInvoke(target, propertyKey, instance, ...providers$$1);
    }
    createSyncParams(params, ...providers$$1) {
        return this.resolveValue(IMethodAccessor.MethodAccessorToken).createSyncParams(params, ...providers$$1);
    }
    createParams(params, ...providers$$1) {
        return this.resolveValue(IMethodAccessor.MethodAccessorToken).createParams(params, ...providers$$1);
    }
    cacheDecorator(map, action) {
        if (!map.has(action.name)) {
            map.set(action.name, action);
        }
    }
    init() {
        this.factories = new Map();
        this.provideTypes = new Map();
        this.bindProvider(IContainer.ContainerToken, () => this);
        registerCores_1.registerCores(this);
    }
    getSingleton() {
        if (!this.hasRegister(SingletonRegToken)) {
            this.bindProvider(SingletonRegToken, new Map());
        }
        return this.resolveValue(SingletonRegToken);
    }
    registerFactory(token, value, singleton) {
        let key = this.getTokenKey(token);
        if (this.factories.has(key)) {
            return;
        }
        let classFactory;
        if (!utils.isUndefined(value)) {
            if (utils.isFunction(value)) {
                if (utils.isClass(value)) {
                    this.bindTypeFactory(key, value, singleton);
                }
                else {
                    classFactory = this.createCustomFactory(key, value, singleton);
                }
            }
            else if (singleton && value !== undefined) {
                classFactory = this.createCustomFactory(key, () => value, singleton);
            }
        }
        else if (!utils.isString(token) && !utils.isSymbol(token)) {
            let ClassT = (token instanceof Registration_1.Registration) ? token.getClass() : token;
            if (utils.isClass(ClassT)) {
                this.bindTypeFactory(key, ClassT, singleton);
            }
        }
        if (classFactory) {
            this.factories.set(key, classFactory);
        }
    }
    createCustomFactory(key, factory, singleton) {
        return singleton ?
            (...providers$$1) => {
                if (this.getSingleton().has(key)) {
                    return this.getSingleton().get(key);
                }
                let instance = factory(this, ...providers$$1);
                this.getSingleton().set(key, instance);
                return instance;
            }
            : (...providers$$1) => factory(this, ...providers$$1);
    }
    bindTypeFactory(key, ClassT, singleton) {
        if (!Reflect.isExtensible(ClassT)) {
            return;
        }
        let lifeScope = this.getLifeScope();
        let parameters = lifeScope.getConstructorParameters(ClassT);
        if (!singleton) {
            singleton = lifeScope.isSingletonType(ClassT);
        }
        let factory = (...providers$$1) => {
            if (singleton && this.getSingleton().has(key)) {
                return this.getSingleton().get(key);
            }
            if (providers$$1.length < 1) {
                let lifecycleData = {
                    tokenKey: key,
                    targetType: ClassT,
                    // raiseContainer: this,
                    singleton: singleton
                };
                lifeScope.execute(lifecycleData, core.CoreActions.cache);
                if (lifecycleData.execResult && lifecycleData.execResult instanceof ClassT) {
                    return lifecycleData.execResult;
                }
            }
            let providerMap = this.getProviderParser().parse(...providers$$1);
            lifeScope.execute({
                tokenKey: key,
                targetType: ClassT,
                raiseContainer: this,
                params: parameters,
                providers: providers$$1,
                providerMap: providerMap,
                singleton: singleton
            }, types.IocState.runtime, core.LifeState.beforeCreateArgs);
            let args = this.createSyncParams(parameters, providerMap);
            lifeScope.routeExecute({
                tokenKey: key,
                targetType: ClassT,
                raiseContainer: this,
                args: args,
                params: parameters,
                providers: providers$$1,
                providerMap: providerMap,
                singleton: singleton
            }, types.IocState.runtime, core.LifeState.beforeConstructor);
            let instance = new ClassT(...args);
            lifeScope.routeExecute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: this,
                args: args,
                params: parameters,
                providers: providers$$1,
                providerMap: providerMap,
                singleton: singleton
            }, types.IocState.runtime, core.LifeState.afterConstructor);
            lifeScope.execute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: this,
                args: args,
                params: parameters,
                providers: providers$$1,
                providerMap: providerMap,
                singleton: singleton
            }, types.IocState.runtime, core.LifeState.onInit);
            lifeScope.routeExecute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: this,
                args: args,
                params: parameters,
                providers: providers$$1,
                providerMap: providerMap,
                singleton: singleton
            }, types.IocState.runtime, core.LifeState.AfterInit);
            lifeScope.execute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: this
            }, core.CoreActions.cache);
            return instance;
        };
        this.factories.set(key, factory);
        lifeScope.routeExecute({
            tokenKey: key,
            targetType: ClassT,
            raiseContainer: this
        }, types.IocState.design);
    }
    static getClassAnnations() {
        return { "name": "Container", "params": { "constructor": [], "getRoot": [], "getProviderParser": [], "getBuilder": [], "getResolvers": [], "has": ["token", "aliasOrway"], "hasRegister": ["key"], "get": ["token", "alias", "providers"], "resolve": ["token", "resway", "providers"], "resolveFirst": ["tokens", "providers"], "resolveValue": ["token", "providers"], "getService": ["token", "target", "toRefToken", "defaultToken", "providers"], "getRefService": ["refToken", "target", "defaultToken", "providers"], "getServices": ["token", "target", "both", "resway", "providers"], "iteratorServices": ["express", "token", "target", "both", "resway", "providers"], "iterator": ["callbackfn", "resway"], "forEach": ["callbackfn"], "getRefToken": ["ref", "tk"], "resolveRef": ["refToken", "target", "providers"], "getTokenKey": ["token", "alias"], "register": ["token", "value"], "registerSingleton": ["token", "value"], "registerValue": ["token", "value"], "bindProvider": ["provide", "provider"], "bindProviders": ["target", "onceBinded", "providers"], "bindRefProvider": ["target", "provide", "provider", "alias", "onceBinded"], "unregisterValue": ["token"], "unregister": ["token", "resway"], "clearCache": ["targetType"], "getToken": ["token", "alias"], "getTokenProvider": ["token"], "getTokenImpl": ["token", "resway"], "forInRefTarget": ["target", "express"], "getTokenClassChain": ["token", "chain"], "getLifeScope": [], "use": ["modules"], "loadModule": ["modules"], "invoke": ["target", "propertyKey", "instance", "providers"], "syncInvoke": ["target", "propertyKey", "instance", "providers"], "createSyncParams": ["params", "providers"], "createParams": ["params", "providers"], "cacheDecorator": ["map", "action"], "init": [], "getSingleton": [], "registerFactory": ["token", "value", "singleton"], "createCustomFactory": ["key", "factory", "singleton"], "bindTypeFactory": ["key", "ClassT", "singleton"] } };
    }
}
exports.Container = Container;


});

unwrapExports(Container_1);
var Container_2 = Container_1.Container;

var IModuleLoader = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * module loader token.
 */
exports.ModuleLoaderToken = new InjectToken_1.InjectToken('DI_ModuleLoader');


});

unwrapExports(IModuleLoader);
var IModuleLoader_1 = IModuleLoader.ModuleLoaderToken;

var DefaultModuleLoader_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * default module loader.
 *
 * @export
 * @class DefaultModuleLoader
 * @implements {IModuleLoader}
 */
class DefaultModuleLoader {
    constructor() {
    }
    getLoader() {
        if (!this._loader) {
            this._loader = this.createLoader();
        }
        return this._loader;
    }
    /**
     * load module.
     *
     * @param {...LoadType[]} modules
     * @returns {Promise<Modules[]>}
     * @memberof DefaultModuleLoader
     */
    load(modules) {
        if (modules.length) {
            return Promise.all(modules.map(mdty => {
                if (utils.isString(mdty)) {
                    return this.isFile(mdty) ? this.loadFile(mdty) : this.loadModule(mdty);
                }
                else if (utils.isObject(mdty) && (mdty['modules'] || mdty['files'])) {
                    return this.loadPathModule(mdty);
                }
                else {
                    return mdty ? [mdty] : [];
                }
            }))
                .then(allms => {
                let rmodules = [];
                allms.forEach(ms => {
                    rmodules = rmodules.concat(ms);
                });
                return rmodules;
            });
        }
        else {
            return Promise.resolve([]);
        }
    }
    /**
     * load types from module.
     *
     * @param {...LoadType[]} modules
     * @returns {Promise<Type<any>[]>}
     * @memberof IContainerBuilder
     */
    loadTypes(modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let mdls = yield this.load(modules);
            return this.getTypes(mdls);
        });
    }
    /**
     * get all class type in modules.
     *
     * @param {Modules[]} modules
     * @param {...Express<Type<any>, boolean>[]} filters
     * @returns {Type<any>[]}
     * @memberof DefaultModuleLoader
     */
    getTypes(modules) {
        let regModules = [];
        modules.forEach(m => {
            let types = this.getContentTypes(m);
            regModules.push(types);
        });
        return regModules;
    }
    loadFile(files, basePath) {
        let loader = this.getLoader();
        let fRes;
        if (utils.isArray(files)) {
            fRes = Promise.all(files.map(f => loader(f)))
                .then(allms => {
                let rms = [];
                allms.forEach(ms => {
                    rms = rms.concat(ms);
                });
                return rms;
            });
        }
        else {
            fRes = loader(files);
        }
        return fRes.then(ms => ms.filter(it => !!it));
    }
    isFile(str) {
        return str && /\/((\w|%|\.))+\.\w+$/.test(str.replace(/\\\\/gi, '/'));
    }
    loadModule(moduleName) {
        let loader = this.getLoader();
        return loader(moduleName).then(ms => ms.filter(it => !!it));
    }
    loadPathModule(pmd) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let modules = [];
            if (pmd.files) {
                yield this.loadFile(pmd.files, pmd.basePath)
                    .then(allmoduls => {
                    allmoduls.forEach(ms => {
                        modules = modules.concat(ms);
                    });
                    return modules;
                });
            }
            if (pmd.modules) {
                yield Promise.all(pmd.modules.map(nmd => {
                    return utils.isString(nmd) ? this.loadModule(nmd) : nmd;
                })).then(ms => {
                    modules = modules.concat(ms);
                    return modules;
                });
            }
            return modules;
        });
    }
    createLoader() {
        if (typeof commonjsRequire !== 'undefined') {
            return (modulepath) => {
                return new Promise((resolve, reject) => {
                    commonjsRequire(modulepath, (mud) => {
                        resolve(mud);
                    }, err => {
                        reject(err);
                    });
                });
            };
        }
        else {
            throw new Error('has not module loader');
        }
    }
    getContentTypes(regModule) {
        let regModules = [];
        if (utils.isClass(regModule)) {
            regModules.push(regModule);
        }
        else if (regModule) {
            let rmodules = regModule['exports'] ? regModule['exports'] : regModule;
            for (let p in rmodules) {
                let type = rmodules[p];
                if (utils.isClass(type)) {
                    regModules.push(type);
                }
            }
        }
        return regModules;
    }
    static getClassAnnations() {
        return { "name": "DefaultModuleLoader", "params": { "constructor": [], "getLoader": [], "load": ["modules"], "loadTypes": ["modules"], "getTypes": ["modules"], "loadFile": ["files", "basePath"], "isFile": ["str"], "loadModule": ["moduleName"], "loadPathModule": ["pmd"], "createLoader": [], "getContentTypes": ["regModule"] } };
    }
}
exports.DefaultModuleLoader = DefaultModuleLoader;


});

unwrapExports(DefaultModuleLoader_1);
var DefaultModuleLoader_2 = DefaultModuleLoader_1.DefaultModuleLoader;

var IModuleValidate = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * inject module validate token for decorator or class.
 *
 * @export
 * @class InjectMetadataManagerToken
 * @extends {RefRegistration<IMetadataManager>}
 * @template T
 */
class InjectModuleValidateToken extends InjectReference_1.RefRegistration {
    constructor(decorator) {
        super(decorator, 'ModuleValidate');
    }
    static getClassAnnations() {
        return { "name": "InjectModuleValidateToken", "params": { "constructor": ["decorator"] } };
    }
}
exports.InjectModuleValidateToken = InjectModuleValidateToken;
/**
 * Module Validate Token
 */
exports.ModuleValidateToken = new InjectModuleValidateToken('');


});

unwrapExports(IModuleValidate);
var IModuleValidate_1 = IModuleValidate.InjectModuleValidateToken;
var IModuleValidate_2 = IModuleValidate.ModuleValidateToken;

var ModuleValidate = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * base module validate.
 *
 * @export
 * @abstract
 * @class BaseModuelValidate
 * @implements {IModuleValidate}
 */
class ModuelValidate {
    constructor() {
    }
    valid(type) {
        if (!utils.isClass(type)) {
            return false;
        }
        let decorator = this.getDecorator();
        if (utils.isString(decorator)) {
            return core.hasOwnClassMetadata(decorator, type);
        }
        else if (utils.isArray(decorator)) {
            return decorator.some(d => core.hasOwnClassMetadata(d, type));
        }
        return true;
    }
    getDecorator() {
        return null;
    }
    static getClassAnnations() {
        return { "name": "ModuelValidate", "params": { "constructor": [], "valid": ["type"], "getDecorator": [] } };
    }
}
exports.ModuelValidate = ModuelValidate;
/**
 * IocExt module validate token.
 */
exports.IocExtModuleValidateToken = new IModuleValidate.InjectModuleValidateToken(core.IocExt.toString());
/**
 * IocExt module validate.
 *
 * @export
 * @class IocExtModuleValidate
 * @extends {ModuelValidate}
 * @implements {IModuleValidate}
 */
class IocExtModuleValidate extends ModuelValidate {
    getDecorator() {
        return core.IocExt.toString();
    }
    static getClassAnnations() {
        return { "name": "IocExtModuleValidate", "params": { "getDecorator": [] } };
    }
}
exports.IocExtModuleValidate = IocExtModuleValidate;


});

unwrapExports(ModuleValidate);
var ModuleValidate_1 = ModuleValidate.ModuelValidate;
var ModuleValidate_2 = ModuleValidate.IocExtModuleValidateToken;
var ModuleValidate_3 = ModuleValidate.IocExtModuleValidate;

var IModuleInjector = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 *  inject module injector token.
 */
class InjectModuleInjectorToken extends Registration_1.Registration {
    constructor(desc) {
        super('DI_ModuleInjector', desc);
    }
    static getClassAnnations() {
        return { "name": "InjectModuleInjectorToken", "params": { "constructor": ["desc"] } };
    }
}
exports.InjectModuleInjectorToken = InjectModuleInjectorToken;
/**
 * async module injector token.
 */
exports.ModuleInjectorToken = new InjectModuleInjectorToken('');


});

unwrapExports(IModuleInjector);
var IModuleInjector_1 = IModuleInjector.InjectModuleInjectorToken;
var IModuleInjector_2 = IModuleInjector.ModuleInjectorToken;

var ModuleInjector_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * base module injector. abstract class.
 *
 * @export
 * @abstract
 * @class BaseModuleInjector
 * @implements {IModuleInjector}
 */
let ModuleInjector = class ModuleInjector {
    /**
     *Creates an instance of BaseModuleInjector.
     * @param {IModuleValidate} [validate]
     * @param {boolean} [skipNext] skip next when has match module to injector.
     * @memberof BaseModuleInjector
     */
    constructor(validate, skipNext) {
        this.validate = validate;
        this.skipNext = skipNext;
    }
    inject(container, modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let types = (modules || []).filter(ty => this.valid(container, ty));
            if (types.length) {
                yield utils.PromiseUtil.step(types.map(ty => () => this.setup(container, ty)));
            }
            let next = this.getNext(modules, types);
            return { injected: types, next: next };
        });
    }
    syncInject(container, modules) {
        let types = (modules || []).filter(ty => this.valid(container, ty));
        if (types.length) {
            types.forEach(ty => {
                this.syncSetup(container, ty);
            });
        }
        let next = this.getNext(modules, types);
        return { injected: types, next: next };
    }
    valid(container, type) {
        if (!this.validate) {
            return true;
        }
        return this.validate.valid(type);
    }
    getNext(all, filtered) {
        if (filtered.length === 0) {
            return all;
        }
        if (this.skipNext) {
            return null;
        }
        if (filtered.length === all.length) {
            return null;
        }
        return all.filter(it => filtered.indexOf(it) < 0);
    }
    setup(container, type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            container.register(type);
        });
    }
    syncSetup(container, type) {
        container.register(type);
    }
    static getClassAnnations() {
        return { "name": "ModuleInjector", "params": { "constructor": ["validate", "skipNext"], "inject": ["container", "modules"], "syncInject": ["container", "modules"], "valid": ["container", "type"], "getNext": ["all", "filtered"], "setup": ["container", "type"], "syncSetup": ["container", "type"] } };
    }
};
ModuleInjector = tslib_1.__decorate([
    core.Injectable(IModuleInjector.ModuleInjectorToken),
    tslib_1.__param(0, core.Inject(IModuleValidate.ModuleValidateToken)),
    tslib_1.__metadata("design:paramtypes", [Object, Boolean])
], ModuleInjector);
exports.ModuleInjector = ModuleInjector;


});

unwrapExports(ModuleInjector_1);
var ModuleInjector_2 = ModuleInjector_1.ModuleInjector;

var IModuleInjectorChain = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * module fileter token. mast use as singlton.
 */
exports.ModuleInjectorChainToken = new InjectToken_1.InjectToken('DI_ModuleInjectorChain');


});

unwrapExports(IModuleInjectorChain);
var IModuleInjectorChain_1 = IModuleInjectorChain.ModuleInjectorChainToken;

var ModuleInjectorChain_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * Module Injector chain, base injector chain.
 *
 * @export
 * @class ModuleInjectorChain
 * @implements {IModuleInjectorChain}
 */
class ModuleInjectorChain {
    get injectors() {
        return this._injectors;
    }
    constructor() {
        this._injectors = [];
    }
    first(injector) {
        if (this.isInjector(injector)) {
            this._injectors.unshift(injector);
        }
        return this;
    }
    next(injector) {
        if (this.isInjector(injector)) {
            this._injectors.push(injector);
        }
        return this;
    }
    isInjector(injector) {
        return injector instanceof ModuleInjector_1.ModuleInjector;
    }
    inject(container, modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let types = [];
            yield utils.PromiseUtil.runInChain(this.injectors.map(jtor => {
                return (mds, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    let ijRt = yield jtor.inject(container, mds);
                    if (ijRt.injected && ijRt.injected.length) {
                        types = types.concat(ijRt.injected);
                    }
                    if (ijRt.next && ijRt.next.length > 0) {
                        return next();
                    }
                });
            }), modules);
            return types;
        });
    }
    syncInject(container, modules) {
        let types = [];
        let completed = false;
        this.injectors.some(jtor => {
            if (jtor instanceof ModuleInjector_1.ModuleInjector) {
                let result = jtor.syncInject(container, modules);
                types = types.concat(result.injected);
                completed = (!result.next || result.next.length < 1);
            }
            return completed;
        });
        return types;
    }
    static getClassAnnations() {
        return { "name": "ModuleInjectorChain", "params": { "constructor": [], "first": ["injector"], "next": ["injector"], "isInjector": ["injector"], "inject": ["container", "modules"], "syncInject": ["container", "modules"] } };
    }
}
exports.ModuleInjectorChain = ModuleInjectorChain;


});

unwrapExports(ModuleInjectorChain_1);
var ModuleInjectorChain_2 = ModuleInjectorChain_1.ModuleInjectorChain;

var injectors = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(IModuleLoader, exports);
tslib_1.__exportStar(DefaultModuleLoader_1, exports);
tslib_1.__exportStar(IModuleValidate, exports);
tslib_1.__exportStar(ModuleValidate, exports);
tslib_1.__exportStar(IModuleInjector, exports);
tslib_1.__exportStar(ModuleInjector_1, exports);
tslib_1.__exportStar(IModuleInjectorChain, exports);
tslib_1.__exportStar(ModuleInjectorChain_1, exports);


});

unwrapExports(injectors);

var ContainerBuilder_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * default container builder.
 *
 * @export
 * @class DefaultContainerBuilder
 * @implements {IContainerBuilder}
 */
class ContainerBuilder {
    constructor(loader) {
        this._loader = loader;
    }
    get loader() {
        if (!this._loader) {
            this._loader = new injectors.DefaultModuleLoader();
        }
        return this._loader;
    }
    create() {
        let container = new Container_1.Container();
        container.bindProvider(IContainerBuilder.ContainerBuilderToken, () => this);
        container.bindProvider(injectors.ModuleLoaderToken, () => this.loader);
        return container;
    }
    /**
     * build container.
     *
     * @param {...LoadType[]} [modules]
     * @returns
     * @memberof DefaultContainerBuilder
     */
    build(...modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let container = this.create();
            if (modules.length) {
                yield this.loadModule(container, ...modules);
            }
            return container;
        });
    }
    /**
     * load modules for container.
     *
     * @param {IContainer} container
     * @param {...LoadType[]} modules
     * @returns {Promise<Type<any>[]>}
     * @memberof DefaultContainerBuilder
     */
    loadModule(container, ...modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let regModules = yield this.loader.loadTypes(modules);
            let injTypes = [];
            if (regModules && regModules.length) {
                let injChain = this.getInjectorChain(container);
                yield utils.PromiseUtil.step(regModules.map(typs => () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    let ityps = yield injChain.inject(container, typs);
                    injTypes = injTypes.concat(ityps);
                })));
            }
            return injTypes;
        });
    }
    syncBuild(...modules) {
        let container = this.create();
        if (modules.length) {
            this.syncLoadModule(container, ...modules);
        }
        return container;
    }
    syncLoadModule(container, ...modules) {
        let regModules = this.loader.getTypes(modules);
        let injTypes = [];
        if (regModules && regModules.length) {
            let injChain = this.getInjectorChain(container);
            regModules.forEach(typs => {
                let ityps = injChain.syncInject(container, typs);
                injTypes = injTypes.concat(ityps);
            });
        }
        return injTypes;
    }
    getInjectorChain(container) {
        if (!container.has(injectors.ModuleInjectorChainToken)) {
            container.register(injectors.ModuleInjector)
                .bindProvider(injectors.ModuleValidateToken, new injectors.ModuelValidate())
                .bindProvider(injectors.IocExtModuleValidateToken, new injectors.IocExtModuleValidate())
                .bindProvider(injectors.ModuleInjectorChainToken, new injectors.ModuleInjectorChain()
                .next(container.resolve(injectors.ModuleInjectorToken, { provide: injectors.ModuleValidateToken, useValue: container.get(injectors.IocExtModuleValidateToken) }, { skipNext: true }))
                .next(container.resolve(injectors.ModuleInjectorToken)));
        }
        return container.get(injectors.ModuleInjectorChainToken);
    }
    static getClassAnnations() {
        return { "name": "ContainerBuilder", "params": { "constructor": ["loader"], "create": [], "build": ["modules"], "loadModule": ["container", "modules"], "syncBuild": ["modules"], "syncLoadModule": ["container", "modules"], "getInjectorChain": ["container"] } };
    }
}
exports.ContainerBuilder = ContainerBuilder;


});

unwrapExports(ContainerBuilder_1);
var ContainerBuilder_2 = ContainerBuilder_1.ContainerBuilder;

var D__workspace_github_tsioc_packages_core_es2015 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(IContainer, exports);
tslib_1.__exportStar(Container_1, exports);
tslib_1.__exportStar(types, exports);
tslib_1.__exportStar(Registration_1, exports);
tslib_1.__exportStar(InjectReference_1, exports);
tslib_1.__exportStar(InjectToken_1, exports);
tslib_1.__exportStar(IContainerBuilder, exports);
tslib_1.__exportStar(IMethodAccessor, exports);
tslib_1.__exportStar(ICacheManager, exports);
tslib_1.__exportStar(LifeScope, exports);
tslib_1.__exportStar(ContainerBuilder_1, exports);
tslib_1.__exportStar(utils, exports);
tslib_1.__exportStar(components, exports);
tslib_1.__exportStar(core, exports);
tslib_1.__exportStar(injectors, exports);
tslib_1.__exportStar(providers, exports);
tslib_1.__exportStar(resolves, exports);


});

var index$9 = unwrapExports(D__workspace_github_tsioc_packages_core_es2015);

module.exports = index$9;

//# sourceMappingURL=sourcemaps/core.js.map
