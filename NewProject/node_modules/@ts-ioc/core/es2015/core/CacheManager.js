"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
/**
 * cache manager.
 *
 * @export
 * @class CacheManager
 * @implements {ICacheManager}
 */
class CacheManager {
    constructor(container) {
        this.container = container;
        this.cacheTokens = new Map();
    }
    isChecking() {
        return !!this.timeout;
    }
    hasCache(targetType) {
        return this.cacheTokens.has(targetType);
    }
    cache(targetType, target, expires) {
        let cache;
        if (this.hasCache(targetType)) {
            cache = this.cacheTokens.get(targetType);
            cache.expires = Date.now() + expires;
        }
        else {
            cache = {
                target: target,
                expires: Date.now() + expires
            };
        }
        this.cacheTokens.set(targetType, cache);
        if (!this.isChecking()) {
            this.checkExpires();
        }
    }
    get(targetType, expires) {
        let result = null;
        if (!this.cacheTokens.has(targetType)) {
            return null;
        }
        let cache = this.cacheTokens.get(targetType);
        if (cache.expires <= Date.now()) {
            result = cache.target;
            if (utils_1.isNumber(expires) && expires > 0) {
                cache.expires = Date.now() + expires;
                this.cacheTokens.set(targetType, cache);
            }
        }
        else {
            this.destroy(targetType, cache.target);
        }
        return result;
    }
    checkExpires() {
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = 0;
        }
        if (this.cacheTokens.size > 0) {
            let timeoutCaches = [];
            this.cacheTokens.forEach((cache, targetType) => {
                if (cache.expires >= Date.now()) {
                    timeoutCaches.push(targetType);
                }
            });
            if (timeoutCaches.length) {
                timeoutCaches.forEach(targetType => {
                    this.destroy(targetType, this.cacheTokens.get(targetType).target);
                });
            }
            this.timeout = setTimeout(() => {
                this.checkExpires();
            }, 60000);
        }
    }
    destroy(targetType, target) {
        if (!this.hasCache(targetType)) {
            return;
        }
        if (!target) {
            target = this.cacheTokens.get(targetType).target;
        }
        try {
            let component = target;
            if (utils_1.isFunction(component.onDestroy)) {
                this.container.syncInvoke(target || targetType, 'onDestroy', target);
            }
            this.cacheTokens.delete(targetType);
        }
        catch (err) {
            console.error && console.error(err);
        }
    }
    static getClassAnnations() {
        return { "name": "CacheManager", "params": { "constructor": ["container"], "isChecking": [], "hasCache": ["targetType"], "cache": ["targetType", "target", "expires"], "get": ["targetType", "expires"], "checkExpires": [], "destroy": ["targetType", "target"] } };
    }
}
exports.CacheManager = CacheManager;

//# sourceMappingURL=../sourcemaps/core/CacheManager.js.map
