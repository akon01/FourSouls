"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const utils_1 = require("../utils");
const Singleton_1 = require("./decorators/Singleton");
const actions_1 = require("./actions");
const factories_1 = require("./factories");
const ActionFactory_1 = require("./ActionFactory");
const IMetaAccessor_1 = require("./IMetaAccessor");
/**
 * default implement life scope.
 *
 * @export
 * @class DefaultLifeScope
 * @implements {LifeScope}
 */
class DefaultLifeScope {
    constructor(container) {
        this.container = container;
        this.decorators = [];
        this.buildAction();
    }
    addAction(action, ...nodepaths) {
        let parent = this.action;
        nodepaths.forEach(pathname => {
            parent = parent.find(act => act.name === pathname);
        });
        if (parent) {
            parent.add(action);
        }
        return this;
    }
    registerDecorator(decorator, ...actions) {
        let type = this.getDecoratorType(decorator);
        return this.registerCustomDecorator(decorator, type, ...actions);
    }
    registerCustomDecorator(decorator, type, ...actions) {
        let types = this.toActionName(type);
        let name = decorator.toString();
        if (!this.decorators.some(d => d.name === name)) {
            this.decorators.push({
                name: name,
                types: types,
                actions: actions
            });
        }
        return this;
    }
    execute(data, ...names) {
        names = names.filter(n => !!n);
        let act = this.action;
        names.forEach(name => {
            act = act.find(itm => itm.name === name);
        });
        if (act) {
            act.execute(this.container, data);
        }
    }
    routeExecute(data, ...names) {
        this.execute(data, ...names);
        let container = this.container.parent;
        while (container) {
            container.getLifeScope().execute(utils_1.lang.assign({}, data), ...names);
            container = container.parent;
        }
    }
    hasDecorator(target, dtype, match) {
        let decors;
        switch (dtype) {
            case factories_1.DecoratorType.Class:
                decors = factories_1.getClassDecorators(target);
                break;
            case factories_1.DecoratorType.Property:
                decors = factories_1.getPropDecorators(target);
                break;
            case factories_1.DecoratorType.Parameter:
                decors = factories_1.getParamDecorators(target);
                break;
            case factories_1.DecoratorType.Method:
                decors = factories_1.getMethodDecorators(target);
                break;
        }
        if (decors) {
            return decors.some(dec => this.decorators.some(d => d.name === dec && match(d)));
        }
        return false;
    }
    getClassDecorators(type, match) {
        return factories_1.getClassDecorators(type)
            .map(dec => this.decorators.find(d => d.name === dec))
            .filter(d => d && (match ? match(d) : true));
    }
    getMethodDecorators(type, match) {
        return factories_1.getMethodDecorators(type)
            .map(dec => this.decorators.find(d => d.name === dec))
            .filter(d => d && (match ? match(d) : true));
    }
    getPropertyDecorators(type, match) {
        return factories_1.getPropDecorators(type)
            .map(dec => this.decorators.find(d => d.name === dec))
            .filter(d => d && (match ? match(d) : true));
    }
    getParameterDecorators(target, propertyKey, match) {
        return factories_1.getParamDecorators(target, propertyKey)
            .map(dec => this.decorators.find(d => d.name === dec))
            .filter(d => d && (match ? match(d) : true));
    }
    getDecoratorType(decirator) {
        return decirator.decoratorType || factories_1.DecoratorType.All;
    }
    /**
     * is vaildate dependence type or not. dependence type must with class decorator.
     *
     * @template T
     * @param {Type<T>} target
     * @returns {boolean}
     * @memberof Container
     */
    isVaildDependence(target) {
        if (!target) {
            return false;
        }
        if (!utils_1.isClass(target)) {
            return false;
        }
        if (utils_1.isAbstractClass(target)) {
            return false;
        }
        return this.getClassDecorators(target).length > 0;
    }
    getAtionByName(name) {
        return this.action.find(action => action.name === name);
    }
    getClassAction() {
        return this.getAtionByName(this.toActionName(factories_1.DecoratorType.Class));
    }
    getMethodAction() {
        return this.getAtionByName(this.toActionName(factories_1.DecoratorType.Method));
    }
    getPropertyAction() {
        return this.getAtionByName(this.toActionName(factories_1.DecoratorType.Property));
    }
    getParameterAction() {
        return this.getAtionByName(this.toActionName(factories_1.DecoratorType.Parameter));
    }
    /**
     * get constructor parameters metadata.
     *
     * @template T
     * @param {Type<T>} type
     * @returns {IParameter[]}
     * @memberof IContainer
     */
    getConstructorParameters(type) {
        return this.getParameters(type);
    }
    /**
     * get method params metadata.
     *
     * @template T
     * @param {Type<T>} type
     * @param {T} instance
     * @param {(string | symbol)} propertyKey
     * @returns {IParameter[]}
     * @memberof IContainer
     */
    getMethodParameters(type, instance, propertyKey) {
        return this.getParameters(type, instance, propertyKey);
    }
    /**
     * get paramerter names.
     *
     * @template T
     * @param {Type<T>} type
     * @param {string} propertyKey
     * @returns {string[]}
     * @memberof DefaultLifeScope
     */
    getParamerterNames(type, propertyKey) {
        let metadata = factories_1.getOwnParamerterNames(type);
        let paramNames = [];
        if (metadata && metadata.hasOwnProperty(propertyKey)) {
            paramNames = metadata[propertyKey];
        }
        if (!utils_1.isArray(paramNames)) {
            paramNames = [];
        }
        return paramNames;
    }
    isSingletonType(type) {
        if (factories_1.hasOwnClassMetadata(Singleton_1.Singleton, type)) {
            return true;
        }
        let metadata = this.container.get(IMetaAccessor_1.MetaAccessorToken).find(type, this.container, m => m.singleton === true);
        return !!metadata;
    }
    getMethodMetadatas(type, propertyKey) {
        let metadatas = [];
        this.getMethodDecorators(type)
            .forEach(dec => {
            let metas = factories_1.getOwnMethodMetadata(dec.name, type);
            if (metas.hasOwnProperty(propertyKey)) {
                metadatas = metadatas.concat(metas[propertyKey] || []);
            }
        });
        return metadatas;
    }
    filerDecorators(express) {
        return this.decorators.filter(express);
    }
    getParameters(type, instance, propertyKey) {
        propertyKey = propertyKey || 'constructor';
        let data = {
            target: instance,
            targetType: type,
            propertyKey: propertyKey
        };
        this.execute(data, actions_1.LifeState.onInit, actions_1.CoreActions.bindParameterType);
        let paramNames = this.getParamerterNames(type, propertyKey);
        if (data.execResult.length) {
            return data.execResult.map((typ, idx) => {
                return {
                    type: typ,
                    name: paramNames[idx]
                };
            });
        }
        else {
            return paramNames.map(name => {
                return {
                    name: name,
                    type: undefined
                };
            });
        }
    }
    getTypeDecorators(decType, match) {
        return this.filerDecorators(value => {
            let flag = (value.types || '').indexOf(decType) >= 0;
            if (flag && match) {
                flag = match(value);
            }
            return flag;
        });
    }
    buildAction() {
        let factory = new ActionFactory_1.ActionFactory();
        let action = factory.create('');
        action
            .add(factory.create(types_1.IocState.design)
            .add(factory.create(actions_1.CoreActions.bindProvider))
            .add(factory.create(actions_1.CoreActions.autorun)))
            .add(factory.create(types_1.IocState.runtime)
            .add(factory.create(actions_1.LifeState.beforeCreateArgs))
            .add(factory.create(actions_1.LifeState.beforeConstructor))
            .add(factory.create(actions_1.LifeState.afterConstructor))
            .add(factory.create(actions_1.LifeState.onInit)
            .add(factory.create(actions_1.CoreActions.componentBeforeInit))
            .add(factory.create(this.toActionName(factories_1.DecoratorType.Class)))
            .add(factory.create(this.toActionName(factories_1.DecoratorType.Method)))
            .add(factory.create(this.toActionName(factories_1.DecoratorType.Property))
            .add(factory.create(actions_1.CoreActions.bindPropertyType))
            .add(factory.create(actions_1.CoreActions.injectProperty)))
            .add(factory.create(this.toActionName(factories_1.DecoratorType.Parameter))
            .add(factory.create(actions_1.CoreActions.bindParameterType))
            .add(factory.create(actions_1.CoreActions.bindParameterProviders)))
            .add(factory.create(actions_1.CoreActions.componentInit)))
            .add(factory.create(actions_1.LifeState.AfterInit)
            .add(factory.create(actions_1.CoreActions.singletion))
            .add(factory.create(actions_1.CoreActions.componentAfterInit))
            .add(factory.create(actions_1.CoreActions.methodAutorun))))
            .add(factory.create(actions_1.CoreActions.cache));
        this.action = action;
    }
    toActionName(type) {
        let types = [];
        if (type & factories_1.DecoratorType.Class) {
            types.push('ClassDecorator');
        }
        if (type & factories_1.DecoratorType.Method) {
            types.push('MethodDecorator');
        }
        if (type & factories_1.DecoratorType.Property) {
            types.push('PropertyDecorator');
        }
        if (type & factories_1.DecoratorType.Parameter) {
            types.push('ParameterDecorator');
        }
        return types.join(',');
    }
    static getClassAnnations() {
        return { "name": "DefaultLifeScope", "params": { "constructor": ["container"], "addAction": ["action", "nodepaths"], "registerDecorator": ["decorator", "actions"], "registerCustomDecorator": ["decorator", "type", "actions"], "execute": ["data", "names"], "routeExecute": ["data", "names"], "hasDecorator": ["target", "dtype", "match"], "getClassDecorators": ["type", "match"], "getMethodDecorators": ["type", "match"], "getPropertyDecorators": ["type", "match"], "getParameterDecorators": ["target", "propertyKey", "match"], "getDecoratorType": ["decirator"], "isVaildDependence": ["target"], "getAtionByName": ["name"], "getClassAction": [], "getMethodAction": [], "getPropertyAction": [], "getParameterAction": [], "getConstructorParameters": ["type"], "getMethodParameters": ["type", "instance", "propertyKey"], "getParamerterNames": ["type", "propertyKey"], "isSingletonType": ["type"], "getMethodMetadatas": ["type", "propertyKey"], "filerDecorators": ["express"], "getParameters": ["type", "instance", "propertyKey"], "getTypeDecorators": ["decType", "match"], "buildAction": [], "toActionName": ["type"] } };
    }
}
exports.DefaultLifeScope = DefaultLifeScope;

//# sourceMappingURL=../sourcemaps/core/DefaultLifeScope.js.map
