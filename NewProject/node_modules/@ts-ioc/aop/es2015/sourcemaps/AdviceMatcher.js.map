{"version":3,"sources":["AdviceMatcher.ts"],"names":[],"mappings":"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","file":"../AdviceMatcher.js","sourcesContent":["import { IAdviceMatcher, AdviceMatcherToken } from './IAdviceMatcher';\r\nimport { AdviceMetadata, AspectMetadata } from './metadatas';\r\nimport {\r\n    Inject, getParamerterNames, getOwnMethodMetadata, hasOwnMethodMetadata,\r\n    hasOwnClassMetadata, Singleton, IContainer, isString, isRegExp, isUndefined,\r\n    Type, ObjectMap, lang, ContainerToken, getOwnTypeMetadata,\r\n    isArray, isFunction\r\n} from '@ts-ioc/core';\r\nimport { IPointcut, MatchPointcut } from './joinpoints';\r\nimport { Advice } from './decorators/Advice';\r\nimport { Aspect } from './decorators/Aspect';\r\nimport { NonePointcut } from './decorators/NonePointcut';\r\n\r\n/**\r\n * match express.\r\n */\r\nexport type MatchExpress = (method: string, fullName: string, targetType?: Type<any>, target?: any, pointcut?: IPointcut) => boolean\r\n\r\n/**\r\n * advice matcher, use to match advice when a registered create instance.\r\n *\r\n * @export\r\n * @class AdviceMatcher\r\n * @implements {IAdviceMatcher}\r\n */\r\n@NonePointcut()\r\n@Singleton(AdviceMatcherToken)\r\nexport class AdviceMatcher implements IAdviceMatcher {\r\n\r\n    constructor(@Inject(ContainerToken) private container: IContainer) {\r\n\r\n    }\r\n\r\n    match(aspectType: Type<any>, targetType: Type<any>, adviceMetas?: ObjectMap<AdviceMetadata[]>, target?: any): MatchPointcut[] {\r\n\r\n        let aspectMeta = lang.first(getOwnTypeMetadata<AspectMetadata>(Aspect, aspectType));\r\n        if (aspectMeta) {\r\n            if (aspectMeta.within) {\r\n                let ins = isArray(aspectMeta.within) ? aspectMeta.within : [aspectMeta.within];\r\n                if (ins.indexOf(targetType) < 0) {\r\n                    return [];\r\n                }\r\n            }\r\n            if (aspectMeta.annotation) {\r\n                let annotation = isFunction(aspectMeta.annotation) ? aspectMeta.annotation.toString() : aspectMeta.annotation;\r\n                let anno = (/^\\^?@\\w+/.test(annotation) ? '' : '@') + annotation;\r\n                if (!hasOwnClassMetadata(anno, targetType)) {\r\n                    return [];\r\n                }\r\n            }\r\n        }\r\n\r\n        let className = lang.getClassName(targetType);\r\n        adviceMetas = adviceMetas || getOwnMethodMetadata<AdviceMetadata>(Advice, targetType);\r\n        let matched: MatchPointcut[] = [];\r\n\r\n        if (targetType === aspectType) {\r\n            let adviceNames = lang.keys(adviceMetas);\r\n            if (adviceNames.length > 1) {\r\n                let advices: AdviceMetadata[] = [];\r\n                adviceNames.forEach(n => {\r\n                    advices = advices.concat(adviceMetas[n]);\r\n                });\r\n\r\n                adviceNames.forEach(n => {\r\n                    advices.forEach(adv => {\r\n                        if (adv.propertyKey !== n) {\r\n                            if (this.matchAspectSelf(n, adv)) {\r\n                                matched.push({\r\n                                    name: n,\r\n                                    fullName: `${className}.${n}`,\r\n                                    advice: adv\r\n                                });\r\n                            }\r\n                        }\r\n                    })\r\n                });\r\n            }\r\n        } else {\r\n            let points: IPointcut[] = [];\r\n            let decorators = Object.getOwnPropertyDescriptors(targetType.prototype);\r\n            // match method.\r\n            for (let name in decorators) {\r\n                points.push({\r\n                    name: name,\r\n                    fullName: `${className}.${name}`\r\n                });\r\n            }\r\n\r\n            let allmethods = getParamerterNames(targetType);\r\n            lang.forIn(allmethods, (item, name: string) => {\r\n                if (name === 'constructor') {\r\n                    return;\r\n                }\r\n                if (isUndefined(decorators[name])) {\r\n                    points.push({\r\n                        name: name,\r\n                        fullName: `${className}.${name}`\r\n                    });\r\n                }\r\n            });\r\n\r\n            Object.getOwnPropertyNames(adviceMetas).forEach(name => {\r\n                let advices = adviceMetas[name];\r\n                advices.forEach(metadata => {\r\n                    matched = matched.concat(this.filterPointcut(targetType, points, metadata));\r\n                });\r\n            });\r\n        }\r\n\r\n        return matched;\r\n\r\n    }\r\n\r\n    protected matchAspectSelf(name: string, metadata: AdviceMetadata): boolean {\r\n        if (metadata.pointcut) {\r\n            let pointcut = metadata.pointcut;\r\n\r\n            if (isString(pointcut)) {\r\n                if (/^execution\\(\\S+\\)$/.test(pointcut)) {\r\n                    pointcut = pointcut.substring(10, pointcut.length - 1);\r\n                }\r\n                return pointcut.startsWith(name);\r\n            } else if (isRegExp(pointcut)) {\r\n                return pointcut.test(name);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    filterPointcut(type: Type<any>, points: IPointcut[], metadata: AdviceMetadata, target?: any): MatchPointcut[] {\r\n        if (!metadata.pointcut) {\r\n            return [];\r\n        }\r\n        let matchedPointcut;\r\n        if (metadata.pointcut) {\r\n            let match = this.matchTypeFactory(type, metadata);\r\n            matchedPointcut = points.filter(p => match(p.name, p.fullName, type, target, p))\r\n        }\r\n\r\n        matchedPointcut = matchedPointcut || [];\r\n        return matchedPointcut.map(p => {\r\n            return lang.assign({}, p, { advice: metadata });\r\n        });\r\n    }\r\n\r\n    protected matchTypeFactory(type: Type<any>, metadata: AdviceMetadata): MatchExpress {\r\n        let pointcut = metadata.pointcut;\r\n        let expresses: (MatchExpress | string)[] = [];\r\n        if (metadata.within) {\r\n            expresses.push((method: string, fullName: string, targetType?: Type<any>) => {\r\n                if (isArray(metadata.within)) {\r\n                    return metadata.within.indexOf(targetType) >= 0;\r\n                } else {\r\n                    return metadata.within === targetType;\r\n                }\r\n            });\r\n            expresses.push('&&')\r\n        }\r\n        if (metadata.target) {\r\n            expresses.push((method: string, fullName: string, targetType?: Type<any>, target?: any) => {\r\n                return metadata.target = target;\r\n            });\r\n            expresses.push('&&')\r\n        }\r\n\r\n        if (metadata.annotation) {\r\n            expresses.push((method: string, fullName: string, targetType?: Type<any>, target?: any) => {\r\n                return hasOwnMethodMetadata(metadata.annotation, targetType, method);\r\n            });\r\n            expresses.push('&&')\r\n        }\r\n        if (isString(pointcut)) {\r\n            let pointcuts = (pointcut || '').trim();\r\n            expresses.push(this.tranlateExpress(type, pointcuts));\r\n        } else if (isRegExp(pointcut)) {\r\n            let pointcutReg = pointcut;\r\n            if (/^\\^?@\\w+/.test(pointcutReg.source)) {\r\n                expresses.push((name: string, fullName: string, targetType?: Type<any>) => {\r\n                    let decName = Reflect.getMetadataKeys(type, name);\r\n                    return decName.some(n => isString(n) && pointcutReg.test(n));\r\n                });\r\n\r\n            } else {\r\n                expresses.push((name: string, fullName: string) => pointcutReg.test(fullName));\r\n            }\r\n        }\r\n        return this.mergeExpress(...expresses);\r\n    }\r\n\r\n    protected spiltBrace(strExp: string) {\r\n        strExp = strExp.trim();\r\n\r\n        if (/^\\(/.test(strExp) && /\\)$/.test(strExp)) {\r\n            strExp = strExp.substring(1, strExp.length - 1).trim();\r\n        }\r\n\r\n        if (/^\\(/.test(strExp) && /\\)$/.test(strExp)) {\r\n            return this.spiltBrace(strExp);\r\n        } else {\r\n            return strExp;\r\n        }\r\n    }\r\n\r\n    protected expressToFunc(type: Type<any>, strExp: string): MatchExpress {\r\n        if (/^@annotation\\(.*\\)$/.test(strExp)) {\r\n            let exp = strExp.substring(12, strExp.length - 1);\r\n            let annotation = /^@/.test(exp) ? exp : ('@' + exp);\r\n            return (name: string, fullName: string) => hasOwnMethodMetadata(annotation, type, name) && !hasOwnClassMetadata(Aspect, type);\r\n\r\n        } else if (/^execution\\(.*\\)$/.test(strExp)) {\r\n            let exp = strExp.substring(10, strExp.length - 1);\r\n            if (exp === '*' || exp === '*.*') {\r\n                return (name: string, fullName: string) => !!name && !hasOwnClassMetadata(Aspect, type);\r\n            } else if (/^\\w+(\\((\\s*\\w+\\s*,)*\\s*\\w*\\))?$/.test(exp)) {\r\n                // if is method name, will match aspect self only.\r\n                return () => false;\r\n            } else if (/^([\\w\\*]+\\.)+[\\w\\*]+(\\((\\s*\\w+\\s*,)*\\s*\\w*\\))?$/.test(exp)) {\r\n                exp = exp.replace(/\\*\\*/gi, '(\\\\\\w+(\\\\\\.|\\\\\\/)){0,}\\\\\\w+')\r\n                    .replace(/\\*/gi, '\\\\\\w+')\r\n                    .replace(/\\./gi, '\\\\\\.')\r\n                    .replace(/\\//gi, '\\\\\\/');\r\n\r\n                let matcher = new RegExp(exp + \"$\");\r\n                return (name: string, fullName: string) => matcher.test(fullName);\r\n            } else {\r\n                return () => false;\r\n            }\r\n        } else if (/^@within\\(\\s*\\w+/.test(strExp)) {\r\n            let classnames = strExp.substring(strExp.indexOf('(') + 1, strExp.length - 1).split(',').map(n => n.trim());\r\n            return (name: string, fullName: string, targetType?: Type<any>) => classnames.indexOf(lang.getClassName(targetType)) >= 0;\r\n        } else if (/^@target\\(\\s*\\w+/.test(strExp)) {\r\n            let torken = strExp.substring(strExp.indexOf('(') + 1, strExp.length - 1).trim();\r\n            return (name: string, fullName: string, targetType?: Type<any>) => this.container.getTokenImpl(torken) === targetType;\r\n        } else {\r\n            return () => false;\r\n        }\r\n    }\r\n\r\n    protected tranlateExpress(type: Type<any>, strExp: string): MatchExpress {\r\n        let expresses: ((MatchExpress) | string)[] = [];\r\n\r\n        let idxOr = strExp.indexOf('||');\r\n        let idxAd = strExp.indexOf('&&');\r\n        if (idxAd < 0 && idxOr < 0) {\r\n            expresses.push(this.expressToFunc(type, this.spiltBrace(strExp)))\r\n        } else {\r\n            if (idxOr > idxAd) {\r\n                let leftExp = this.spiltBrace(strExp.substring(0, idxOr));\r\n                if (leftExp) {\r\n                    expresses.push(this.tranlateExpress(type, leftExp));\r\n                }\r\n                let rightExp = this.spiltBrace(strExp.substring(idxOr + 2));\r\n                if (rightExp) {\r\n                    expresses.push('||');\r\n                    expresses.push(this.tranlateExpress(type, rightExp));\r\n                }\r\n            } else if (idxAd > idxOr) {\r\n                let leftExp = this.spiltBrace(strExp.substring(0, idxAd));\r\n                if (leftExp) {\r\n                    expresses.push(this.tranlateExpress(type, leftExp));\r\n                }\r\n                let rightExp = this.spiltBrace(strExp.substring(idxAd + 2));\r\n                if (rightExp) {\r\n                    expresses.push('&&');\r\n                    expresses.push(this.tranlateExpress(type, rightExp));\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.mergeExpress(...expresses);\r\n    }\r\n\r\n\r\n    protected mergeExpress(...expresses: (MatchExpress | string)[]): MatchExpress {\r\n        return (method: string, fullName: string, targetType?: Type<any>, pointcut?: IPointcut) => {\r\n            let flag;\r\n            expresses.forEach((express, idx) => {\r\n                if (!isUndefined(flag)) {\r\n                    return;\r\n                }\r\n                if (isFunction(express)) {\r\n                    let rel = express(method, fullName, targetType, pointcut);\r\n                    if (idx < expresses.length - 2) {\r\n                        if (!rel && express[idx + 1] === '&&') {\r\n                            flag = false;\r\n                        }\r\n                        if (rel && express[idx + 1] === '||') {\r\n                            flag = true;\r\n                        }\r\n                    } else {\r\n                        flag = rel;\r\n                    }\r\n                }\r\n\r\n            });\r\n            return flag;\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"AdviceMatcher\",\"params\":{\"constructor\":[\"container\"],\"match\":[\"aspectType\",\"targetType\",\"adviceMetas\",\"target\"],\"matchAspectSelf\":[\"name\",\"metadata\"],\"filterPointcut\":[\"type\",\"points\",\"metadata\",\"target\"],\"matchTypeFactory\":[\"type\",\"metadata\"],\"spiltBrace\":[\"strExp\"],\"expressToFunc\":[\"type\",\"strExp\"],\"tranlateExpress\":[\"type\",\"strExp\"],\"mergeExpress\":[\"expresses\"]}};\n                        }\n                   }\r\n"]}