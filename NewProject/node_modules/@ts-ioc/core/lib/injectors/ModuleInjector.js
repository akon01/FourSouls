"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var IModuleInjector_1 = require("./IModuleInjector");
var utils_1 = require("../utils");
var IModuleValidate_1 = require("./IModuleValidate");
var core_1 = require("../core");
/**
 * base module injector. abstract class.
 *
 * @export
 * @abstract
 * @class BaseModuleInjector
 * @implements {IModuleInjector}
 */
var ModuleInjector = /** @class */ (function () {
    /**
     *Creates an instance of BaseModuleInjector.
     * @param {IModuleValidate} [validate]
     * @param {boolean} [skipNext] skip next when has match module to injector.
     * @memberof BaseModuleInjector
     */
    function ModuleInjector(validate, skipNext) {
        this.validate = validate;
        this.skipNext = skipNext;
    }
    ModuleInjector.prototype.inject = function (container, modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var types, next;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        types = (modules || []).filter(function (ty) { return _this.valid(container, ty); });
                        if (!types.length) return [3 /*break*/, 2];
                        return [4 /*yield*/, utils_1.PromiseUtil.step(types.map(function (ty) { return function () { return _this.setup(container, ty); }; }))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        next = this.getNext(modules, types);
                        return [2 /*return*/, { injected: types, next: next }];
                }
            });
        });
    };
    ModuleInjector.prototype.syncInject = function (container, modules) {
        var _this = this;
        var types = (modules || []).filter(function (ty) { return _this.valid(container, ty); });
        if (types.length) {
            types.forEach(function (ty) {
                _this.syncSetup(container, ty);
            });
        }
        var next = this.getNext(modules, types);
        return { injected: types, next: next };
    };
    ModuleInjector.prototype.valid = function (container, type) {
        if (!this.validate) {
            return true;
        }
        return this.validate.valid(type);
    };
    ModuleInjector.prototype.getNext = function (all, filtered) {
        if (filtered.length === 0) {
            return all;
        }
        if (this.skipNext) {
            return null;
        }
        if (filtered.length === all.length) {
            return null;
        }
        return all.filter(function (it) { return filtered.indexOf(it) < 0; });
    };
    ModuleInjector.prototype.setup = function (container, type) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                container.register(type);
                return [2 /*return*/];
            });
        });
    };
    ModuleInjector.prototype.syncSetup = function (container, type) {
        container.register(type);
    };
    ModuleInjector.getClassAnnations = function () {
        return { "name": "ModuleInjector", "params": { "constructor": ["validate", "skipNext"], "inject": ["container", "modules"], "syncInject": ["container", "modules"], "valid": ["container", "type"], "getNext": ["all", "filtered"], "setup": ["container", "type"], "syncSetup": ["container", "type"] } };
    };
    ModuleInjector = tslib_1.__decorate([
        core_1.Injectable(IModuleInjector_1.ModuleInjectorToken),
        tslib_1.__param(0, core_1.Inject(IModuleValidate_1.ModuleValidateToken)),
        tslib_1.__metadata("design:paramtypes", [Object, Boolean])
    ], ModuleInjector);
    return ModuleInjector;
}());
exports.ModuleInjector = ModuleInjector;

//# sourceMappingURL=../sourcemaps/injectors/ModuleInjector.js.map
