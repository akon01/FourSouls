"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Registration_1 = require("./Registration");
var utils_1 = require("./utils");
/**
 * Reference registration.
 *
 * @export
 * @class RefRegistration
 * @extends {Registration<T>}
 * @template T
 */
var RefRegistration = /** @class */ (function (_super) {
    tslib_1.__extends(RefRegistration, _super);
    function RefRegistration(provideType, desc) {
        var _this = _super.call(this, provideType, desc) || this;
        _this.type = 'Ref';
        return _this;
    }
    RefRegistration.getClassAnnations = function () {
        return { "name": "RefRegistration", "params": { "constructor": ["provideType", "desc"] } };
    };
    return RefRegistration;
}(Registration_1.Registration));
exports.RefRegistration = RefRegistration;
/**
 * inject reference.
 *
 * @export
 * @class InjectReference
 * @extends {Registration<T>}
 * @template T
 */
var InjectReference = /** @class */ (function (_super) {
    tslib_1.__extends(InjectReference, _super);
    function InjectReference(provideType, target) {
        var _this = _super.call(this, provideType, '') || this;
        _this.target = target;
        return _this;
    }
    InjectReference.prototype.init = function (provideType) {
        this.classType = this.format(provideType);
    };
    /**
     * to string.
     *
     * @returns {string}
     * @memberof Registration
     */
    InjectReference.prototype.toString = function () {
        var key = _super.prototype.toString.call(this);
        var target = this.format(this.target);
        return "Ref " + key + " for " + target;
    };
    InjectReference.getClassAnnations = function () {
        return { "name": "InjectReference", "params": { "constructor": ["provideType", "target"], "init": ["provideType"], "toString": [] } };
    };
    return InjectReference;
}(Registration_1.Registration));
exports.InjectReference = InjectReference;
/**
 * is inject reference token or not.
 *
 * @export
 * @template T
 * @param {*} target
 * @returns {target is InjectReference<T>}
 */
function isInjectReference(target) {
    if (!target) {
        return false;
    }
    return target instanceof InjectReference || (utils_1.isString(target) && /^Ref\s+[\w\{\}]+\sfor/.test(target));
}
exports.isInjectReference = isInjectReference;
/**
 * inject class provides token.
 *
 * @export
 * @class InjectClassProvidesToken
 * @extends {RefRegistration<IClassProvides>}
 */
var InjectClassProvidesToken = /** @class */ (function (_super) {
    tslib_1.__extends(InjectClassProvidesToken, _super);
    function InjectClassProvidesToken(provideType) {
        return _super.call(this, provideType, 'class_provides') || this;
    }
    InjectClassProvidesToken.getClassAnnations = function () {
        return { "name": "InjectClassProvidesToken", "params": { "constructor": ["provideType"] } };
    };
    return InjectClassProvidesToken;
}(RefRegistration));
exports.InjectClassProvidesToken = InjectClassProvidesToken;

//# sourceMappingURL=sourcemaps/InjectReference.js.map
