import { ObjectMap, Type, Token, ClassType } from '../types';
/**
 * map base.
 *
 * @export
 * @class MapBase
 * @template K
 * @template V
 */
export declare class MapBase<K, V> {
    protected map: Map<K, V>;
    readonly size: number;
    constructor();
    clear(): void;
    delete(key: K): boolean;
    get(key: K): V | undefined;
    has(key: K): boolean;
    set(key: K, value: V): this;
    keys(): K[];
    values(): V[];
    static getClassAnnations(): any;
}
/**
 * map set  for tsioc old version.
 *
 * @export
 * @class MapSet
 * @template K
 * @template V
 */
export declare class MapSet<K, V> extends MapBase<K, V> {
    constructor();
    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
    static getClassAnnations(): any;
}
/**
 * lang utils
 */
export declare namespace lang {
    /**
     * assert param is right or not.
     *
     * @export
     * @param {*} param
     * @param {(string | Function)} msg
     */
    function assert(param: any, msg: string | Function): void;
    /**
     * check assert param invalid by express
     *
     * @export
     * @param {(boolean | (() => boolean))} express
     * @param {(string | Function)} msg
     */
    function assertExp(express: boolean | (() => boolean), msg: string | Function): void;
    /**
     * get object keys.
     *
     * @param {*} target
     * @returns {string[]}
     */
    function keys(target: any): string[];
    /**
     * values of target object.
     *
     * @export
     * @param {*} target
     * @returns {any[]}
     */
    function values(target: any): any[];
    /**
     * assign
     *
     * @export
     * @template T
     * @param {T} target
     * @param {...any[]} source
     * @returns {T}
     */
    function assign<T, U, V>(target: T, source1: U, source2?: V, sources?: any[]): (T & U & V) | (T & U);
    /**
     * create an new object from target object omit some field.
     *
     * @export
     * @param {ObjectMap<any>} target
     * @param {...string[]} fields
     * @returns {*}
     */
    function omit(target: ObjectMap<any>, ...fields: string[]): any;
    /**
     * object has field or not.
     *
     * @export
     * @param {ObjectMap<any>} target
     * @returns
     */
    function hasField(target: ObjectMap<any>): boolean;
    /**
     * for in opter for object or array.
     *
     * @export
     * @template T
     * @param {(ObjectMap<T> | T[])} target
     * @param {(item: T, idx?: number|string) => void|boolean} iterator
     */
    function forIn<T>(target: ObjectMap<T> | T[], iterator: (item: T, idx?: number | string) => void | boolean): void;
    /**
     * find
     *
     * @template T
     * @param {(ObjectMap<T> | T[])} target
     * @param {((item: T, idx?: number | string) => boolean)} express
     */
    function find<T>(target: ObjectMap<T> | T[], express: (item: T, idx?: number | string) => boolean): void;
    /**
     * first.
     *
     * @export
     * @template T
     * @param {T[]} list
     * @returns {T}
     */
    function first<T>(list: T[]): T;
    /**
     * last.
     *
     * @export
     * @template T
     * @param {T[]} list
     * @returns {T}
     */
    function last<T>(list: T[]): T;
    /**
     * get class annations.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns
     */
    function getClassAnnations(target: ClassType<any>): import("../types").ClassAnnations;
    /**
     * target has class annations or not.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {boolean}
     */
    function hasClassAnnations(target: ClassType<any>): boolean;
    /**
     * get calss of object.
     *
     * @export
     * @param {*} target
     * @returns {Type<any>}
     */
    function getClass(target: any): Type<any>;
    /**
     * get class name.
     *
     * @export
     * @param {AbstractType<any>} target
     * @returns {string}
     */
    function getClassName(target: any): string;
    /**
     * get target type parent class.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {ClassType<any>}
     */
    function getParentClass(target: ClassType<any>): ClassType<any>;
    /**
     * get all parent class in chain.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {ClassType<any>[]}
     */
    function getClassChain(target: ClassType<any>): ClassType<any>[];
    /**
     * iterate base classes of target in chain. return false will break iterate.
     *
     * @export
     * @param {Type<any>} target
     * @param {(token: Type<any>) => any} express
     */
    function forInClassChain(target: ClassType<any>, express: (token: ClassType<any>) => any): void;
    /**
     * target is extends class of baseClass or not.
     *
     * @export
     * @param {Token<any>} target
     * @param {(ClassType<any> | ((type: ClassType<any>) => boolean))} baseClass
     * @returns {boolean}
     */
    function isExtendsClass(target: Token<any>, baseClass: ClassType<any> | ((type: ClassType<any>) => boolean)): boolean;
}
