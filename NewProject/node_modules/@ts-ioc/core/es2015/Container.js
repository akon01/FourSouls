"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const IContainer_1 = require("./IContainer");
const types_1 = require("./types");
const utils_1 = require("./utils");
const Registration_1 = require("./Registration");
const IMethodAccessor_1 = require("./IMethodAccessor");
const core_1 = require("./core");
const ICacheManager_1 = require("./ICacheManager");
const IContainerBuilder_1 = require("./IContainerBuilder");
const registerCores_1 = require("./registerCores");
const resolves_1 = require("./resolves");
const InjectReference_1 = require("./InjectReference");
const LifeScope_1 = require("./LifeScope");
const providers_1 = require("./providers");
/**
 * singleton reg token.
 */
const SingletonRegToken = '___IOC__Singleton___';
/**
 * Container
 *
 * @export
 * @class Container
 * @implements {IContainer}
 */
class Container {
    constructor() {
        // @enumerable(false)
        this.children = [];
        this.init();
    }
    get size() {
        return this.factories.size;
    }
    /**
     * get root container.
     *
     * @returns {IContainer}
     * @memberof Container
     */
    getRoot() {
        let root = this;
        while (root.parent) {
            root = root.parent;
        }
        return root;
    }
    getProviderParser() {
        if (!this.parser) {
            this.parser = this.resolveValue(providers_1.ProviderParserToken);
        }
        return this.parser;
    }
    /**
     * get container builder.
     *
     * @returns {IContainerBuilder}
     * @memberof Container
     */
    getBuilder() {
        return this.resolveValue(IContainerBuilder_1.ContainerBuilderToken);
    }
    /**
    * resolve token value in this container only.
    *
    * @template T
    * @param {Token<T>} token
    * @param {...ParamProviders[]} providers
    * @returns {T}
    * @memberof Container
    */
    getResolvers() {
        return this.resolveValue(resolves_1.ResolverChainToken);
    }
    /**
     * has register the token or not.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [aliasOrway]
     * @returns {boolean}
     * @memberof Container
     */
    has(token, aliasOrway) {
        return this.getResolvers().has(token, aliasOrway);
    }
    /**
     * has register type.
     *
     * @template T
     * @param {Token<T>} key
     * @returns
     * @memberof Container
     */
    hasRegister(key) {
        return this.factories.has(this.getTokenKey(key));
    }
    /**
     * Retrieves an instance from the container based on the provided token.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    get(token, alias, ...providers) {
        return this.resolve(alias ? this.getTokenKey(token, alias) : token, ...providers);
    }
    /**
     * resolve type instance with token and param provider.
     *
     * @template T
     * @param {Token<T>} token
     * @param {T} [notFoundValue]
     * @param {...ParamProviders[]} providers
     * @memberof Container
     */
    resolve(token, resway, ...providers) {
        return this.getResolvers().resolve(token, resway, ...providers);
    }
    /**
     * resolve first token when not null.
     *
     * @template T
     * @param {Token<T>[]} tokens
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    resolveFirst(tokens, ...providers) {
        let inst;
        tokens.some(tk => {
            inst = this.resolve(tk, ...providers);
            return inst !== null;
        });
        return inst;
    }
    /**
     * resolve token value in this container only.
     *
     * @template T
     * @param {Token<T>} token
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    resolveValue(token, ...providers) {
        let key = this.getTokenKey(token);
        if (!this.hasRegister(key)) {
            return null;
        }
        let factory = this.factories.get(key);
        return factory(...providers);
    }
    /**
     * get service or target reference service.
     *
     * @template T
     * @param {(Token<T> | Token<any>[])} token servive token.
     * @param {(RefTarget | RefTarget[])} [target] service refrence target.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    getService(token, target, toRefToken, defaultToken, ...providers) {
        if (utils_1.isArray(target) || utils_1.isToken(target) || utils_1.isRefTarget(target) || utils_1.isTypeObject(target)) {
            let tokens = [];
            (utils_1.isArray(token) ? token : [token]).forEach(tk => {
                tokens.push(tk);
                if (!utils_1.isClass(tk)) {
                    tokens.push(this.getTokenImpl(tk));
                }
            });
            let fac;
            let defToken;
            let prds = [];
            if (utils_1.isBoolean(toRefToken)) {
                if (toRefToken) {
                    defToken = token;
                }
                else {
                    defToken = null;
                }
            }
            else if (utils_1.isToken(toRefToken)) {
                defToken = toRefToken;
            }
            else if (utils_1.isFunction(toRefToken)) {
                fac = toRefToken;
                if (utils_1.isBoolean(defaultToken)) {
                    if (defaultToken) {
                        defToken = token;
                    }
                    else {
                        defToken = null;
                    }
                }
                else if (utils_1.isToken(defaultToken)) {
                    defToken = defaultToken;
                }
                else if (defaultToken) {
                    prds.push(defaultToken);
                }
            }
            else if (toRefToken) {
                prds.unshift(toRefToken);
            }
            defToken = defToken === null ? null : (defToken || token);
            prds = prds.concat(providers);
            return this.getRefService([
                ...tokens.map(tk => { return { service: tk, isPrivate: true }; }),
                ...fac ? [tk => fac(tk)] : [],
                ...tokens.map(t => (tk) => new InjectReference_1.InjectReference(t, tk))
            ], target, defToken, ...prds);
        }
        else {
            return this.resolveFirst(utils_1.isArray(token) ? token : [token], ...[target, toRefToken, defaultToken, ...providers].filter(a => a));
        }
    }
    /**
     * get target reference service.
     *
     * @template T
     * @param {Type<Registration<T>>} [refToken] reference service Registration Injector
     * @param {RefTarget | RefTarget[]} target  the service reference to.
     * @param {Token<T>} [defaultToken] default service token.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    getRefService(refToken, target, defaultToken, ...providers) {
        let service = null;
        (utils_1.isArray(target) ? target : [target])
            .some(tag => {
            this.forInRefTarget(tag, tk => {
                // exclude ref registration.
                if (InjectReference_1.isInjectReference(tk)) {
                    return true;
                }
                return !(utils_1.isArray(refToken) ? refToken : [refToken]).some(stk => {
                    let tokens = this.getRefToken(stk, tk);
                    return (utils_1.isArray(tokens) ? tokens : [tokens]).some(rtk => {
                        service = this.resolveRef(rtk, tk, ...providers);
                        return service !== null;
                    });
                });
            });
            return service !== null;
        });
        if (!service && defaultToken) {
            service = this.resolveFirst(utils_1.isArray(defaultToken) ? defaultToken : [defaultToken], ...providers);
        }
        return service;
    }
    /**
     * get all service extends type and reference target.
     *
     * @template T
     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.
     * @param {(Token<any> | Token<any>[])} [target] service refrence target.
     * @param {(boolean|ParamProviders)} [both]
     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    getServices(token, target, both, resway, ...providers) {
        let services = [];
        this.iteratorServices((tk, fac, resolver, ...pds) => {
            services.push(fac(...pds));
        }, token, target, both, resway, ...providers);
        return services;
    }
    /**
     * get all service extends type and reference target.
     *
     * @template T
     * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express
     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.
     * @param {(Token<any> | Token<any>[])} [target] service refrence target.
     * @param {(boolean|ParamProviders)} [both]
     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    iteratorServices(express, token, target, both, resway, ...providers) {
        let withTag;
        let rway = IContainer_1.ResoveWay.all;
        let withBoth = false;
        let matchExp;
        if (utils_1.isToken(token)) {
            let type = utils_1.isClassType(token) ? token : this.getTokenImpl(token);
            matchExp = (tk) => utils_1.lang.isExtendsClass(tk, type);
        }
        else if (utils_1.isFunction(token)) {
            matchExp = token;
        }
        if (utils_1.isNumber(resway)) {
            rway = resway;
        }
        else {
            providers.unshift(resway);
        }
        if (utils_1.isToken(target) || utils_1.isArray(target)) {
            withTag = true;
            if (utils_1.isBoolean(both)) {
                withBoth = both;
            }
            else if (utils_1.isNumber(both)) {
                rway = both;
            }
            else {
                providers.unshift(both);
            }
            let tags = (utils_1.isArray(target) ? target : [target]).map(t => {
                if (utils_1.isClass(t)) {
                    return t;
                }
                else if (utils_1.isAbstractClass(t)) {
                    return t;
                }
                else {
                    return this.getTokenImpl(t);
                }
            });
            // target private service.
            this.getResolvers().toArray().some(resolver => {
                return tags.some(tg => {
                    let priMapTk = new InjectReference_1.InjectReference(providers_1.ProviderMap, tg);
                    if (resolver.has(priMapTk, IContainer_1.ResoveWay.nodes)) {
                        let priMap = resolver.resolve(priMapTk, IContainer_1.ResoveWay.nodes);
                        return priMap.keys().some(ptk => {
                            if (utils_1.isClassType(ptk) && matchExp(ptk)) {
                                return express(ptk, priMap.get(ptk), priMap, ...providers) !== false;
                            }
                            return false;
                        });
                    }
                    return false;
                });
            });
        }
        else {
            if (utils_1.isNumber(target)) {
                rway = target;
            }
            else {
                providers.unshift(target);
            }
            withTag = false;
        }
        if (!withTag || (withTag && withBoth)) {
            this.iterator((tk, fac, resolver) => {
                if (utils_1.isClassType(tk) && matchExp(tk)) {
                    return express(tk, fac, resolver, ...providers);
                }
            }, rway);
        }
    }
    /**
     * iterator all registered factory
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean} callbackfn
     * @param {ResoveWay} [resway= ResoveWay.all]
     * @memberof Container
     */
    iterator(callbackfn, resway = IContainer_1.ResoveWay.all) {
        this.getResolvers().iterator(callbackfn, resway);
    }
    /**
     * iterator.
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>) => void | boolean} callbackfn
     * @memberof IExports
     */
    forEach(callbackfn) {
        return !Array.from(this.factories.keys()).some(tk => {
            return callbackfn(tk, this.factories.get(tk), this) === false;
        });
    }
    getRefToken(ref, tk) {
        if (Registration_1.isRegistrationClass(ref)) {
            return new ref(tk);
        }
        if (utils_1.isToken(ref)) {
            return ref;
        }
        if (utils_1.isFunction(ref)) {
            return ref(tk);
        }
        return ref;
    }
    resolveRef(refToken, target, ...providers) {
        let tk;
        let isPrivate = false;
        if (utils_1.isToken(refToken)) {
            tk = refToken;
        }
        else {
            tk = refToken.service;
            isPrivate = refToken.isPrivate !== false;
        }
        if (!tk) {
            return null;
        }
        // resolve private first.
        if (utils_1.isClass(target) && !InjectReference_1.isInjectReference(tk)) {
            let pdrmap = this.resolve(new InjectReference_1.InjectReference(providers_1.ProviderMap, target));
            if (pdrmap && pdrmap.has(tk)) {
                return pdrmap.resolve(tk, ...providers);
            }
        }
        // have not private registered.
        if (isPrivate) {
            return null;
        }
        return this.resolve(tk, ...providers);
    }
    /**
     * get tocken key.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @returns {SymbolType<T>}
     * @memberof Container
     */
    getTokenKey(token, alias) {
        if (alias) {
            return new Registration_1.Registration(token, alias).toString();
        }
        else if (token instanceof Registration_1.Registration) {
            return token.toString();
        }
        return token;
    }
    /**
     * register type.
     * @abstract
     * @template T
     * @param {Token<T>} token
     * @param {T} [value]
     * @returns {this}
     * @memberOf Container
     */
    register(token, value) {
        this.registerFactory(token, value);
        return this;
    }
    /**
     * register stingleton type.
     * @abstract
     * @template T
     * @param {Token<T>} token
     * @param {Factory<T>} [value]
     * @returns {this}
     * @memberOf Container
     */
    registerSingleton(token, value) {
        this.registerFactory(token, value, true);
        return this;
    }
    /**
     * register value.
     *
     * @template T
     * @param {Token<T>} token
     * @param {T} value
     * @returns {this}
     * @memberof Container
     */
    registerValue(token, value) {
        let key = this.getTokenKey(token);
        this.getSingleton().set(key, value);
        if (!this.factories.has(key)) {
            this.factories.set(key, () => {
                return this.getSingleton().get(key);
            });
        }
        return this;
    }
    /**
     * bind provider.
     *
     * @template T
     * @param {Token<T>} provide
     * @param {Token<T>} provider
     * @returns {this}
     * @memberof Container
     */
    bindProvider(provide, provider) {
        let provideKey = this.getTokenKey(provide);
        let factory;
        if (utils_1.isToken(provider)) {
            factory = (...providers) => {
                return this.resolve(provider, ...providers);
            };
        }
        else {
            if (utils_1.isFunction(provider)) {
                factory = (...providers) => {
                    return provider(this, ...providers);
                };
            }
            else {
                factory = () => {
                    return provider;
                };
            }
        }
        if (utils_1.isClass(provider)) {
            if (!this.has(provider)) {
                this.register(provider);
            }
            this.provideTypes.set(provideKey, provider);
        }
        else if (utils_1.isToken(provider)) {
            let token = provider;
            while (this.provideTypes.has(token) && !utils_1.isClass(token)) {
                token = this.provideTypes.get(token);
                if (utils_1.isClass(token)) {
                    this.provideTypes.set(provideKey, token);
                    break;
                }
            }
        }
        this.factories.set(provideKey, factory);
        return this;
    }
    /**
     * bind providers for only target class.
     *
     * @param {Token<any>} target
     * @param {ParamProviders[]} providers
     * @param {(mapTokenKey: Token<any>) => void} [onceBinded]
     * @returns {this}
     * @memberof Container
     */
    bindProviders(target, onceBinded, ...providers) {
        let tgt;
        let complete;
        let prods = providers;
        if (utils_1.isFunction(onceBinded)) {
            complete = onceBinded;
        }
        else if (onceBinded) {
            prods.unshift(onceBinded);
        }
        if (utils_1.isToken(target)) {
            tgt = target;
        }
        else if (target) {
            tgt = null;
            prods.unshift(target);
        }
        let maps = this.getProviderParser().parse(...prods);
        if (tgt) {
            let refKey = new InjectReference_1.InjectReference(providers_1.ProviderMap, utils_1.isClass(tgt) ? tgt : this.getTokenImpl(tgt));
            if (this.hasRegister(refKey)) {
                this.resolveValue(refKey).copy(maps);
            }
            else {
                this.bindProvider(refKey, maps);
                complete && complete(refKey);
            }
        }
        else {
            maps.keys().forEach(key => {
                utils_1.isToken(key) && this.factories.set(key, (...prds) => maps.resolve(key, ...prds));
            });
        }
        return this;
    }
    /**
     * bind provider ref to target.
     *
     * @template T
     * @param {Token<any>} target
     * @param {Token<T>} provide
     * @param {(Token<T> | Factory<T>)} provider
     * @param {string} [alias]
     * @param {(refToken: Token<T>) => void} [onceBinded]
     * @returns {this}
     * @memberof Container
     */
    bindRefProvider(target, provide, provider, alias, onceBinded) {
        let refToken = new InjectReference_1.InjectReference(this.getTokenKey(provide, alias), target);
        this.bindProvider(refToken, provider);
        onceBinded && onceBinded(refToken);
        return this;
    }
    unregisterValue(token) {
        let key = this.getTokenKey(token);
        if (this.hasRegister(key)) {
            this.factories.delete(key);
            if (this.provideTypes.has(key)) {
                this.provideTypes.delete(key);
            }
            if (utils_1.isClass(key)) {
                this.clearCache(key);
            }
        }
        return this;
    }
    /**
     * unregister the token
     *
     * @template T
     * @param {Token<T>} token
     * @param {ResoveWay} [resway]
     * @returns {this}
     * @memberof Container
     */
    unregister(token, resway) {
        this.getResolvers().unregister(token, resway);
        return this;
    }
    /**
     * clear cache.
     *
     * @param {Type<any>} targetType
     * @memberof IContainer
     */
    clearCache(targetType) {
        this.resolveValue(ICacheManager_1.CacheManagerToken).destroy(targetType);
    }
    /**
     * get token.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @returns {Token<T>}
     * @memberof Container
     */
    getToken(token, alias) {
        if (alias) {
            return new Registration_1.Registration(token, alias);
        }
        return token;
    }
    getTokenProvider(token) {
        if (utils_1.isClass(token)) {
            return token;
        }
        let tokenKey = this.getTokenKey(token);
        if (this.provideTypes.has(tokenKey)) {
            return this.provideTypes.get(tokenKey);
        }
        return null;
    }
    /**
     * get token implements class type.
     *
     * @template T
     * @param {Token<T>} token
     * @param {boolean} [inchain]
     * @returns {Type<T>}
     * @memberof Container
     */
    getTokenImpl(token, resway) {
        return this.getResolvers().getTokenImpl(token, resway);
    }
    /**
     * iterate token  in  token class chain.  return false will break iterate.
     *
     * @param {RefTarget} target
     * @param {(token: Token<any>) => boolean} express
     * @memberof Container
     */
    forInRefTarget(target, express) {
        let type;
        let token;
        let level;
        if (utils_1.isToken(target)) {
            token = target;
            level = types_1.RefTagLevel.all;
        }
        else if (target) {
            if (utils_1.isRefTarget(target)) {
                token = target.target;
                level = target.level || types_1.RefTagLevel.self;
            }
            else if (utils_1.isTypeObject(target)) {
                token = utils_1.lang.getClass(target);
                level = types_1.RefTagLevel.all;
            }
        }
        if (!utils_1.isToken(token)) {
            return;
        }
        if (utils_1.isClassType(token)) {
            type = token;
            if (utils_1.isClass(type) && !this.has(type)) {
                this.use(type);
            }
        }
        else {
            type = this.getTokenImpl(token);
        }
        if (!utils_1.isClassType(token) || (types_1.RefTagLevel.self === level)) {
            express(token);
            return;
        }
        let inChain = (level & types_1.RefTagLevel.chain) > 0;
        let inProviders = (level & types_1.RefTagLevel.providers) > 0;
        utils_1.lang.forInClassChain(type, ty => {
            let tokens;
            if (inProviders) {
                let prdKey = new InjectReference_1.InjectClassProvidesToken(ty);
                let prds = this.get(prdKey);
                if (prds && prds.provides && prds.provides.length) {
                    let ppdkey = prdKey.toString();
                    let pmapKey = new InjectReference_1.InjectReference(providers_1.ProviderMap, ty).toString();
                    tokens = prds.provides.slice(1).filter(p => {
                        let key = this.getTokenKey(p);
                        return key !== ppdkey && key !== pmapKey;
                    });
                }
            }
            tokens = tokens || [];
            return !(tokens.concat(ty).some(tk => express(tk) === false)) && inChain;
        });
    }
    /**
     * get token implement class and base classes.
     *
     * @param {Token<any>} token
     * @returns {Token<any>[]}
     * @memberof Container
     */
    getTokenClassChain(token, chain = true) {
        let tokens = [];
        this.forInRefTarget(token, tk => {
            tokens.push(tk);
            return chain;
        });
        return tokens;
    }
    /**
    * get life scope of container.
    *
    * @returns {LifeScope}
    * @memberof IContainer
    */
    getLifeScope() {
        return this.get(LifeScope_1.LifeScopeToken);
    }
    /**
     * use modules.
     *
     * @param {...Modules[]} modules
     * @returns {this}
     * @memberof Container
     */
    use(...modules) {
        this.getBuilder().syncLoadModule(this, ...modules);
        return this;
    }
    /**
     * async use modules.
     *
     * @param {...LoadType[]} modules load modules.
     * @returns {Promise<Type<any>[]>}  types loaded.
     * @memberof IContainer
     */
    loadModule(...modules) {
        return this.getBuilder().loadModule(this, ...modules);
    }
    /**
     * invoke method async.
     *
     * @template T
     * @param {any} target
     * @param {string} propertyKey
     * @param {*} [instance]
     * @param {...ParamProviders[]} providers
     * @returns {Promise<T>}
     * @memberof Container
     */
    invoke(target, propertyKey, instance, ...providers) {
        return this.resolveValue(IMethodAccessor_1.MethodAccessorToken).invoke(target, propertyKey, instance, ...providers);
    }
    /**
     * invoke method.
     *
     * @template T
     * @param {any} target
     * @param {string} propertyKey
     * @param {*} [instance]
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    syncInvoke(target, propertyKey, instance, ...providers) {
        return this.resolveValue(IMethodAccessor_1.MethodAccessorToken).syncInvoke(target, propertyKey, instance, ...providers);
    }
    createSyncParams(params, ...providers) {
        return this.resolveValue(IMethodAccessor_1.MethodAccessorToken).createSyncParams(params, ...providers);
    }
    createParams(params, ...providers) {
        return this.resolveValue(IMethodAccessor_1.MethodAccessorToken).createParams(params, ...providers);
    }
    cacheDecorator(map, action) {
        if (!map.has(action.name)) {
            map.set(action.name, action);
        }
    }
    init() {
        this.factories = new Map();
        this.provideTypes = new Map();
        this.bindProvider(IContainer_1.ContainerToken, () => this);
        registerCores_1.registerCores(this);
    }
    getSingleton() {
        if (!this.hasRegister(SingletonRegToken)) {
            this.bindProvider(SingletonRegToken, new Map());
        }
        return this.resolveValue(SingletonRegToken);
    }
    registerFactory(token, value, singleton) {
        let key = this.getTokenKey(token);
        if (this.factories.has(key)) {
            return;
        }
        let classFactory;
        if (!utils_1.isUndefined(value)) {
            if (utils_1.isFunction(value)) {
                if (utils_1.isClass(value)) {
                    this.bindTypeFactory(key, value, singleton);
                }
                else {
                    classFactory = this.createCustomFactory(key, value, singleton);
                }
            }
            else if (singleton && value !== undefined) {
                classFactory = this.createCustomFactory(key, () => value, singleton);
            }
        }
        else if (!utils_1.isString(token) && !utils_1.isSymbol(token)) {
            let ClassT = (token instanceof Registration_1.Registration) ? token.getClass() : token;
            if (utils_1.isClass(ClassT)) {
                this.bindTypeFactory(key, ClassT, singleton);
            }
        }
        if (classFactory) {
            this.factories.set(key, classFactory);
        }
    }
    createCustomFactory(key, factory, singleton) {
        return singleton ?
            (...providers) => {
                if (this.getSingleton().has(key)) {
                    return this.getSingleton().get(key);
                }
                let instance = factory(this, ...providers);
                this.getSingleton().set(key, instance);
                return instance;
            }
            : (...providers) => factory(this, ...providers);
    }
    bindTypeFactory(key, ClassT, singleton) {
        if (!Reflect.isExtensible(ClassT)) {
            return;
        }
        let lifeScope = this.getLifeScope();
        let parameters = lifeScope.getConstructorParameters(ClassT);
        if (!singleton) {
            singleton = lifeScope.isSingletonType(ClassT);
        }
        let factory = (...providers) => {
            if (singleton && this.getSingleton().has(key)) {
                return this.getSingleton().get(key);
            }
            if (providers.length < 1) {
                let lifecycleData = {
                    tokenKey: key,
                    targetType: ClassT,
                    // raiseContainer: this,
                    singleton: singleton
                };
                lifeScope.execute(lifecycleData, core_1.CoreActions.cache);
                if (lifecycleData.execResult && lifecycleData.execResult instanceof ClassT) {
                    return lifecycleData.execResult;
                }
            }
            let providerMap = this.getProviderParser().parse(...providers);
            lifeScope.execute({
                tokenKey: key,
                targetType: ClassT,
                raiseContainer: this,
                params: parameters,
                providers: providers,
                providerMap: providerMap,
                singleton: singleton
            }, types_1.IocState.runtime, core_1.LifeState.beforeCreateArgs);
            let args = this.createSyncParams(parameters, providerMap);
            lifeScope.routeExecute({
                tokenKey: key,
                targetType: ClassT,
                raiseContainer: this,
                args: args,
                params: parameters,
                providers: providers,
                providerMap: providerMap,
                singleton: singleton
            }, types_1.IocState.runtime, core_1.LifeState.beforeConstructor);
            let instance = new ClassT(...args);
            lifeScope.routeExecute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: this,
                args: args,
                params: parameters,
                providers: providers,
                providerMap: providerMap,
                singleton: singleton
            }, types_1.IocState.runtime, core_1.LifeState.afterConstructor);
            lifeScope.execute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: this,
                args: args,
                params: parameters,
                providers: providers,
                providerMap: providerMap,
                singleton: singleton
            }, types_1.IocState.runtime, core_1.LifeState.onInit);
            lifeScope.routeExecute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: this,
                args: args,
                params: parameters,
                providers: providers,
                providerMap: providerMap,
                singleton: singleton
            }, types_1.IocState.runtime, core_1.LifeState.AfterInit);
            lifeScope.execute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: this
            }, core_1.CoreActions.cache);
            return instance;
        };
        this.factories.set(key, factory);
        lifeScope.routeExecute({
            tokenKey: key,
            targetType: ClassT,
            raiseContainer: this
        }, types_1.IocState.design);
    }
    static getClassAnnations() {
        return { "name": "Container", "params": { "constructor": [], "getRoot": [], "getProviderParser": [], "getBuilder": [], "getResolvers": [], "has": ["token", "aliasOrway"], "hasRegister": ["key"], "get": ["token", "alias", "providers"], "resolve": ["token", "resway", "providers"], "resolveFirst": ["tokens", "providers"], "resolveValue": ["token", "providers"], "getService": ["token", "target", "toRefToken", "defaultToken", "providers"], "getRefService": ["refToken", "target", "defaultToken", "providers"], "getServices": ["token", "target", "both", "resway", "providers"], "iteratorServices": ["express", "token", "target", "both", "resway", "providers"], "iterator": ["callbackfn", "resway"], "forEach": ["callbackfn"], "getRefToken": ["ref", "tk"], "resolveRef": ["refToken", "target", "providers"], "getTokenKey": ["token", "alias"], "register": ["token", "value"], "registerSingleton": ["token", "value"], "registerValue": ["token", "value"], "bindProvider": ["provide", "provider"], "bindProviders": ["target", "onceBinded", "providers"], "bindRefProvider": ["target", "provide", "provider", "alias", "onceBinded"], "unregisterValue": ["token"], "unregister": ["token", "resway"], "clearCache": ["targetType"], "getToken": ["token", "alias"], "getTokenProvider": ["token"], "getTokenImpl": ["token", "resway"], "forInRefTarget": ["target", "express"], "getTokenClassChain": ["token", "chain"], "getLifeScope": [], "use": ["modules"], "loadModule": ["modules"], "invoke": ["target", "propertyKey", "instance", "providers"], "syncInvoke": ["target", "propertyKey", "instance", "providers"], "createSyncParams": ["params", "providers"], "createParams": ["params", "providers"], "cacheDecorator": ["map", "action"], "init": [], "getSingleton": [], "registerFactory": ["token", "value", "singleton"], "createCustomFactory": ["key", "factory", "singleton"], "bindTypeFactory": ["key", "ClassT", "singleton"] } };
    }
}
exports.Container = Container;

//# sourceMappingURL=sourcemaps/Container.js.map
