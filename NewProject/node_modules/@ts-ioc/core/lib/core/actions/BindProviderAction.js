"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ActionComposite_1 = require("./ActionComposite");
var CoreActions_1 = require("./CoreActions");
var factories_1 = require("../factories");
var InjectReference_1 = require("../../InjectReference");
/**
 * bind provider action. for binding a factory to an token.
 *
 * @export
 * @class BindProviderAction
 * @extends {ActionComposite}
 */
var BindProviderAction = /** @class */ (function (_super) {
    tslib_1.__extends(BindProviderAction, _super);
    function BindProviderAction() {
        return _super.call(this, CoreActions_1.CoreActions.bindProvider) || this;
    }
    BindProviderAction.prototype.working = function (container, data) {
        var type = data.targetType;
        var raiseContainer = data.raiseContainer;
        var lifeScope = container.getLifeScope();
        var matchs = lifeScope.getClassDecorators(type, function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.bindProvider); });
        var clpds = new InjectReference_1.InjectClassProvidesToken(type);
        // has binding.
        var classPds = raiseContainer.resolveValue(clpds) || { provides: [clpds.toString()], decors: [] };
        if (classPds.decors.length) {
            matchs = matchs.filter(function (d) { return classPds.decors.indexOf(d.name) < 0; });
        }
        if (matchs.length < 1) {
            data.execResult = classPds.provides;
            return;
        }
        matchs.forEach(function (surm) {
            var metadata = factories_1.getOwnTypeMetadata(surm.name, type);
            classPds.decors.push(surm.name);
            if (Array.isArray(metadata) && metadata.length > 0) {
                // bind all provider.
                metadata.forEach(function (c) {
                    if (!c) {
                        return;
                    }
                    if (c.provide) {
                        var provide = raiseContainer.getToken(c.provide, c.alias);
                        classPds.provides.push(provide);
                        raiseContainer.bindProvider(provide, c.type);
                    }
                    if (c.refs && c.refs.target) {
                        raiseContainer.bindRefProvider(c.refs.target, c.refs.provide ? c.refs.provide : c.type, c.type, c.refs.provide ? c.refs.alias : '', function (tk) { return classPds.provides.push(tk); });
                    }
                    // class private provider.
                    if (c.providers && c.providers.length) {
                        raiseContainer.bindProviders.apply(raiseContainer, [c.type,
                            function (refKey) { return classPds.provides.push(refKey); }].concat(c.providers));
                    }
                });
            }
        });
        raiseContainer.bindProvider(clpds, classPds);
        data.execResult = classPds.provides;
    };
    BindProviderAction.getClassAnnations = function () {
        return { "name": "BindProviderAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return BindProviderAction;
}(ActionComposite_1.ActionComposite));
exports.BindProviderAction = BindProviderAction;

//# sourceMappingURL=../../sourcemaps/core/actions/BindProviderAction.js.map
