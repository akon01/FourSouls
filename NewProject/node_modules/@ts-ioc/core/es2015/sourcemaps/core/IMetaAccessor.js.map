{"version":3,"sources":["core/IMetaAccessor.ts"],"names":[],"mappings":";;AAEA,wDAAqD;AA6GrD;;;;;;;GAOG;AACH,MAAa,uBAA2B,SAAQ,iCAAiC;IAC7E,YAAY,IAAc;QACtB,KAAK,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;IAChC,CAAC;IAEmB,MAAM,CAAC,iBAAiB;QACpB,OAAO,EAAC,MAAM,EAAC,yBAAyB,EAAC,QAAQ,EAAC,EAAC,aAAa,EAAC,CAAC,MAAM,CAAC,EAAC,EAAC,CAAC;IAChF,CAAC;CACL;AARpB,0DAQoB;AAEpB;;GAEG;AACU,QAAA,iBAAiB,GAAG,IAAI,uBAAuB,CAAM,MAAM,CAAC,CAAC","file":"../../core/IMetaAccessor.js","sourcesContent":["import { Token, Type, Express } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { RefRegistration } from '../InjectReference';\r\nimport { ComponentMetadata } from './metadatas';\r\n\r\n/**\r\n * annotation metadata.\r\n *\r\n * @export\r\n * @interface IAnnotationMetadata\r\n * @extends {ClassMetadata}\r\n * @template T\r\n */\r\nexport interface IAnnotationMetadata<T> extends ComponentMetadata {\r\n    /**\r\n     * annotation for the type.\r\n     *\r\n     * @type {Token<T>}\r\n     * @memberof AnnotationConfigure\r\n     */\r\n    token?: Token<T>;\r\n    /**\r\n     * Annotation class Type.\r\n     *\r\n     * @type {Type<T>}\r\n     * @memberof IAnnotationMetadata\r\n     */\r\n    type?: Type<T>;\r\n    /**\r\n     * bootstrap.\r\n     *\r\n     * @type {Token<T>}\r\n     * @memberof IAnnotationMetadata\r\n     */\r\n    bootstrap?: Token<T>;\r\n}\r\n\r\n/**\r\n * module metadata accessor\r\n *\r\n * @export\r\n * @interface IMetaAccessor\r\n * @template T\r\n */\r\nexport interface IMetaAccessor<T> {\r\n    /**\r\n     * get then first decorator metadata contain via decorators in order.\r\n     *\r\n     * @param {Type<T>} type\r\n     * @returns {string[]}\r\n     * @memberof IMetaAccessor\r\n     */\r\n    getDecorators(type: Type<T>): string[];\r\n\r\n    /**\r\n     * get metadata config of target type. via decorators in order.\r\n     *\r\n     * @param {Token<T>} type\r\n     * @param {IContainer} container\r\n     * @param {IAnnotationMetadata<T>} [extConfig] ext config to merge with metadata.\r\n     * @param {Express<string, boolean>} [decorFilter]\r\n     * @returns {IAnnotationMetadata<T>}\r\n     * @memberof IMetaAccessor\r\n     */\r\n    getMetadata(type: Token<T>, container: IContainer, extConfig?: IAnnotationMetadata<T>, decorFilter?: Express<string, boolean>): IAnnotationMetadata<T>;\r\n\r\n    /**\r\n     * find metadata.\r\n     *\r\n     * @param {Token<T>} type\r\n     * @param {IContainer} container\r\n     * @param {Express<IAnnotationMetadata<T>, boolean>} filter\r\n     * @param {Express<string, boolean>} [decorFilter]\r\n     * @returns {IAnnotationMetadata<T>}\r\n     * @memberof IMetaAccessor\r\n     */\r\n    find(type: Token<T>, container: IContainer, filter: Express<IAnnotationMetadata<T>, boolean>, decorFilter?: Express<string, boolean>): IAnnotationMetadata<T>;\r\n\r\n    /**\r\n     * filter metadata.\r\n     *\r\n     * @param {Token<T>} type\r\n     * @param {IContainer} container\r\n     * @param {Express<IAnnotationMetadata<T>, boolean>} filter\r\n     * @param {Express<string, boolean>} [decorFilter]\r\n     * @returns {IAnnotationMetadata<T>[]}\r\n     * @memberof IMetaAccessor\r\n     */\r\n    filter(type: Token<T>, container: IContainer, filter: Express<IAnnotationMetadata<T>, boolean>, decorFilter?: Express<string, boolean>): IAnnotationMetadata<T>[];\r\n\r\n    /**\r\n     * get token of metadata.\r\n     *\r\n     * @param {AnnotationConfigure<any>} config\r\n     * @returns {Token<any>}\r\n     * @param {IContainer} [container]  vaild container.\r\n     * @memberof IMetadataManager\r\n     */\r\n    getToken(config: IAnnotationMetadata<any>, container?: IContainer): Token<any>;\r\n\r\n    /**\r\n     * get boot token of module config.\r\n     *\r\n     * @param {IAnnotationMetadata<any>} cfg\r\n     * @param {IContainer} [container]  vaild container.\r\n     * @returns {Token<any>}\r\n     * @memberof IModuleValidate\r\n     */\r\n    getBootToken(cfg: IAnnotationMetadata<any>, container?: IContainer): Token<any>\r\n}\r\n\r\n/**\r\n * application service token.\r\n *\r\n * @export\r\n * @class InjectMetaAccessorToken\r\n * @extends {Registration<MetaAccessor<T>>}\r\n * @template T\r\n */\r\nexport class InjectMetaAccessorToken<T> extends RefRegistration<IMetaAccessor<T>> {\r\n    constructor(type: Token<T>) {\r\n        super(type, 'metaAccessor');\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"InjectMetaAccessorToken\",\"params\":{\"constructor\":[\"type\"]}};\n                        }\n                   }\r\n\r\n/**\r\n * MetaAccessor token.\r\n */\r\nexport const MetaAccessorToken = new InjectMetaAccessorToken<any>(Object);\r\n"]}