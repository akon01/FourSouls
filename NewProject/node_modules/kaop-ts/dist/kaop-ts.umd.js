(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('kaop'), require('reflect-metadata')) :
    typeof define === 'function' && define.amd ? define(['exports', 'kaop', 'reflect-metadata'], factory) :
    (global = global || self, factory(global.kaopTs = {}, global.kaop));
}(this, function (exports, kaop) { 'use strict';

    const KEY_ORIGINAL_METHOD = "original-method";
    const KEY_BEFORE_METHOD = "before-method";
    const KEY_AFTER_METHOD = "after-method";
    const KEY_BEFORE_INSTANCE = "before-instance";
    const KEY_AFTER_INSTANCE = "after-instance";

    function getMethod(target, methodName) {
        const keyOriginalMethod = generateKey(KEY_ORIGINAL_METHOD, methodName);
        return Reflect.getMetadata(keyOriginalMethod, target);
    }
    function getConstructor(target) {
        const keyOriginalMethod = generateKey(KEY_ORIGINAL_METHOD, "constructor");
        return Reflect.getMetadata(keyOriginalMethod, target.prototype);
    }
    function reassignMethods(target) {
        const members = Object.getOwnPropertyNames(target);
        members.forEach(member => {
            if (typeof target[member] === "function") {
                const originalMethod = getMethod(target, member);
                originalMethod && Object.defineProperty(target, member, { value: originalMethod });
            }
        });
    }
    function clearAdvices(target) {
        const originalConstructor = getConstructor(target);
        reassignMethods(originalConstructor);
        reassignMethods(originalConstructor.prototype);
        return originalConstructor;
    }
    function generateKey(scope, methodName) {
        return `${scope}-${methodName}`;
    }
    const clearMethod = getMethod;

    function wrapMethod(target, methodName, original, befores, afters, caller) {
        const adviceList = [
            ...(befores || []),
            original,
            ...(afters || [])
        ];
        return kaop.reflect.createProxyFn(target, methodName, adviceList, caller);
    }
    function replace(target, metaContainer, advices, methodName, keyJoinPoint, original) {
        const adviceArr = Reflect.getMetadata(keyJoinPoint, metaContainer) || [];
        adviceArr.unshift(...advices.map(kaop.reflect.advice));
        Reflect.defineMetadata(keyJoinPoint, adviceArr, metaContainer);
        const keyOriginalMethod = generateKey(KEY_ORIGINAL_METHOD, methodName);
        if (!Reflect.getMetadata(keyOriginalMethod, metaContainer)) {
            Reflect.defineMetadata(keyOriginalMethod, original, metaContainer);
        }
        const originalMethod = Reflect.getMetadata(keyOriginalMethod, metaContainer);
        if (methodName === "constructor") {
            const keyBeforeMethod = generateKey(KEY_BEFORE_INSTANCE, methodName);
            const keyAfterMethod = generateKey(KEY_AFTER_INSTANCE, methodName);
            const beforeAdvices = Reflect.getMetadata(keyBeforeMethod, metaContainer);
            const afterAdvices = Reflect.getMetadata(keyAfterMethod, metaContainer);
            const nctor = wrapMethod(target, methodName, originalMethod, beforeAdvices, afterAdvices, meta => Reflect.construct(meta.target.prototype.constructor, meta.args, meta.ES6newTarget));
            nctor.prototype = target.prototype;
            return nctor;
        }
        else {
            const keyBeforeMethod = generateKey(KEY_BEFORE_METHOD, methodName);
            const keyAfterMethod = generateKey(KEY_AFTER_METHOD, methodName);
            const beforeAdvices = Reflect.getMetadata(keyBeforeMethod, metaContainer);
            const afterAdvices = Reflect.getMetadata(keyAfterMethod, metaContainer);
            return wrapMethod(target, methodName, originalMethod, beforeAdvices, afterAdvices);
        }
    }
    function beforeMethod(...advices) {
        return Object.assign((target, methodName, descriptor) => {
            const keyBeforeMethod = generateKey(KEY_BEFORE_METHOD, methodName);
            descriptor.value = replace(target, target, advices, methodName, keyBeforeMethod, descriptor.value);
            return descriptor;
        }, { advices: () => advices });
    }
    function afterMethod(...advices) {
        return Object.assign((target, methodName, descriptor) => {
            const keyAfterMethod = generateKey(KEY_AFTER_METHOD, methodName);
            descriptor.value = replace(target, target, advices, methodName, keyAfterMethod, descriptor.value);
            return descriptor;
        }, { advices: () => advices });
    }
    function beforeInstance(...advices) {
        return Object.assign((target, methodName = "constructor") => {
            const keyBeforeInstance = generateKey(KEY_BEFORE_INSTANCE, methodName);
            return replace(target, target.prototype, advices, methodName, keyBeforeInstance, target.prototype.constructor);
        }, { advices: () => advices });
    }
    function afterInstance(...advices) {
        return Object.assign((target, methodName = "constructor") => {
            const keyAfterInstance = generateKey(KEY_AFTER_INSTANCE, methodName);
            return replace(target, target.prototype, advices, methodName, keyAfterInstance, target.prototype.constructor);
        }, { advices: () => advices });
    }

    function onException(advice) {
        return afterMethod(meta => meta.exception && advice(meta));
    }

    function applyAspect(definition) {
        return function (target) {
            const ctor = definition["constructor"] instanceof Array ? definition["constructor"] : [];
            delete definition["constructor"];
            for (let key in definition) {
                definition[key].forEach(advice => Object.defineProperty(target.prototype, key, advice(target, key, Object.getOwnPropertyDescriptor(target.prototype, key))));
            }
            ctor.forEach(advice => target = advice(target));
            return target;
        };
    }

    exports.inject = kaop.inject;
    exports.provider = kaop.provider;
    exports.afterMethod = afterMethod;
    exports.beforeMethod = beforeMethod;
    exports.afterInstance = afterInstance;
    exports.beforeInstance = beforeInstance;
    exports.onException = onException;
    exports.applyAspect = applyAspect;
    exports.clearAdvices = clearAdvices;
    exports.clearMethod = clearMethod;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
