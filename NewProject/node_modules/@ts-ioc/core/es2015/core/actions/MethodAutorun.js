"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ActionComposite_1 = require("./ActionComposite");
const utils_1 = require("../../utils");
const CoreActions_1 = require("./CoreActions");
const factories_1 = require("../factories");
const decorators_1 = require("../decorators");
/**
 * Inject DrawType action.
 *
 * @export
 * @class SetPropAction
 * @extends {ActionComposite}
 */
class MethodAutorun extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.methodAutorun);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.target && data.targetType) {
            if (factories_1.hasMethodMetadata(decorators_1.Autorun, data.targetType)) {
                let metas = factories_1.getMethodMetadata(decorators_1.Autorun, data.targetType);
                let lastmetas = [];
                let idx = utils_1.lang.keys(metas).length;
                utils_1.lang.forIn(metas, (mm, key) => {
                    if (mm && mm.length) {
                        let m = mm[0];
                        m.autorun = key;
                        idx++;
                        if (!utils_1.isNumber(m.order)) {
                            m.order = idx;
                        }
                        lastmetas.push(m);
                    }
                });
                lastmetas.sort((au1, au2) => {
                    return au1.order - au1.order;
                }).forEach(aut => {
                    container.syncInvoke(data.target || data.targetType, aut.autorun, data.target);
                });
            }
        }
    }
    static getClassAnnations() {
        return { "name": "MethodAutorun", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.MethodAutorun = MethodAutorun;

//# sourceMappingURL=../../sourcemaps/core/actions/MethodAutorun.js.map
