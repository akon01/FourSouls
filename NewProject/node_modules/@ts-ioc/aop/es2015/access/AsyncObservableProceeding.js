"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@ts-ioc/core");
const IAdvisorProceeding_1 = require("./IAdvisorProceeding");
const ReturningType_1 = require("./ReturningType");
const NonePointcut_1 = require("../decorators/NonePointcut");
let AsyncObservableProceeding = class AsyncObservableProceeding {
    constructor() {
    }
    proceeding(joinPoint, ...actions) {
        // if (isObservable(joinPoint.returning)) {
        //     if (isFunction(joinPoint.returning.pipe)) {
        //         const flatMap = require('rxjs/operators').flatMap;
        //         actions.forEach(action => {
        //             joinPoint.returning = joinPoint.returning.pipe(
        //                 flatMap((val) => {
        //                     joinPoint.returningValue = val;
        //                     action(joinPoint);
        //                     if (isObservable(joinPoint.returningValue)) {
        //                         return joinPoint.returningValue;
        //                     } else if (isPromise(joinPoint.returningValue)) {
        //                         return joinPoint.returningValue;
        //                     } else {
        //                         return Promise.resolve(joinPoint.returningValue);
        //                     }
        //                 }));
        //         });
        //     } else
        if (core_1.isObservable(joinPoint.returning) && core_1.isFunction(joinPoint.returning.flatMap)) {
            actions.forEach(action => {
                joinPoint.returning = joinPoint.returning.flatMap((val) => {
                    joinPoint.returningValue = val;
                    action(joinPoint);
                    if (core_1.isObservable(joinPoint.returningValue)) {
                        return joinPoint.returningValue;
                    }
                    else if (core_1.isPromise(joinPoint.returningValue)) {
                        return joinPoint.returningValue;
                    }
                    else {
                        return Promise.resolve(joinPoint.returningValue);
                    }
                });
            });
        }
        else {
            actions.forEach(action => {
                action(joinPoint);
            });
        }
    }
    static getClassAnnations() {
        return { "name": "AsyncObservableProceeding", "params": { "constructor": [], "proceeding": ["joinPoint", "actions"] } };
    }
};
AsyncObservableProceeding = tslib_1.__decorate([
    NonePointcut_1.NonePointcut(),
    core_1.Singleton(IAdvisorProceeding_1.AdvisorProceedingToken, ReturningType_1.ReturningType.observable),
    tslib_1.__metadata("design:paramtypes", [])
], AsyncObservableProceeding);
exports.AsyncObservableProceeding = AsyncObservableProceeding;

//# sourceMappingURL=../sourcemaps/access/AsyncObservableProceeding.js.map
