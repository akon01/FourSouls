{"version":3,"sources":["core/factories/ParamDecoratorFactory.ts"],"names":[],"mappings":";;AAAA,4BAA0B;AAE1B,uDAAuF;AACvF,iDAAgD;AAChD,qCAAyD;AA+BzD;;;;;;;;;GASG;AACH,SAAgB,oBAAoB,CAChC,IAAY,EACZ,OAAyB,EACzB,eAAoC;IAEpC,IAAI,YAAY,GAAG,CAAC,UAAC,IAAkB;QACnC,IAAI,OAAO,EAAE;YACT,OAAO,CAAC,IAAI,CAAC,CAAC;SACjB;QACD,IAAI,CAAC,IAAI,CAAI;YACT,UAAU,EAAE,UAAC,GAAG,IAAK,OAAA,yBAAiB,CAAC,GAAG,EAAE,OAAO,CAAC,EAA/B,CAA+B;YACpD,KAAK,EAAE,UAAC,GAAG,IAAK,OAAA,eAAO,CAAC,GAAG,CAAC,EAAZ,CAAY;YAC5B,WAAW,EAAE,UAAC,QAAQ,EAAE,GAAG;gBACvB,QAAQ,CAAC,QAAQ,GAAG,GAAG,CAAC;YAC5B,CAAC;SACJ,CAAC,CAAC;QACH,iBAAiB;QACjB,qCAAqC;QACrC,wCAAwC;QACxC,gCAAgC;QAChC,QAAQ;QACR,MAAM;IACV,CAAC,CAAC,CAAC;IACH,IAAI,SAAS,GAAG,kCAAe,CAAI,IAAI,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;IACxE,SAAS,CAAC,aAAa,GAAG,6BAAa,CAAC,SAAS,CAAC;IAClD,OAAO,SAAS,CAAC;AACrB,CAAC;AA1BD,oDA0BC","file":"../../../core/factories/ParamDecoratorFactory.js","sourcesContent":["import 'reflect-metadata';\r\nimport { ParameterMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { isToken, isProvideMetadata } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { Token } from '../../types';\r\n\r\n\r\n/**\r\n * Parameter decorator.\r\n *\r\n * @export\r\n * @interface IParameterDecorator\r\n */\r\nexport interface IParameterDecorator<T extends ParameterMetadata> {\r\n    /**\r\n     * define parameter decorator with param.\r\n     *\r\n     * @param {Token<T>} provider define provider to resolve value to the parameter.\r\n     */\r\n    (provider: Token<T>): ParameterDecorator;\r\n    /**\r\n     * define parameter decorator with metadata map.\r\n     * @param {T} [metadata] define matadata map to resolve value to the parameter.\r\n     */\r\n    (metadata?: T): ParameterDecorator;\r\n    /**\r\n     * define paramete decorator.\r\n     */\r\n    (target: object, propertyKey: string | symbol, parameterIndex: number): void;\r\n}\r\n\r\n\r\n\r\n/**\r\n * create parameter decorator.\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns\r\n */\r\nexport function createParamDecorator<T extends ParameterMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IParameterDecorator<T> {\r\n\r\n    let paramAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            isMetadata: (arg) => isProvideMetadata(arg, 'index'),\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provider = arg;\r\n            }\r\n        });\r\n        // args.next<T>({\r\n        //     match: (arg) => isString(arg),\r\n        //     setMetadata: (metadata, arg) => {\r\n        //         metadata.alias = arg;\r\n        //     }\r\n        // });\r\n    });\r\n    let decorator = createDecorator<T>(name, paramAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Parameter;\r\n    return decorator;\r\n}\r\n"]}