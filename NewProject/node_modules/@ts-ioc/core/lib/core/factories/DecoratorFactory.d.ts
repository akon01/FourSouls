import 'reflect-metadata';
import { PropertyMetadata, MethodMetadata, ParameterMetadata, Metadate } from '../metadatas';
import { ArgsIterator } from './ArgsIterator';
import { Type, AbstractType, ObjectMap, ClassType } from '../../types';
export declare const ParamerterName = "paramerter_names";
export interface MetadataAdapter {
    (args: ArgsIterator): any;
}
/**
 * extend metadata.
 *
 * @export
 * @interface MetadataExtends
 * @template T
 */
export interface MetadataExtends<T> {
    (metadata: T): void;
}
export interface MetadataTarget<T> {
    (target: Type<any> | object): Type<any> | object;
}
/**
 * decorator for all.
 *
 * @export
 * @interface IDecorator
 * @template T
 */
export interface IDecorator<T extends Metadate> {
    /**
     * define decorator setting with params.
     *
     * @param {(Type<any> | symbol | string)} provide define this class provider for provide.
     * @param {string} [alias] define this class provider with alias for provide.
     */
    (provider: string | symbol | Type<any>, alias?: string): any;
    /**
     * define decorator setting with metadata map.
     *
     * @param {T} [metadata] metadata map.
     */
    (metadata?: T): any;
    (target: Type<any>): void;
    (target: object, propertyKey: string | symbol): void;
    (target: object, propertyKey: string | symbol, parameterIndex: number): void;
    (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>): void;
}
/**
 * create dectorator for class params props methods.
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {*}
 */
export declare function createDecorator<T>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): any;
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
export declare function getClassDecorators(target: Type<any> | AbstractType<any>): string[];
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
export declare function getMethodDecorators(target: Type<any> | AbstractType<any>): string[];
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
export declare function getPropDecorators(target: Type<any> | AbstractType<any>): string[];
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
export declare function getParamDecorators(target: any, propertyKey?: string): string[];
/**
 * get all class metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns
 */
export declare function getTypeMetadata<T>(decorator: string | Function, target: Type<any> | AbstractType<T>): T[];
/**
 * get own class metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns
 */
export declare function getOwnTypeMetadata<T>(decorator: string | Function, target: Type<any> | AbstractType<T>): T[];
/**
 * has class decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @returns {boolean}
 */
export declare function hasClassMetadata(decorator: string | Function, target: Type<any> | object): boolean;
/**
 * has own class decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @returns {boolean}
 */
export declare function hasOwnClassMetadata(decorator: string | Function, target: Type<any> | object): boolean;
/**
 * get all method metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
export declare function getMethodMetadata<T extends MethodMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]>;
/**
 * get own method metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
export declare function getOwnMethodMetadata<T extends MethodMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]>;
/**
 * has own method decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
export declare function hasOwnMethodMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean;
/**
 * has method decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
export declare function hasMethodMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean;
/**
 * get all property metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
export declare function getPropertyMetadata<T extends PropertyMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]>;
/**
 * get own property metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
export declare function getOwnPropertyMetadata<T extends PropertyMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]>;
/**
 * has property decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
export declare function hasPropertyMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean;
/**
 * get paramerter metadata of one specail decorator in target method.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {T[][]}
 */
export declare function getParamMetadata<T extends ParameterMetadata>(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): T[][];
/**
 * get own paramerter metadata of one specail decorator in target method.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {T[][]}
 */
export declare function getOwnParamMetadata<T extends ParameterMetadata>(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): T[][];
/**
 * has param decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {boolean}
 */
export declare function hasParamMetadata(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): boolean;
/**
 * has param decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {boolean}
 */
export declare function hasOwnParamMetadata(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): boolean;
export declare function getParamerterNames(target: Type<any> | AbstractType<any>): ObjectMap<string[]>;
export declare function getOwnParamerterNames(target: Type<any> | AbstractType<any>): ObjectMap<string[]>;
export declare function setParamerterNames(target: ClassType<any>): void;
