{"version":3,"sources":["Container.ts"],"names":[],"mappings":"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","file":"../Container.js","sourcesContent":["import 'reflect-metadata';\r\nimport { IContainer, ContainerToken, ResoveWay } from './IContainer';\r\nimport {\r\n    Type, Token, Factory, SymbolType, IocState,\r\n    ReferenceToken, RefTokenType, RefTokenFacType,\r\n    RefTokenFac, Modules, LoadType, RefTarget, RefTagLevel, ClassType, ToInstance, InstanceFactory\r\n} from './types';\r\nimport {\r\n    isClass, isFunction, isSymbol, isToken, isString, isUndefined,\r\n    lang, isArray, isBoolean, isRefTarget, isTypeObject, isAbstractClass, isClassType, isNumber\r\n} from './utils';\r\nimport { IParameter } from './IParameter';\r\nimport { Registration, isRegistrationClass } from './Registration';\r\nimport { MethodAccessorToken } from './IMethodAccessor';\r\nimport { CoreActions, CacheActionData, LifeState, ActionComponent, enumerable } from './core';\r\nimport { CacheManagerToken } from './ICacheManager';\r\nimport { IContainerBuilder, ContainerBuilderToken } from './IContainerBuilder';\r\nimport { registerCores } from './registerCores';\r\nimport { ResolverChain, ResolverChainToken } from './resolves';\r\nimport { InjectReference, InjectClassProvidesToken, isInjectReference } from './InjectReference';\r\nimport { LifeScope, LifeScopeToken } from './LifeScope';\r\nimport { ParamProviders, ProviderMap, ProviderParserToken, IProviderParser, ProviderTypes } from './providers';\r\nimport { IResolver } from './IResolver';\r\n\r\n/**\r\n * singleton reg token.\r\n */\r\nconst SingletonRegToken = '___IOC__Singleton___';\r\n\r\n/**\r\n * Container\r\n *\r\n * @export\r\n * @class Container\r\n * @implements {IContainer}\r\n */\r\nexport class Container implements IContainer {\r\n\r\n    // @enumerable(false)\r\n    parent: IContainer;\r\n\r\n    // @enumerable(false)\r\n    children: IContainer[] = [];\r\n\r\n    /**\r\n     * provide types.\r\n     *\r\n     * @protected\r\n     * @type {Map<Token<any>, Type<any>>}\r\n     * @memberof Container\r\n     */\r\n    protected provideTypes: Map<Token<any>, Type<any>>;\r\n    /**\r\n     * factories.\r\n     *\r\n     * @protected\r\n     * @type {Map<Token<any>, Function>}\r\n     * @memberof Container\r\n     */\r\n    protected factories: Map<Token<any>, InstanceFactory<any>>;\r\n\r\n    constructor() {\r\n        this.init();\r\n    }\r\n\r\n    get size(): number {\r\n        return this.factories.size;\r\n    }\r\n    /**\r\n     * get root container.\r\n     *\r\n     * @returns {IContainer}\r\n     * @memberof Container\r\n     */\r\n    getRoot(): IContainer {\r\n        let root: IContainer = this;\r\n        while (root.parent) {\r\n            root = root.parent;\r\n        }\r\n        return root;\r\n    }\r\n\r\n    private parser: IProviderParser;\r\n    getProviderParser(): IProviderParser {\r\n        if (!this.parser) {\r\n            this.parser = this.resolveValue(ProviderParserToken)\r\n        }\r\n        return this.parser;\r\n    }\r\n\r\n    /**\r\n     * get container builder.\r\n     *\r\n     * @returns {IContainerBuilder}\r\n     * @memberof Container\r\n     */\r\n    getBuilder(): IContainerBuilder {\r\n        return this.resolveValue(ContainerBuilderToken);\r\n    }\r\n\r\n    /**\r\n    * resolve token value in this container only.\r\n    *\r\n    * @template T\r\n    * @param {Token<T>} token\r\n    * @param {...ParamProviders[]} providers\r\n    * @returns {T}\r\n    * @memberof Container\r\n    */\r\n    getResolvers(): ResolverChain {\r\n        return this.resolveValue(ResolverChainToken);\r\n    }\r\n\r\n    /**\r\n     * has register the token or not.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [aliasOrway]\r\n     * @returns {boolean}\r\n     * @memberof Container\r\n     */\r\n    has<T>(token: Token<T>, aliasOrway?: string | ResoveWay): boolean {\r\n        return this.getResolvers().has(token, aliasOrway);\r\n    }\r\n\r\n    /**\r\n     * has register type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} key\r\n     * @returns\r\n     * @memberof Container\r\n     */\r\n    hasRegister<T>(key: Token<T>): boolean {\r\n        return this.factories.has(this.getTokenKey(key));\r\n    }\r\n\r\n    /**\r\n     * Retrieves an instance from the container based on the provided token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    get<T>(token: Token<T>, alias?: string, ...providers: ParamProviders[]): T {\r\n        return this.resolve(alias ? this.getTokenKey<T>(token, alias) : token, ...providers);\r\n    }\r\n\r\n    /**\r\n     * resolve type instance with token and param provider.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} [notFoundValue]\r\n     * @param {...ParamProviders[]} providers\r\n     * @memberof Container\r\n     */\r\n    resolve<T>(token: Token<T>, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T {\r\n        return this.getResolvers().resolve(token, resway, ...providers);\r\n    }\r\n\r\n    /**\r\n     * resolve first token when not null.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>[]} tokens\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    resolveFirst<T>(tokens: Token<T>[], ...providers: ParamProviders[]): T {\r\n        let inst: T;\r\n        tokens.some(tk => {\r\n            inst = this.resolve(tk, ...providers);\r\n            return inst !== null;\r\n        })\r\n        return inst;\r\n    }\r\n\r\n    /**\r\n     * resolve token value in this container only.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    resolveValue<T>(token: Token<T>, ...providers: ParamProviders[]): T {\r\n        let key = this.getTokenKey<T>(token);\r\n        if (!this.hasRegister(key)) {\r\n            return null;\r\n        }\r\n        let factory = this.factories.get(key);\r\n        return factory(...providers) as T;\r\n    }\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {(RefTarget | RefTarget[])} [target] service refrence target.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], target?: RefTarget | RefTarget[] | ParamProviders, toRefToken?: boolean | Token<T> | RefTokenFac<T> | ParamProviders, defaultToken?: boolean | Token<T> | ParamProviders, ...providers: ParamProviders[]): T {\r\n        if (isArray(target) || isToken(target) || isRefTarget(target) || isTypeObject(target)) {\r\n            let tokens: Token<any>[] = [];\r\n            (isArray(token) ? token : [token]).forEach(tk => {\r\n                tokens.push(tk);\r\n                if (!isClass(tk)) {\r\n                    tokens.push(this.getTokenImpl(tk));\r\n                }\r\n            });\r\n\r\n            let fac: RefTokenFac<T>;\r\n            let defToken: Token<T> | Token<any>[];\r\n            let prds: ParamProviders[] = [];\r\n            if (isBoolean(toRefToken)) {\r\n                if (toRefToken) {\r\n                    defToken = token;\r\n                } else {\r\n                    defToken = null;\r\n                }\r\n            } else if (isToken(toRefToken)) {\r\n                defToken = toRefToken;\r\n            } else if (isFunction(toRefToken)) {\r\n                fac = toRefToken;\r\n                if (isBoolean(defaultToken)) {\r\n                    if (defaultToken) {\r\n                        defToken = token;\r\n                    } else {\r\n                        defToken = null;\r\n                    }\r\n                } else if (isToken(defaultToken)) {\r\n                    defToken = defaultToken;\r\n                } else if (defaultToken) {\r\n                    prds.push(defaultToken);\r\n                }\r\n            } else if (toRefToken) {\r\n                prds.unshift(toRefToken);\r\n            }\r\n\r\n\r\n            defToken = defToken === null ? null : (defToken || token);\r\n            prds = prds.concat(providers);\r\n            return this.getRefService(\r\n                [\r\n                    ...tokens.map(tk => { return { service: tk, isPrivate: true } }),\r\n                    ...fac ? [tk => fac(tk)] : [],\r\n                    ...tokens.map(t => (tk) => new InjectReference(t, tk))\r\n                ],\r\n                target as RefTarget | RefTarget[],\r\n                defToken,\r\n                ...prds);\r\n        } else {\r\n            return this.resolveFirst(isArray(token) ? token : [token], ...[target, toRefToken as ParamProviders, defaultToken as ParamProviders, ...providers].filter(a => a));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get target reference service.\r\n     *\r\n     * @template T\r\n     * @param {Type<Registration<T>>} [refToken] reference service Registration Injector\r\n     * @param {RefTarget | RefTarget[]} target  the service reference to.\r\n     * @param {Token<T>} [defaultToken] default service token.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    getRefService<T>(refToken: ReferenceToken<T>, target: RefTarget | RefTarget[], defaultToken?: Token<T> | Token<any>[], ...providers: ParamProviders[]): T {\r\n        let service: T = null;\r\n        (isArray(target) ? target : [target])\r\n            .some(tag => {\r\n                this.forInRefTarget(tag, tk => {\r\n                    // exclude ref registration.\r\n                    if (isInjectReference(tk)) {\r\n                        return true;\r\n                    }\r\n                    return !(isArray(refToken) ? refToken : [refToken]).some(stk => {\r\n                        let tokens = this.getRefToken(stk, tk);\r\n                        return (isArray(tokens) ? tokens : [tokens]).some(rtk => {\r\n                            service = this.resolveRef(rtk, tk, ...providers);\r\n                            return service !== null;\r\n                        });\r\n                    });\r\n                });\r\n                return service !== null;\r\n            });\r\n\r\n        if (!service && defaultToken) {\r\n            service = this.resolveFirst(isArray(defaultToken) ? defaultToken : [defaultToken], ...providers);\r\n        }\r\n        return service;\r\n    }\r\n\r\n    /**\r\n     * get all service extends type and reference target.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n     * @param {(Token<any> | Token<any>[])} [target] service refrence target.\r\n     * @param {(boolean|ParamProviders)} [both]\r\n     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getServices<T>(token: Token<T> | ((token: ClassType<T>) => boolean), target?: ResoveWay | Token<any> | Token<any>[] | ParamProviders, both?: boolean | ResoveWay | ParamProviders, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T[] {\r\n        let services: T[] = [];\r\n        this.iteratorServices((tk, fac, resolver, ...pds) => {\r\n            services.push(fac(...pds));\r\n        }, token, target, both, resway, ...providers);\r\n        return services;\r\n    }\r\n\r\n    /**\r\n     * get all service extends type and reference target.\r\n     *\r\n     * @template T\r\n     * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express\r\n     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n     * @param {(Token<any> | Token<any>[])} [target] service refrence target.\r\n     * @param {(boolean|ParamProviders)} [both]\r\n     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    iteratorServices<T>(\r\n        express: (tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean,\r\n        token: Token<T> | ((token: ClassType<T>) => boolean),\r\n        target?: ResoveWay | Token<any> | Token<any>[] | ParamProviders,\r\n        both?: boolean | ResoveWay | ParamProviders,\r\n        resway?: ResoveWay | ParamProviders,\r\n        ...providers: ParamProviders[]): void {\r\n\r\n        let withTag: boolean;\r\n        let rway = ResoveWay.all;\r\n        let withBoth = false;\r\n        let matchExp: (token: ClassType<T>) => boolean;\r\n        if (isToken(token)) {\r\n            let type = isClassType(token) ? token : this.getTokenImpl(token);\r\n            matchExp = (tk) => lang.isExtendsClass(tk, type);\r\n        } else if (isFunction(token)) {\r\n            matchExp = token;\r\n        }\r\n\r\n        if (isNumber(resway)) {\r\n            rway = resway;\r\n        } else {\r\n            providers.unshift(resway);\r\n        }\r\n        if (isToken(target) || isArray(target)) {\r\n            withTag = true;\r\n            if (isBoolean(both)) {\r\n                withBoth = both;\r\n            } else if (isNumber(both)) {\r\n                rway = both;\r\n            } else {\r\n                providers.unshift(both);\r\n            }\r\n            let tags: ClassType<any>[] = (isArray(target) ? target : [target]).map(t => {\r\n                if (isClass(t)) {\r\n                    return t;\r\n                } else if (isAbstractClass(t)) {\r\n                    return t;\r\n                } else {\r\n                    return this.getTokenImpl(t);\r\n                }\r\n            });\r\n            // target private service.\r\n            this.getResolvers().toArray().some(resolver => {\r\n                return tags.some(tg => {\r\n                    let priMapTk = new InjectReference(ProviderMap, tg);\r\n                    if (resolver.has(priMapTk, ResoveWay.nodes)) {\r\n                        let priMap = resolver.resolve(priMapTk, ResoveWay.nodes);\r\n                        return priMap.keys().some(ptk => {\r\n                            if (isClassType(ptk) && matchExp(ptk)) {\r\n                                return express(ptk, priMap.get(ptk), priMap, ...providers) !== false;\r\n                            }\r\n                            return false;\r\n                        });\r\n                    }\r\n                    return false;\r\n                });\r\n            });\r\n        } else {\r\n            if (isNumber(target)) {\r\n                rway = target;\r\n            } else {\r\n                providers.unshift(target);\r\n            }\r\n            withTag = false;\r\n        }\r\n        if (!withTag || (withTag && withBoth)) {\r\n            this.iterator((tk, fac, resolver) => {\r\n                if (isClassType(tk) && matchExp(tk)) {\r\n                    return express(tk, fac, resolver, ...providers);\r\n                }\r\n            }, rway);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * iterator all registered factory\r\n     *\r\n     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean} callbackfn\r\n     * @param {ResoveWay} [resway= ResoveWay.all]\r\n     * @memberof Container\r\n     */\r\n    iterator(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean, resway = ResoveWay.all): void {\r\n        this.getResolvers().iterator(callbackfn, resway);\r\n    }\r\n\r\n    /**\r\n     * iterator.\r\n     *\r\n     * @param {(tk: Token<any>, fac: InstanceFactory<any>) => void | boolean} callbackfn\r\n     * @memberof IExports\r\n     */\r\n    forEach(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean): void | boolean {\r\n        return !Array.from(this.factories.keys()).some(tk => {\r\n            return callbackfn(tk, this.factories.get(tk), this) === false;\r\n        });\r\n    }\r\n\r\n    protected getRefToken<T>(ref: RefTokenFacType<T>, tk: Token<any>): RefTokenType<T> | RefTokenType<T>[] {\r\n        if (isRegistrationClass(ref)) {\r\n            return new ref(tk);\r\n        }\r\n        if (isToken(ref)) {\r\n            return ref;\r\n        }\r\n        if (isFunction(ref)) {\r\n            return ref(tk);\r\n        }\r\n        return ref;\r\n    }\r\n\r\n    protected resolveRef<T>(refToken: RefTokenType<T>, target: Token<any>, ...providers: ParamProviders[]): T {\r\n        let tk: Token<T>;\r\n        let isPrivate = false;\r\n        if (isToken(refToken)) {\r\n            tk = refToken;\r\n        } else {\r\n            tk = refToken.service;\r\n            isPrivate = refToken.isPrivate !== false;\r\n        }\r\n\r\n        if (!tk) {\r\n            return null;\r\n        }\r\n        // resolve private first.\r\n        if (isClass(target) && !isInjectReference(tk)) {\r\n            let pdrmap = this.resolve(new InjectReference(ProviderMap, target));\r\n            if (pdrmap && pdrmap.has(tk)) {\r\n                return pdrmap.resolve(tk, ...providers);\r\n            }\r\n        }\r\n        // have not private registered.\r\n        if (isPrivate) {\r\n            return null;\r\n        }\r\n        return this.resolve(tk, ...providers);\r\n    }\r\n\r\n    /**\r\n     * get tocken key.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {SymbolType<T>}\r\n     * @memberof Container\r\n     */\r\n    getTokenKey<T>(token: Token<T>, alias?: string): SymbolType<T> {\r\n        if (alias) {\r\n            return new Registration(token, alias).toString();\r\n        } else if (token instanceof Registration) {\r\n            return token.toString();\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * register type.\r\n     * @abstract\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} [value]\r\n     * @returns {this}\r\n     * @memberOf Container\r\n     */\r\n    register<T>(token: Token<T>, value?: Factory<T>): this {\r\n        this.registerFactory(token, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * register stingleton type.\r\n     * @abstract\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {Factory<T>} [value]\r\n     * @returns {this}\r\n     * @memberOf Container\r\n     */\r\n    registerSingleton<T>(token: Token<T>, value?: Factory<T>): this {\r\n        this.registerFactory(token, value, true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * register value.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} value\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    registerValue<T>(token: Token<T>, value: T): this {\r\n        let key = this.getTokenKey(token);\r\n        this.getSingleton().set(key, value);\r\n        if (!this.factories.has(key)) {\r\n            this.factories.set(key, () => {\r\n                return this.getSingleton().get(key);\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * bind provider.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} provide\r\n     * @param {Token<T>} provider\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    bindProvider<T>(provide: Token<T>, provider: Token<T> | Factory<T>): this {\r\n        let provideKey = this.getTokenKey(provide);\r\n        let factory;\r\n        if (isToken(provider)) {\r\n            factory = (...providers: ParamProviders[]) => {\r\n                return this.resolve(provider, ...providers);\r\n            };\r\n        } else {\r\n            if (isFunction(provider)) {\r\n                factory = (...providers: ParamProviders[]) => {\r\n                    return (<ToInstance<any>>provider)(this, ...providers);\r\n                };\r\n            } else {\r\n                factory = () => {\r\n                    return provider\r\n                };\r\n            }\r\n        }\r\n        if (isClass(provider)) {\r\n            if (!this.has(provider)) {\r\n                this.register(provider);\r\n            }\r\n            this.provideTypes.set(provideKey, provider);\r\n        } else if (isToken(provider)) {\r\n            let token = provider;\r\n            while (this.provideTypes.has(token) && !isClass(token)) {\r\n                token = this.provideTypes.get(token);\r\n                if (isClass(token)) {\r\n                    this.provideTypes.set(provideKey, token);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.factories.set(provideKey, factory);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * bind providers for only target class.\r\n     *\r\n     * @param {Token<any>} target\r\n     * @param {ParamProviders[]} providers\r\n     * @param {(mapTokenKey: Token<any>) => void} [onceBinded]\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    bindProviders(target?: Token<any> | ProviderTypes, onceBinded?: ProviderTypes | ((mapTokenKey: Token<any>) => void), ...providers: ProviderTypes[]): this {\r\n        let tgt: Token<any>;\r\n        let complete: (mapTokenKey: Token<any>) => void;\r\n        let prods: ProviderTypes[] = providers;\r\n\r\n        if (isFunction(onceBinded)) {\r\n            complete = onceBinded as (mapTokenKey: Token<any>) => void;\r\n        } else if (onceBinded) {\r\n            prods.unshift(onceBinded);\r\n        }\r\n\r\n        if (isToken(target)) {\r\n            tgt = target;\r\n        } else if (target) {\r\n            tgt = null;\r\n            prods.unshift(target);\r\n        }\r\n\r\n        let maps = this.getProviderParser().parse(...prods);\r\n        if (tgt) {\r\n            let refKey = new InjectReference(ProviderMap, isClass(tgt) ? tgt : this.getTokenImpl(tgt));\r\n            if (this.hasRegister(refKey)) {\r\n                this.resolveValue(refKey).copy(maps);\r\n            } else {\r\n                this.bindProvider(refKey, maps);\r\n                complete && complete(refKey);\r\n            }\r\n        } else {\r\n            maps.keys().forEach(key => {\r\n                isToken(key) && this.factories.set(key, (...prds) => maps.resolve(key, ...prds));\r\n            })\r\n\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * bind provider ref to target.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>} target\r\n     * @param {Token<T>} provide\r\n     * @param {(Token<T> | Factory<T>)} provider\r\n     * @param {string} [alias]\r\n     * @param {(refToken: Token<T>) => void} [onceBinded]\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    bindRefProvider<T>(target: Token<any>, provide: Token<T>, provider: Token<T> | Factory<T>, alias?: string, onceBinded?: (refToken: Token<T>) => void): this {\r\n        let refToken = new InjectReference(this.getTokenKey(provide, alias), target);\r\n        this.bindProvider(refToken, provider);\r\n        onceBinded && onceBinded(refToken);\r\n        return this;\r\n    }\r\n\r\n    unregisterValue<T>(token: Token<T>): this {\r\n        let key = this.getTokenKey(token);\r\n        if (this.hasRegister(key)) {\r\n            this.factories.delete(key);\r\n            if (this.provideTypes.has(key)) {\r\n                this.provideTypes.delete(key);\r\n            }\r\n            if (isClass(key)) {\r\n                this.clearCache(key);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * unregister the token\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {ResoveWay} [resway]\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    unregister<T>(token: Token<T>, resway?: ResoveWay): this {\r\n        this.getResolvers().unregister(token, resway);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * clear cache.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @memberof IContainer\r\n     */\r\n    clearCache(targetType: Type<any>) {\r\n        this.resolveValue(CacheManagerToken).destroy(targetType);\r\n    }\r\n\r\n    /**\r\n     * get token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {Token<T>}\r\n     * @memberof Container\r\n     */\r\n    getToken<T>(token: Token<T>, alias?: string): Token<T> {\r\n        if (alias) {\r\n            return new Registration(token, alias);\r\n        }\r\n        return token;\r\n    }\r\n\r\n    getTokenProvider<T>(token: Token<T>): Type<T> {\r\n        if (isClass(token)) {\r\n            return token;\r\n        }\r\n        let tokenKey = this.getTokenKey(token);\r\n        if (this.provideTypes.has(tokenKey)) {\r\n            return this.provideTypes.get(tokenKey);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * get token implements class type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {boolean} [inchain]\r\n     * @returns {Type<T>}\r\n     * @memberof Container\r\n     */\r\n    getTokenImpl<T>(token: Token<T>, resway?: ResoveWay): Type<T> {\r\n        return this.getResolvers().getTokenImpl(token, resway);\r\n    }\r\n\r\n    /**\r\n     * iterate token  in  token class chain.  return false will break iterate.\r\n     *\r\n     * @param {RefTarget} target\r\n     * @param {(token: Token<any>) => boolean} express\r\n     * @memberof Container\r\n     */\r\n    forInRefTarget(target: RefTarget, express: (token: Token<any>) => boolean): void {\r\n        let type: ClassType<any>;\r\n        let token: Token<any>;\r\n        let level: RefTagLevel;\r\n        if (isToken(target)) {\r\n            token = target;\r\n            level = RefTagLevel.all;\r\n        } else if (target) {\r\n            if (isRefTarget(target)) {\r\n                token = target.target;\r\n                level = target.level || RefTagLevel.self;\r\n            } else if (isTypeObject(target)) {\r\n                token = lang.getClass(target);\r\n                level = RefTagLevel.all;\r\n            }\r\n        }\r\n\r\n        if (!isToken(token)) {\r\n            return;\r\n        }\r\n\r\n        if (isClassType(token)) {\r\n            type = token;\r\n            if (isClass(type) && !this.has(type)) {\r\n                this.use(type);\r\n            }\r\n        } else {\r\n            type = this.getTokenImpl(token);\r\n        }\r\n        if (!isClassType(token) || (RefTagLevel.self === level)) {\r\n            express(token);\r\n            return;\r\n        }\r\n\r\n        let inChain = (level & RefTagLevel.chain) > 0;\r\n        let inProviders = (level & RefTagLevel.providers) > 0;\r\n        lang.forInClassChain(type, ty => {\r\n            let tokens: Token<any>[];\r\n            if (inProviders) {\r\n                let prdKey = new InjectClassProvidesToken(ty);\r\n                let prds = this.get(prdKey);\r\n                if (prds && prds.provides && prds.provides.length) {\r\n                    let ppdkey = prdKey.toString();\r\n                    let pmapKey = new InjectReference(ProviderMap, ty).toString();\r\n                    tokens = prds.provides.slice(1).filter(p => {\r\n                        let key = this.getTokenKey(p);\r\n                        return key !== ppdkey && key !== pmapKey\r\n                    });\r\n                }\r\n            }\r\n            tokens = tokens || [];\r\n            return !(tokens.concat(ty).some(tk => express(tk) === false)) && inChain;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * get token implement class and base classes.\r\n     *\r\n     * @param {Token<any>} token\r\n     * @returns {Token<any>[]}\r\n     * @memberof Container\r\n     */\r\n    getTokenClassChain(token: Token<any>, chain = true): Token<any>[] {\r\n        let tokens: Token<any>[] = [];\r\n        this.forInRefTarget(token, tk => {\r\n            tokens.push(tk);\r\n            return chain;\r\n        });\r\n        return tokens;\r\n    }\r\n\r\n    /**\r\n    * get life scope of container.\r\n    *\r\n    * @returns {LifeScope}\r\n    * @memberof IContainer\r\n    */\r\n    getLifeScope(): LifeScope {\r\n        return this.get(LifeScopeToken);\r\n    }\r\n\r\n    /**\r\n     * use modules.\r\n     *\r\n     * @param {...Modules[]} modules\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    use(...modules: Modules[]): this {\r\n        this.getBuilder().syncLoadModule(this, ...modules);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * async use modules.\r\n     *\r\n     * @param {...LoadType[]} modules load modules.\r\n     * @returns {Promise<Type<any>[]>}  types loaded.\r\n     * @memberof IContainer\r\n     */\r\n    loadModule(...modules: LoadType[]): Promise<Type<any>[]> {\r\n        return this.getBuilder().loadModule(this, ...modules);\r\n    }\r\n\r\n    /**\r\n     * invoke method async.\r\n     *\r\n     * @template T\r\n     * @param {any} target\r\n     * @param {string} propertyKey\r\n     * @param {*} [instance]\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {Promise<T>}\r\n     * @memberof Container\r\n     */\r\n    invoke<T>(target: any, propertyKey: string, instance?: any, ...providers: ParamProviders[]): Promise<T> {\r\n        return this.resolveValue(MethodAccessorToken).invoke(target, propertyKey, instance, ...providers);\r\n    }\r\n\r\n    /**\r\n     * invoke method.\r\n     *\r\n     * @template T\r\n     * @param {any} target\r\n     * @param {string} propertyKey\r\n     * @param {*} [instance]\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    syncInvoke<T>(target: Token<any>, propertyKey: string, instance?: any, ...providers: ParamProviders[]): T {\r\n        return this.resolveValue(MethodAccessorToken).syncInvoke(target, propertyKey, instance, ...providers);\r\n    }\r\n\r\n    createSyncParams(params: IParameter[], ...providers: ParamProviders[]): any[] {\r\n        return this.resolveValue(MethodAccessorToken).createSyncParams(params, ...providers);\r\n    }\r\n\r\n    createParams(params: IParameter[], ...providers: ParamProviders[]): Promise<any[]> {\r\n        return this.resolveValue(MethodAccessorToken).createParams(params, ...providers);\r\n    }\r\n\r\n    protected cacheDecorator<T>(map: Map<string, ActionComponent>, action: ActionComponent) {\r\n        if (!map.has(action.name)) {\r\n            map.set(action.name, action);\r\n        }\r\n    }\r\n\r\n    protected init() {\r\n        this.factories = new Map();\r\n        this.provideTypes = new Map();\r\n        this.bindProvider(ContainerToken, () => this);\r\n        registerCores(this);\r\n    }\r\n\r\n    protected getSingleton(): Map<Token<any>, any> {\r\n        if (!this.hasRegister(SingletonRegToken)) {\r\n            this.bindProvider(SingletonRegToken, new Map<Token<any>, any>());\r\n        }\r\n        return this.resolveValue(SingletonRegToken);\r\n    }\r\n\r\n    protected registerFactory<T>(token: Token<T>, value?: Factory<T>, singleton?: boolean) {\r\n        let key = this.getTokenKey(token);\r\n\r\n        if (this.factories.has(key)) {\r\n            return;\r\n        }\r\n\r\n        let classFactory;\r\n        if (!isUndefined(value)) {\r\n            if (isFunction(value)) {\r\n                if (isClass(value)) {\r\n                    this.bindTypeFactory(key, value as Type<T>, singleton);\r\n                } else {\r\n                    classFactory = this.createCustomFactory(key, value as ToInstance<T>, singleton);\r\n                }\r\n            } else if (singleton && value !== undefined) {\r\n                classFactory = this.createCustomFactory(key, () => value, singleton);\r\n            }\r\n\r\n        } else if (!isString(token) && !isSymbol(token)) {\r\n            let ClassT = (token instanceof Registration) ? token.getClass() : token;\r\n            if (isClass(ClassT)) {\r\n                this.bindTypeFactory(key, ClassT as Type<T>, singleton);\r\n            }\r\n        }\r\n\r\n        if (classFactory) {\r\n            this.factories.set(key, classFactory);\r\n        }\r\n    }\r\n\r\n    protected createCustomFactory<T>(key: SymbolType<T>, factory?: ToInstance<T>, singleton?: boolean) {\r\n        return singleton ?\r\n            (...providers: ParamProviders[]) => {\r\n                if (this.getSingleton().has(key)) {\r\n                    return this.getSingleton().get(key);\r\n                }\r\n                let instance = factory(this, ...providers);\r\n                this.getSingleton().set(key, instance);\r\n                return instance;\r\n            }\r\n            : (...providers: ParamProviders[]) => factory(this, ...providers);\r\n    }\r\n\r\n    protected bindTypeFactory<T>(key: SymbolType<T>, ClassT?: Type<T>, singleton?: boolean) {\r\n        if (!Reflect.isExtensible(ClassT)) {\r\n            return;\r\n        }\r\n\r\n        let lifeScope = this.getLifeScope();\r\n        let parameters = lifeScope.getConstructorParameters(ClassT);\r\n        if (!singleton) {\r\n            singleton = lifeScope.isSingletonType<T>(ClassT);\r\n        }\r\n\r\n        let factory = (...providers: ParamProviders[]) => {\r\n            if (singleton && this.getSingleton().has(key)) {\r\n                return this.getSingleton().get(key);\r\n            }\r\n\r\n            if (providers.length < 1) {\r\n                let lifecycleData: CacheActionData = {\r\n                    tokenKey: key,\r\n                    targetType: ClassT,\r\n                    // raiseContainer: this,\r\n                    singleton: singleton\r\n                };\r\n                lifeScope.execute(lifecycleData, CoreActions.cache);\r\n                if (lifecycleData.execResult && lifecycleData.execResult instanceof ClassT) {\r\n                    return lifecycleData.execResult;\r\n                }\r\n            }\r\n\r\n            let providerMap = this.getProviderParser().parse(...providers);\r\n\r\n            lifeScope.execute({\r\n                tokenKey: key,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.beforeCreateArgs);\r\n\r\n            let args = this.createSyncParams(parameters, providerMap);\r\n\r\n            lifeScope.routeExecute({\r\n                tokenKey: key,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.beforeConstructor);\r\n\r\n            let instance = new ClassT(...args);\r\n\r\n            lifeScope.routeExecute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.afterConstructor);\r\n\r\n            lifeScope.execute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.onInit);\r\n\r\n\r\n            lifeScope.routeExecute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.AfterInit);\r\n\r\n            lifeScope.execute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this\r\n            }, CoreActions.cache);\r\n\r\n            return instance;\r\n        };\r\n\r\n        this.factories.set(key, factory);\r\n\r\n        lifeScope.routeExecute({\r\n            tokenKey: key,\r\n            targetType: ClassT,\r\n            raiseContainer: this\r\n        }, IocState.design);\r\n\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"Container\",\"params\":{\"constructor\":[],\"getRoot\":[],\"getProviderParser\":[],\"getBuilder\":[],\"getResolvers\":[],\"has\":[\"token\",\"aliasOrway\"],\"hasRegister\":[\"key\"],\"get\":[\"token\",\"alias\",\"providers\"],\"resolve\":[\"token\",\"resway\",\"providers\"],\"resolveFirst\":[\"tokens\",\"providers\"],\"resolveValue\":[\"token\",\"providers\"],\"getService\":[\"token\",\"target\",\"toRefToken\",\"defaultToken\",\"providers\"],\"getRefService\":[\"refToken\",\"target\",\"defaultToken\",\"providers\"],\"getServices\":[\"token\",\"target\",\"both\",\"resway\",\"providers\"],\"iteratorServices\":[\"express\",\"token\",\"target\",\"both\",\"resway\",\"providers\"],\"iterator\":[\"callbackfn\",\"resway\"],\"forEach\":[\"callbackfn\"],\"getRefToken\":[\"ref\",\"tk\"],\"resolveRef\":[\"refToken\",\"target\",\"providers\"],\"getTokenKey\":[\"token\",\"alias\"],\"register\":[\"token\",\"value\"],\"registerSingleton\":[\"token\",\"value\"],\"registerValue\":[\"token\",\"value\"],\"bindProvider\":[\"provide\",\"provider\"],\"bindProviders\":[\"target\",\"onceBinded\",\"providers\"],\"bindRefProvider\":[\"target\",\"provide\",\"provider\",\"alias\",\"onceBinded\"],\"unregisterValue\":[\"token\"],\"unregister\":[\"token\",\"resway\"],\"clearCache\":[\"targetType\"],\"getToken\":[\"token\",\"alias\"],\"getTokenProvider\":[\"token\"],\"getTokenImpl\":[\"token\",\"resway\"],\"forInRefTarget\":[\"target\",\"express\"],\"getTokenClassChain\":[\"token\",\"chain\"],\"getLifeScope\":[],\"use\":[\"modules\"],\"loadModule\":[\"modules\"],\"invoke\":[\"target\",\"propertyKey\",\"instance\",\"providers\"],\"syncInvoke\":[\"target\",\"propertyKey\",\"instance\",\"providers\"],\"createSyncParams\":[\"params\",\"providers\"],\"createParams\":[\"params\",\"providers\"],\"cacheDecorator\":[\"map\",\"action\"],\"init\":[],\"getSingleton\":[],\"registerFactory\":[\"token\",\"value\",\"singleton\"],\"createCustomFactory\":[\"key\",\"factory\",\"singleton\"],\"bindTypeFactory\":[\"key\",\"ClassT\",\"singleton\"]}};\n                        }\n                   }\r\n"]}