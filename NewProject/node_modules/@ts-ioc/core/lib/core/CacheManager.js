"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
/**
 * cache manager.
 *
 * @export
 * @class CacheManager
 * @implements {ICacheManager}
 */
var CacheManager = /** @class */ (function () {
    function CacheManager(container) {
        this.container = container;
        this.cacheTokens = new Map();
    }
    CacheManager.prototype.isChecking = function () {
        return !!this.timeout;
    };
    CacheManager.prototype.hasCache = function (targetType) {
        return this.cacheTokens.has(targetType);
    };
    CacheManager.prototype.cache = function (targetType, target, expires) {
        var cache;
        if (this.hasCache(targetType)) {
            cache = this.cacheTokens.get(targetType);
            cache.expires = Date.now() + expires;
        }
        else {
            cache = {
                target: target,
                expires: Date.now() + expires
            };
        }
        this.cacheTokens.set(targetType, cache);
        if (!this.isChecking()) {
            this.checkExpires();
        }
    };
    CacheManager.prototype.get = function (targetType, expires) {
        var result = null;
        if (!this.cacheTokens.has(targetType)) {
            return null;
        }
        var cache = this.cacheTokens.get(targetType);
        if (cache.expires <= Date.now()) {
            result = cache.target;
            if (utils_1.isNumber(expires) && expires > 0) {
                cache.expires = Date.now() + expires;
                this.cacheTokens.set(targetType, cache);
            }
        }
        else {
            this.destroy(targetType, cache.target);
        }
        return result;
    };
    CacheManager.prototype.checkExpires = function () {
        var _this = this;
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = 0;
        }
        if (this.cacheTokens.size > 0) {
            var timeoutCaches_1 = [];
            this.cacheTokens.forEach(function (cache, targetType) {
                if (cache.expires >= Date.now()) {
                    timeoutCaches_1.push(targetType);
                }
            });
            if (timeoutCaches_1.length) {
                timeoutCaches_1.forEach(function (targetType) {
                    _this.destroy(targetType, _this.cacheTokens.get(targetType).target);
                });
            }
            this.timeout = setTimeout(function () {
                _this.checkExpires();
            }, 60000);
        }
    };
    CacheManager.prototype.destroy = function (targetType, target) {
        if (!this.hasCache(targetType)) {
            return;
        }
        if (!target) {
            target = this.cacheTokens.get(targetType).target;
        }
        try {
            var component = target;
            if (utils_1.isFunction(component.onDestroy)) {
                this.container.syncInvoke(target || targetType, 'onDestroy', target);
            }
            this.cacheTokens.delete(targetType);
        }
        catch (err) {
            console.error && console.error(err);
        }
    };
    CacheManager.getClassAnnations = function () {
        return { "name": "CacheManager", "params": { "constructor": ["container"], "isChecking": [], "hasCache": ["targetType"], "cache": ["targetType", "target", "expires"], "get": ["targetType", "expires"], "checkExpires": [], "destroy": ["targetType", "target"] } };
    };
    return CacheManager;
}());
exports.CacheManager = CacheManager;

//# sourceMappingURL=../sourcemaps/core/CacheManager.js.map
