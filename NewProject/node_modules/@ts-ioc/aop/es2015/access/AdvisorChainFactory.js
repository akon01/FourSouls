"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@ts-ioc/core");
const joinpoints_1 = require("../joinpoints");
const IAdvisorChainFactory_1 = require("./IAdvisorChainFactory");
const IAdvisorChain_1 = require("./IAdvisorChain");
const NonePointcut_1 = require("../decorators/NonePointcut");
const IAdvisor_1 = require("../IAdvisor");
/**
 * advisor chain factory.
 *
 * @export
 * @class AdvisorChainFactory
 * @implements {IAdvisorChainFactory}
 */
let AdvisorChainFactory = class AdvisorChainFactory {
    constructor(container, advisor, advices) {
        this.container = container;
        this.advisor = advisor;
        this.advices = advices;
    }
    getAdvicers(adviceType) {
        return (adviceType ? this.advices[adviceType] : null) || [];
    }
    invoaction(joinPoint, state, valueOrthrowing) {
        joinPoint.state = state;
        joinPoint.returning = undefined;
        joinPoint.throwing = undefined;
        switch (state) {
            case joinpoints_1.JoinpointState.Before:
                this.before(joinPoint);
                break;
            case joinpoints_1.JoinpointState.Pointcut:
                this.pointcut(joinPoint);
                break;
            case joinpoints_1.JoinpointState.After:
                joinPoint.returning = valueOrthrowing;
                this.after(joinPoint);
                break;
            case joinpoints_1.JoinpointState.AfterThrowing:
                joinPoint.throwing = valueOrthrowing;
                this.afterThrowing(joinPoint);
                break;
            case joinpoints_1.JoinpointState.AfterReturning:
                joinPoint.returning = valueOrthrowing;
                this.afterReturning(joinPoint);
                break;
        }
    }
    before(joinPoint) {
        let cloneJp = core_1.lang.assign({}, joinPoint);
        this.getAdvicers('Around')
            .forEach(advicer => {
            this.invokeAdvice(cloneJp, advicer);
        });
        if (!core_1.isUndefined(cloneJp.args)) {
            joinPoint.args = cloneJp.args;
        }
        this.getAdvicers('Before')
            .forEach(advicer => {
            this.invokeAdvice(cloneJp, advicer);
        });
    }
    pointcut(joinPoint) {
        let cloneJp = core_1.lang.assign({}, joinPoint);
        this.getAdvicers('Pointcut')
            .forEach(advicer => {
            this.invokeAdvice(cloneJp, advicer);
        });
        if (!core_1.isUndefined(cloneJp.args)) {
            joinPoint.args = cloneJp.args;
        }
    }
    after(joinPoint) {
        let cloneJp = core_1.lang.assign({}, joinPoint);
        this.getAdvicers('Around')
            .forEach(advicer => {
            this.invokeAdvice(cloneJp, advicer);
        });
        this.getAdvicers('After')
            .forEach(advicer => {
            this.invokeAdvice(cloneJp, advicer);
        });
    }
    afterThrowing(joinPoint) {
        let cloneJp = core_1.lang.assign({}, joinPoint);
        this.getAdvicers('Around')
            .forEach(advicer => {
            this.invokeAdvice(cloneJp, advicer);
        });
        this.getAdvicers('AfterThrowing')
            .forEach(advicer => {
            this.invokeAdvice(cloneJp, advicer);
        });
    }
    afterReturning(joinPoint) {
        let cloneJp = core_1.lang.assign({}, joinPoint);
        let advChain = this.container.resolve(IAdvisorChain_1.AdvisorChainToken, { joinPoint: cloneJp });
        this.getAdvicers('Around')
            .forEach(advicer => {
            advChain.next((jp) => {
                return this.invokeAdvice(jp, advicer);
            });
        });
        this.getAdvicers('AfterReturning')
            .forEach(advicer => {
            advChain.next(jp => {
                return this.invokeAdvice(jp, advicer);
            });
        });
        advChain.next((jp) => {
            if (!core_1.isUndefined(jp.returning)) {
                joinPoint.returning = jp.returning;
            }
            return joinPoint;
        });
        advChain.process();
    }
    invokeAdvice(joinPoint, advicer) {
        let providers = [];
        providers.push(core_1.Provider.createExtends(joinpoints_1.Joinpoint, joinPoint, (inst, provider) => {
            inst._cache_JoinPoint = provider.resolve(this.container);
        }));
        let metadata = advicer.advice;
        if (!core_1.isUndefined(joinPoint.args) && metadata.args) {
            providers.push(core_1.Provider.create(metadata.args, joinPoint.args));
        }
        if (metadata.annotationArgName) {
            providers.push(core_1.Provider.create(metadata.annotationArgName, () => {
                let curj = joinPoint;
                let annotations = curj.annotations;
                while (!annotations && joinPoint.provJoinpoint) {
                    curj = joinPoint.provJoinpoint;
                    if (curj && curj.annotations) {
                        annotations = curj.annotations;
                        break;
                    }
                }
                if (core_1.isArray(annotations)) {
                    if (metadata.annotationName) {
                        let d = metadata.annotationName;
                        d = /^@/.test(d) ? d : `@${d}`;
                        return annotations.filter(a => a.decorator === d);
                    }
                    return annotations;
                }
                else {
                    return [];
                }
            }));
        }
        if (!core_1.isUndefined(joinPoint.returning) && metadata.returning) {
            providers.push(core_1.Provider.create(metadata.returning, joinPoint.returning));
        }
        if (!core_1.isUndefined(joinPoint.throwing) && metadata.throwing) {
            providers.push(core_1.Provider.create(metadata.throwing, joinPoint.throwing));
        }
        return this.advisor.getContainer(advicer.aspectType, this.container).syncInvoke(advicer.aspectType, advicer.advice.propertyKey, null, ...providers);
    }
    static getClassAnnations() {
        return { "name": "AdvisorChainFactory", "params": { "constructor": ["container", "advisor", "advices"], "getAdvicers": ["adviceType"], "invoaction": ["joinPoint", "state", "valueOrthrowing"], "before": ["joinPoint"], "pointcut": ["joinPoint"], "after": ["joinPoint"], "afterThrowing": ["joinPoint"], "afterReturning": ["joinPoint"], "invokeAdvice": ["joinPoint", "advicer"] } };
    }
};
AdvisorChainFactory = tslib_1.__decorate([
    NonePointcut_1.NonePointcut(),
    core_1.Injectable(IAdvisorChainFactory_1.AdvisorChainFactoryToken),
    tslib_1.__param(0, core_1.Inject(core_1.ContainerToken)), tslib_1.__param(1, core_1.Inject(IAdvisor_1.AdvisorToken)),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object])
], AdvisorChainFactory);
exports.AdvisorChainFactory = AdvisorChainFactory;

//# sourceMappingURL=../sourcemaps/access/AdvisorChainFactory.js.map
