{"version":3,"sources":["providers/ProviderMap.ts"],"names":[],"mappings":";;AAAA,oCAAyF;AAEzF,8CAAsD;AACtD,gDAA6C;AAI7C,0BAA0B;AAEb,QAAA,gBAAgB,GAAG,IAAI,yBAAW,CAAc,gBAAgB,CAAC,CAAC;AAE/E;;;;;;;GAOG;AACH,MAAa,WAAY,SAAQ,eAAkD;IAE/E,YAAoB,SAAqB;QACrC,KAAK,EAAE,CAAC;QADQ,cAAS,GAAT,SAAS,CAAY;IAEzC,CAAC;IAED;;;;;;OAMG;IACH,GAAG,CAAC,OAA4B;QAC5B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;IACnD,CAAC;IAED,QAAQ;QACJ,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,eAAO,CAAC,CAAC,CAAC,CAAiB,CAAC;IAC/D,CAAC;IAED;;;;;;OAMG;IACH,WAAW,CAAC,KAA0B;QAClC,IAAI,eAAO,CAAC,KAAK,CAAC,EAAE;YAChB,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;SAC5C;QACD,OAAO,KAAK,CAAC;IACjB,CAAC;IAED;;;;;;;OAOG;IACH,GAAG,CAAI,OAA0B;QAC7B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;IACnD,CAAC;IAED,YAAY,CAAI,KAAe,EAAE,MAAkB;QAC/C,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IACtD,CAAC;IAED,UAAU,CAAI,KAAe,EAAE,MAAkB;QAC7C,IAAI,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAClC,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACnB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACxB;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;;;OAQG;IACH,GAAG,CAAI,OAA0B,EAAE,QAA+B;QAC9D,IAAI,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;QACpC,IAAI,mBAAW,CAAC,GAAG,CAAC,EAAE;YAClB,OAAO,IAAI,CAAC;SACf;QACD,IAAI,OAAO,CAAC;QACZ,IAAI,eAAO,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;YACnD,OAAO,GAAG,CAAC,GAAG,SAA0B,EAAE,EAAE;gBACxC,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,GAAG,SAAS,CAAC,CAAC;YAC1D,CAAC,CAAC;SACL;aAAM;YACH,IAAI,kBAAU,CAAC,QAAQ,CAAC,EAAE;gBACtB,OAAO,GAAG,QAAQ,CAAC;aACtB;iBAAM;gBACH,OAAO,GAAG,GAAG,EAAE;oBACX,OAAO,QAAQ,CAAC;gBACpB,CAAC,CAAC;aACL;SACJ;QACD,IAAI,OAAO,EAAE;YACT,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;SAC9B;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;;;OAQG;IACH,OAAO,CAAI,OAA0B,EAAE,MAAmC,EAAE,GAAG,SAA2B;QACtG,IAAI,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;QACpC,IAAI,GAAc,CAAC;QACnB,IAAI,gBAAQ,CAAC,MAAM,CAAC,EAAE;YAClB,GAAG,GAAG,MAAM,CAAC;SAChB;aAAM;YACH,IAAI,MAAM,EAAE;gBACR,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;aAC7B;YACD,GAAG,GAAG,sBAAS,CAAC,OAAO,CAAC;SAC3B;QACD,IAAI,CAAC,GAAG,GAAG,sBAAS,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YAChD,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACjC,OAAO,kBAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;SAC/D;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,OAAO,CAAC,UAAqF;QACzF,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YAC1B,CAAC,gBAAQ,CAAC,GAAG,CAAC,IAAI,UAAU,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;QACjD,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;OAMG;IACH,IAAI,CAAC,GAAgB;QACjB,IAAI,CAAC,GAAG,EAAE;YACN,OAAO,IAAI,CAAC;SACf;QACD,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;YAC1B,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QAC3B,CAAC,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IAChB,CAAC;IAEmB,MAAM,CAAC,iBAAiB;QACpB,OAAO,EAAC,MAAM,EAAC,aAAa,EAAC,QAAQ,EAAC,EAAC,aAAa,EAAC,CAAC,WAAW,CAAC,EAAC,KAAK,EAAC,CAAC,SAAS,CAAC,EAAC,UAAU,EAAC,EAAE,EAAC,aAAa,EAAC,CAAC,OAAO,CAAC,EAAC,KAAK,EAAC,CAAC,SAAS,CAAC,EAAC,cAAc,EAAC,CAAC,OAAO,EAAC,QAAQ,CAAC,EAAC,YAAY,EAAC,CAAC,OAAO,EAAC,QAAQ,CAAC,EAAC,KAAK,EAAC,CAAC,SAAS,EAAC,UAAU,CAAC,EAAC,SAAS,EAAC,CAAC,SAAS,EAAC,QAAQ,EAAC,WAAW,CAAC,EAAC,SAAS,EAAC,CAAC,YAAY,CAAC,EAAC,MAAM,EAAC,CAAC,KAAK,CAAC,EAAC,EAAC,CAAC;IACrU,CAAC;CACL;AAlJpB,kCAkJoB;AAIpB;;;;;;GAMG;AACH,SAAgB,aAAa,CAAC,MAAc;IACxC,IAAI,CAAC,gBAAQ,CAAC,MAAM,CAAC,EAAE;QACnB,OAAO,KAAK,CAAC;KAChB;IACD,OAAO,MAAM,YAAY,WAAW,CAAC;AACzC,CAAC;AALD,sCAKC","file":"../../providers/ProviderMap.js","sourcesContent":["import { isToken, isFunction, isUndefined, isObject, isNumber, MapBase } from '../utils';\r\nimport { Token, InstanceFactory, SymbolType, Factory, Type } from '../types';\r\nimport { IContainer, ResoveWay } from '../IContainer';\r\nimport { InjectToken } from '../InjectToken';\r\nimport { IResolver, IResolverContainer } from '../IResolver';\r\nimport { ProviderTypes, ParamProviders } from './types';\r\n\r\n// use core-js in browser.\r\n\r\nexport const ProviderMapToken = new InjectToken<ProviderMap>('DI_ProviderMap');\r\n\r\n/**\r\n * Provider Map.\r\n *\r\n * note: object map provider can not resolve token.\r\n *\r\n * @export\r\n * @class Providers\r\n */\r\nexport class ProviderMap extends MapBase<Token<any> | number, InstanceFactory<any>> implements IResolverContainer {\r\n\r\n    constructor(private container: IContainer) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * has provide or not.\r\n     *\r\n     * @param {(Token<any> | number)} provide\r\n     * @returns {boolean}\r\n     * @memberof ProviderMap\r\n     */\r\n    has(provide: Token<any> | number): boolean {\r\n        return this.map.has(this.getTokenKey(provide));\r\n    }\r\n\r\n    provides(): Token<any>[] {\r\n        return this.keys().filter(k => isToken(k)) as Token<any>[];\r\n    }\r\n\r\n    /**\r\n     * get token key.\r\n     *\r\n     * @param {(Token<any> | number)} token\r\n     * @returns {(SymbolType<any> | number)}\r\n     * @memberof ProviderMap\r\n     */\r\n    getTokenKey(token: Token<any> | number): SymbolType<any> | number {\r\n        if (isToken(token)) {\r\n            return this.container.getTokenKey(token);\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * get token factory.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | number)} provide\r\n     * @returns {InstanceFactory<T>}\r\n     * @memberof ProviderMap\r\n     */\r\n    get<T>(provide: Token<T> | number): InstanceFactory<T> {\r\n        return this.map.get(this.getTokenKey(provide));\r\n    }\r\n\r\n    getTokenImpl<T>(token: Token<T>, resway?: ResoveWay): Type<T> {\r\n        return this.container.getTokenImpl(token, resway);\r\n    }\r\n\r\n    unregister<T>(token: Token<T>, resway?: ResoveWay): this {\r\n        let key = this.getTokenKey(token);\r\n        if (this.map.has(key)) {\r\n            this.map.delete(key);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * add and bind token provider.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | number)} provide\r\n     * @param {(Token<T> | Factory<T>)} provider\r\n     * @returns {this}\r\n     * @memberof ProviderMap\r\n     */\r\n    add<T>(provide: Token<T> | number, provider: Token<T> | Factory<T>): this {\r\n        let key = this.getTokenKey(provide);\r\n        if (isUndefined(key)) {\r\n            return this;\r\n        }\r\n        let factory;\r\n        if (isToken(provider) && this.container.has(provider)) {\r\n            factory = (...providers: ProviderTypes[]) => {\r\n                return this.container.resolve(provider, ...providers);\r\n            };\r\n        } else {\r\n            if (isFunction(provider)) {\r\n                factory = provider;\r\n            } else {\r\n                factory = () => {\r\n                    return provider;\r\n                };\r\n            }\r\n        }\r\n        if (factory) {\r\n            this.map.set(key, factory);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * resolve instance via provide token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} provide\r\n     * @param {...ProviderTypes[]} providers\r\n     * @returns {T}\r\n     * @memberof ProviderMap\r\n     */\r\n    resolve<T>(provide: Token<T> | number, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T {\r\n        let key = this.getTokenKey(provide);\r\n        let way: ResoveWay;\r\n        if (isNumber(resway)) {\r\n            way = resway;\r\n        } else {\r\n            if (resway) {\r\n                providers.unshift(resway);\r\n            }\r\n            way = ResoveWay.current;\r\n        }\r\n        if ((way & ResoveWay.current) && this.map.has(key)) {\r\n            let provider = this.map.get(key);\r\n            return isFunction(provider) ? provider(...providers) : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    forEach(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void): void {\r\n        this.map.forEach((fac, key) => {\r\n            !isNumber(key) && callbackfn(key, fac, this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * copy provider map.\r\n     *\r\n     * @param {ProviderMap} map\r\n     * @returns\r\n     * @memberof ProviderMap\r\n     */\r\n    copy(map: ProviderMap): this {\r\n        if (!map) {\r\n            return this;\r\n        }\r\n        this.map.forEach((fac, key) => {\r\n            this.map.set(key, fac);\r\n        });\r\n        return this;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ProviderMap\",\"params\":{\"constructor\":[\"container\"],\"has\":[\"provide\"],\"provides\":[],\"getTokenKey\":[\"token\"],\"get\":[\"provide\"],\"getTokenImpl\":[\"token\",\"resway\"],\"unregister\":[\"token\",\"resway\"],\"add\":[\"provide\",\"provider\"],\"resolve\":[\"provide\",\"resway\",\"providers\"],\"forEach\":[\"callbackfn\"],\"copy\":[\"map\"]}};\n                        }\n                   }\r\n\r\n\r\n\r\n/**\r\n * object is provider map or not.\r\n *\r\n * @export\r\n * @param {object} target\r\n * @returns {target is ProviderMap}\r\n */\r\nexport function isProviderMap(target: object): target is ProviderMap {\r\n    if (!isObject(target)) {\r\n        return false;\r\n    }\r\n    return target instanceof ProviderMap;\r\n}\r\n"]}