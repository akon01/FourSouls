{"version":3,"sources":["types.ts"],"names":[],"mappings":";;AAkLA;;;;;GAKG;AACH,IAAY,WA8BX;AA9BD,WAAY,WAAW;IACnB;;OAEG;IACH,6CAAQ,CAAA;IACR;;OAEG;IACH,uDAAkB,CAAA;IAClB;;OAEG;IACH,+DAAgC,CAAA;IAChC;;OAEG;IACH,+CAAc,CAAA;IACd;;OAEG;IACF,uDAAwB,CAAA;IACzB;;OAEG;IACH,iEAAkC,CAAA;IAClC;;OAEG;IACH,2CAA8B,CAAA;AAElC,CAAC,EA9BW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QA8BtB;AAkGD;;;;;GAKG;AACH,IAAY,QAGX;AAHD,WAAY,QAAQ;IAChB,6BAAiB,CAAA;IACjB,+BAAmB,CAAA;AACvB,CAAC,EAHW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAGnB;AAED;;;;;GAKG;AACH,IAAY,IAkBX;AAlBD,WAAY,IAAI;IACZ;;OAEG;IACH,iCAAS,CAAA;IACT;;OAEG;IACH,uCAAQ,CAAA;IACR;;OAEG;IACH,uCAAQ,CAAA;IAER;;OAEG;IACH,+CAAY,CAAA;AAChB,CAAC,EAlBW,IAAI,GAAJ,YAAI,KAAJ,YAAI,QAkBf","file":"../types.js","sourcesContent":["import { Registration } from './Registration';\r\nimport { IContainer } from './IContainer';\r\nimport { ProviderTypes } from './providers';\r\n\r\n/**\r\n * module types.\r\n */\r\nexport type Modules = Type<any> | ObjectMap<any>;\r\n\r\n/**\r\n * load modules in base on an path.\r\n *\r\n * @export\r\n * @interface PathModules\r\n */\r\nexport interface PathModules {\r\n    /**\r\n     * fire express base on the root path.\r\n     *\r\n     * @type {string}\r\n     * @memberof LoadOptions\r\n     */\r\n    basePath?: string;\r\n    /**\r\n     * in nodejs:\r\n     * script files match express.\r\n     * see: https://github.com/isaacs/node-glob\r\n     *\r\n     * in browser:\r\n     * script file url.\r\n     * @type {(string | string[])}\r\n     * @memberof BuilderOptions\r\n     */\r\n    files?: string | string[];\r\n\r\n    /**\r\n     * modules\r\n     *\r\n     * @type {((Modules | string)[])}\r\n     * @memberof AsyncLoadOptions\r\n     */\r\n    modules?: (Modules | string)[];\r\n}\r\n\r\n\r\n/**\r\n * load module type.\r\n */\r\nexport type LoadType = Modules | string | PathModules;\r\n\r\n/**\r\n * class type.\r\n */\r\nexport type ClassType<T> = Type<T> | AbstractType<T>;\r\n/**\r\n * symbol type\r\n */\r\nexport type SymbolType<T> = ClassType<T> | string | symbol;\r\n\r\n/**\r\n * factory tocken.\r\n */\r\nexport type Token<T> = Registration<T> | SymbolType<T>;\r\n\r\n\r\n/**\r\n * instance factory.\r\n */\r\nexport type InstanceFactory<T> = (...providers: ProviderTypes[]) => T\r\n\r\n/**\r\n * to instance via container.\r\n */\r\nexport type ToInstance<T> = (container?: IContainer, ...providers: ProviderTypes[]) => T;\r\n\r\n/**\r\n * Factory of Token\r\n */\r\nexport type Factory<T> = T | Type<T> | ToInstance<T>;\r\n\r\n/**\r\n * object map.\r\n *\r\n * @export\r\n * @interface ObjectMap\r\n * @template T\r\n */\r\nexport interface ObjectMap<T> {\r\n    [index: string]: T\r\n}\r\n\r\n/**\r\n * class Annations\r\n *\r\n * @export\r\n * @interface ClassAnnations\r\n */\r\nexport interface ClassAnnations {\r\n    /**\r\n     * class name\r\n     *\r\n     * @type {string}\r\n     * @memberof ClassAnnations\r\n     */\r\n    name: string;\r\n    /**\r\n     * class params declaration.\r\n     *\r\n     * @type {ObjectMap<string[]>}\r\n     * @memberof ClassAnnations\r\n     */\r\n    params: ObjectMap<string[]>;\r\n}\r\n/**\r\n * class type\r\n * @export\r\n * @interface Type\r\n * @extends {Function}\r\n * @template T\r\n */\r\nexport interface Type<T> extends Function {\r\n    new(...args: any[]): T;\r\n    classAnnations?: ClassAnnations;\r\n    getClassAnnations?(): ClassAnnations;\r\n}\r\n\r\n/**\r\n * abstract type\r\n *\r\n * @export\r\n * @interface AbstractType\r\n * @extends {Function}\r\n * @template T\r\n */\r\nexport interface AbstractType<T> extends Function {\r\n    new?(...args: any[]): T;\r\n    classAnnations?: ClassAnnations;\r\n    getClassAnnations?(): ClassAnnations;\r\n}\r\n\r\n/**\r\n * ref service\r\n *\r\n * @export\r\n * @interface IRefService\r\n * @template T\r\n */\r\nexport interface IRefService<T> {\r\n    /**\r\n     * ref service\r\n     *\r\n     * @type {Token<T>}\r\n     * @memberof IReference\r\n     */\r\n    service: Token<T>;\r\n    /**\r\n     * is private service of target class or not.\r\n     *\r\n     * @type {boolean}\r\n     * @memberof IReference\r\n     */\r\n    isPrivate?: boolean;\r\n}\r\n\r\n/**\r\n * reference token type.\r\n */\r\nexport type RefTokenType<T> = IRefService<T> | Token<T>;\r\n\r\nexport type RefTokenFac<T> = (token: Token<any>) => RefTokenType<T> | RefTokenType<T>[];\r\n\r\nexport type RefTokenFacType<T> = Type<Registration<T>> | RefTokenType<T> | RefTokenFac<T>\r\n\r\n/**\r\n * reference token.\r\n */\r\nexport type ReferenceToken<T> = RefTokenFacType<T> | RefTokenFacType<T>[];\r\n\r\n/**\r\n * reference target level.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum RefTagLevel {\r\n    /**\r\n     * ref taget self only\r\n     */\r\n    self = 1,\r\n    /**\r\n     * ref taget provider.\r\n     */\r\n    providers = 1 << 1,\r\n    /**\r\n     * self provider\r\n     */\r\n    selfProviders = self | providers,\r\n    /**\r\n     * ref target class chain.\r\n     */\r\n    chain = 1 << 2,\r\n    /**\r\n     * self chain.\r\n     */\r\n     selfChain = self | chain,\r\n    /**\r\n     * chain providers.\r\n     */\r\n    chainProviders = chain | providers,\r\n    /**\r\n     * ref all.\r\n     */\r\n    all = self | providers | chain\r\n\r\n}\r\n\r\n/**\r\n * ref target\r\n *\r\n * @export\r\n * @interface IRefTarget\r\n */\r\nexport interface IRefTarget {\r\n    /**\r\n     * ref target.\r\n     *\r\n     * @type {Token<any>}\r\n     * @memberof IRefTarget\r\n     */\r\n    target: Token<any>;\r\n    /**\r\n     * ref target level.\r\n     *\r\n     * @type {RefTagLevel}\r\n     * @memberof IRefTarget\r\n     */\r\n    level: RefTagLevel;\r\n\r\n}\r\n\r\n/**\r\n * reference target.\r\n */\r\nexport type RefTarget = IRefTarget | Token<any> | Object;\r\n\r\n/**\r\n * express.\r\n *\r\n * @export\r\n * @interface Express\r\n * @template T\r\n * @template TResult\r\n */\r\nexport interface Express<T, TResult> {\r\n    (item: T): TResult\r\n}\r\n\r\n/**\r\n * express\r\n *\r\n * @export\r\n * @interface Express2\r\n * @template T1\r\n * @template T2\r\n * @template TResult\r\n */\r\nexport interface Express2<T1, T2, TResult> {\r\n    (arg1: T1, arg2: T2): TResult\r\n}\r\n/**\r\n * express\r\n *\r\n * @export\r\n * @interface Express3\r\n * @template T1\r\n * @template T2\r\n * @template T3\r\n * @template TResult\r\n */\r\nexport interface Express3<T1, T2, T3, TResult> {\r\n    (arg1: T1, arg2: T2, arg3: T3): TResult\r\n}\r\n/**\r\n * express\r\n *\r\n * @export\r\n * @interface Express4\r\n * @template T1\r\n * @template T2\r\n * @template T3\r\n * @template T4\r\n * @template TResult\r\n */\r\nexport interface Express4<T1, T2, T3, T4, TResult> {\r\n    (arg1: T1, arg2: T2, arg3: T3, arg4: T4): TResult\r\n}\r\n/**\r\n * express.\r\n *\r\n * @export\r\n * @interface Express5\r\n * @template T1\r\n * @template T2\r\n * @template T3\r\n * @template T4\r\n * @template T5\r\n * @template TResult\r\n */\r\nexport interface Express5<T1, T2, T3, T4, T5, TResult> {\r\n    (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): TResult\r\n}\r\n\r\n/**\r\n * State of type in ioc.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum IocState {\r\n    design = 'design',\r\n    runtime = 'runtime'\r\n}\r\n\r\n/**\r\n * iterate way.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum Mode {\r\n    /**\r\n     * route up. iterate in parents.\r\n     */\r\n    route = 1,\r\n    /**\r\n     * iterate in children.\r\n     */\r\n    children,\r\n    /**\r\n     * iterate as tree map. node first\r\n     */\r\n    traverse,\r\n\r\n    /**\r\n     * iterate as tree map. node last\r\n     */\r\n    traverseLast\r\n}\r\n"]}