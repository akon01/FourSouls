"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("../utils");
var IContainer_1 = require("../IContainer");
var InjectToken_1 = require("../InjectToken");
// use core-js in browser.
exports.ProviderMapToken = new InjectToken_1.InjectToken('DI_ProviderMap');
/**
 * Provider Map.
 *
 * note: object map provider can not resolve token.
 *
 * @export
 * @class Providers
 */
var ProviderMap = /** @class */ (function (_super) {
    tslib_1.__extends(ProviderMap, _super);
    function ProviderMap(container) {
        var _this = _super.call(this) || this;
        _this.container = container;
        return _this;
    }
    /**
     * has provide or not.
     *
     * @param {(Token<any> | number)} provide
     * @returns {boolean}
     * @memberof ProviderMap
     */
    ProviderMap.prototype.has = function (provide) {
        return this.map.has(this.getTokenKey(provide));
    };
    ProviderMap.prototype.provides = function () {
        return this.keys().filter(function (k) { return utils_1.isToken(k); });
    };
    /**
     * get token key.
     *
     * @param {(Token<any> | number)} token
     * @returns {(SymbolType<any> | number)}
     * @memberof ProviderMap
     */
    ProviderMap.prototype.getTokenKey = function (token) {
        if (utils_1.isToken(token)) {
            return this.container.getTokenKey(token);
        }
        return token;
    };
    /**
     * get token factory.
     *
     * @template T
     * @param {(Token<T> | number)} provide
     * @returns {InstanceFactory<T>}
     * @memberof ProviderMap
     */
    ProviderMap.prototype.get = function (provide) {
        return this.map.get(this.getTokenKey(provide));
    };
    ProviderMap.prototype.getTokenImpl = function (token, resway) {
        return this.container.getTokenImpl(token, resway);
    };
    ProviderMap.prototype.unregister = function (token, resway) {
        var key = this.getTokenKey(token);
        if (this.map.has(key)) {
            this.map.delete(key);
        }
        return this;
    };
    /**
     * add and bind token provider.
     *
     * @template T
     * @param {(Token<T> | number)} provide
     * @param {(Token<T> | Factory<T>)} provider
     * @returns {this}
     * @memberof ProviderMap
     */
    ProviderMap.prototype.add = function (provide, provider) {
        var _this = this;
        var key = this.getTokenKey(provide);
        if (utils_1.isUndefined(key)) {
            return this;
        }
        var factory;
        if (utils_1.isToken(provider) && this.container.has(provider)) {
            factory = function () {
                var providers = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    providers[_i] = arguments[_i];
                }
                var _a;
                return (_a = _this.container).resolve.apply(_a, [provider].concat(providers));
            };
        }
        else {
            if (utils_1.isFunction(provider)) {
                factory = provider;
            }
            else {
                factory = function () {
                    return provider;
                };
            }
        }
        if (factory) {
            this.map.set(key, factory);
        }
        return this;
    };
    /**
     * resolve instance via provide token.
     *
     * @template T
     * @param {Token<T>} provide
     * @param {...ProviderTypes[]} providers
     * @returns {T}
     * @memberof ProviderMap
     */
    ProviderMap.prototype.resolve = function (provide, resway) {
        var providers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers[_i - 2] = arguments[_i];
        }
        var key = this.getTokenKey(provide);
        var way;
        if (utils_1.isNumber(resway)) {
            way = resway;
        }
        else {
            if (resway) {
                providers.unshift(resway);
            }
            way = IContainer_1.ResoveWay.current;
        }
        if ((way & IContainer_1.ResoveWay.current) && this.map.has(key)) {
            var provider = this.map.get(key);
            return utils_1.isFunction(provider) ? provider.apply(void 0, providers) : null;
        }
        return null;
    };
    ProviderMap.prototype.forEach = function (callbackfn) {
        var _this = this;
        this.map.forEach(function (fac, key) {
            !utils_1.isNumber(key) && callbackfn(key, fac, _this);
        });
    };
    /**
     * copy provider map.
     *
     * @param {ProviderMap} map
     * @returns
     * @memberof ProviderMap
     */
    ProviderMap.prototype.copy = function (map) {
        var _this = this;
        if (!map) {
            return this;
        }
        this.map.forEach(function (fac, key) {
            _this.map.set(key, fac);
        });
        return this;
    };
    ProviderMap.getClassAnnations = function () {
        return { "name": "ProviderMap", "params": { "constructor": ["container"], "has": ["provide"], "provides": [], "getTokenKey": ["token"], "get": ["provide"], "getTokenImpl": ["token", "resway"], "unregister": ["token", "resway"], "add": ["provide", "provider"], "resolve": ["provide", "resway", "providers"], "forEach": ["callbackfn"], "copy": ["map"] } };
    };
    return ProviderMap;
}(utils_1.MapBase));
exports.ProviderMap = ProviderMap;
/**
 * object is provider map or not.
 *
 * @export
 * @param {object} target
 * @returns {target is ProviderMap}
 */
function isProviderMap(target) {
    if (!utils_1.isObject(target)) {
        return false;
    }
    return target instanceof ProviderMap;
}
exports.isProviderMap = isProviderMap;

//# sourceMappingURL=../sourcemaps/providers/ProviderMap.js.map
