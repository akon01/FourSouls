'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib_1 = _interopDefault(require('tslib'));
var reflectMetadata = _interopDefault(require('reflect-metadata'));

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var lang_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


// use core-js in browser.
/**
 * map base.
 *
 * @export
 * @class MapBase
 * @template K
 * @template V
 */
var MapBase = /** @class */ (function () {
    function MapBase() {
        this.map = new Map();
    }
    Object.defineProperty(MapBase.prototype, "size", {
        get: function () {
            return this.map.size;
        },
        enumerable: true,
        configurable: true
    });
    MapBase.prototype.clear = function () {
        this.map.clear();
    };
    MapBase.prototype.delete = function (key) {
        return this.map.delete(key);
    };
    MapBase.prototype.get = function (key) {
        return this.map.get(key);
    };
    MapBase.prototype.has = function (key) {
        return this.map.has(key);
    };
    MapBase.prototype.set = function (key, value) {
        this.map.set(key, value);
        return this;
    };
    MapBase.prototype.keys = function () {
        return Array.from(this.map.keys());
    };
    MapBase.prototype.values = function () {
        return Array.from(this.map.values());
    };
    MapBase.getClassAnnations = function () {
        return { "name": "MapBase", "params": { "constructor": [], "clear": [], "delete": ["key"], "get": ["key"], "has": ["key"], "set": ["key", "value"], "keys": [], "values": [] } };
    };
    return MapBase;
}());
exports.MapBase = MapBase;
/**
 * map set  for tsioc old version.
 *
 * @export
 * @class MapSet
 * @template K
 * @template V
 */
var MapSet = /** @class */ (function (_super) {
    tslib_1.__extends(MapSet, _super);
    function MapSet() {
        return _super.call(this) || this;
    }
    MapSet.prototype.forEach = function (callbackfn, thisArg) {
        this.map.forEach(callbackfn, thisArg);
    };
    MapSet.getClassAnnations = function () {
        return { "name": "MapSet", "params": { "constructor": [], "forEach": ["callbackfn", "thisArg"] } };
    };
    return MapSet;
}(MapBase));
exports.MapSet = MapSet;
/**
 * lang utils
 */
var lang;
(function (lang) {
    /**
     * assert param is right or not.
     *
     * @export
     * @param {*} param
     * @param {(string | Function)} msg
     */
    function assert(param, msg) {
        if (typeCheck.isNullOrUndefined(param)) {
            throw new Error(typeCheck.isFunction(msg) ? msg(param) : msg);
        }
    }
    lang.assert = assert;
    /**
     * check assert param invalid by express
     *
     * @export
     * @param {(boolean | (() => boolean))} express
     * @param {(string | Function)} msg
     */
    function assertExp(express, msg) {
        if (!(typeCheck.isFunction(express) ? express() : express)) {
            throw new Error(typeCheck.isFunction(msg) ? msg() : msg);
        }
    }
    lang.assertExp = assertExp;
    /**
     * get object keys.
     *
     * @param {*} target
     * @returns {string[]}
     */
    function keys(target) {
        if (typeCheck.isObject(target)) {
            if (typeCheck.isFunction(Object.keys)) {
                return Object.keys(target);
            }
        }
        return [];
    }
    lang.keys = keys;
    /**
     * values of target object.
     *
     * @export
     * @param {*} target
     * @returns {any[]}
     */
    function values(target) {
        if (typeCheck.isObject(target)) {
            if (typeCheck.isFunction(Object.values)) {
                return Object.values(target);
            }
            else {
                return keys(target).map(function (n) { return target[n]; });
            }
        }
        return [];
    }
    lang.values = values;
    /**
     * assign
     *
     * @export
     * @template T
     * @param {T} target
     * @param {...any[]} source
     * @returns {T}
     */
    function assign(target, source1, source2, sources) {
        if (sources && sources.length) {
            sources.unshift(source2 || {});
            sources.unshift(source1 || {});
            return Object.assign.apply(Object, [target].concat(sources));
        }
        else if (source2) {
            return Object.assign(target, source1 || {}, source2);
        }
        else {
            return Object.assign(target, source1 || {});
        }
    }
    lang.assign = assign;
    /**
     * create an new object from target object omit some field.
     *
     * @export
     * @param {ObjectMap<any>} target
     * @param {...string[]} fields
     * @returns {*}
     */
    function omit(target) {
        var fields = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            fields[_i - 1] = arguments[_i];
        }
        if (typeCheck.isObject(target)) {
            var result_1 = {};
            keys(target).forEach(function (key) {
                if (fields.indexOf(key) < 0) {
                    result_1[key] = target[key];
                }
            });
            return result_1;
        }
        else {
            return target;
        }
    }
    lang.omit = omit;
    /**
     * object has field or not.
     *
     * @export
     * @param {ObjectMap<any>} target
     * @returns
     */
    function hasField(target) {
        return keys(target).length > 0;
    }
    lang.hasField = hasField;
    /**
     * for in opter for object or array.
     *
     * @export
     * @template T
     * @param {(ObjectMap<T> | T[])} target
     * @param {(item: T, idx?: number|string) => void|boolean} iterator
     */
    function forIn(target, iterator) {
        if (typeCheck.isArray(target)) {
            target.some(function (it, idx) { return iterator(it, idx) === false; });
        }
        else if (typeCheck.isObject(target)) {
            keys(target).some(function (key, idx) { return iterator(target[key], key) === false; });
        }
    }
    lang.forIn = forIn;
    /**
     * find
     *
     * @template T
     * @param {(ObjectMap<T> | T[])} target
     * @param {((item: T, idx?: number | string) => boolean)} express
     */
    function find(target, express) {
        var item;
        forIn(target, function (it, idx) {
            if (!item) {
                if (express(it, idx)) {
                    item = it;
                    return false;
                }
                return true;
            }
            else {
                return true;
            }
        });
    }
    lang.find = find;
    /**
     * first.
     *
     * @export
     * @template T
     * @param {T[]} list
     * @returns {T}
     */
    function first(list) {
        if (typeCheck.isArray(list) && list.length) {
            return list[0];
        }
        return null;
    }
    lang.first = first;
    /**
     * last.
     *
     * @export
     * @template T
     * @param {T[]} list
     * @returns {T}
     */
    function last(list) {
        if (typeCheck.isArray(list) && list.length) {
            return list[list.length - 1];
        }
        return null;
    }
    lang.last = last;
    /**
     * get class annations.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns
     */
    function getClassAnnations(target) {
        return typeCheck.isFunction(target.getClassAnnations) ? target.getClassAnnations() : target.classAnnations;
    }
    lang.getClassAnnations = getClassAnnations;
    /**
     * target has class annations or not.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {boolean}
     */
    function hasClassAnnations(target) {
        if (typeCheck.isFunction(target.getClassAnnations)) {
            return true;
        }
        return target.classAnnations && typeCheck.isString(target.classAnnations.name) && target.classAnnations.name.length > 0;
    }
    lang.hasClassAnnations = hasClassAnnations;
    /**
     * get calss of object.
     *
     * @export
     * @param {*} target
     * @returns {Type<any>}
     */
    function getClass(target) {
        if (typeCheck.isNullOrUndefined(target)) {
            return null;
        }
        if (typeCheck.isClass(target)) {
            return target;
        }
        return target.constructor || target.prototype.constructor;
    }
    lang.getClass = getClass;
    /**
     * get class name.
     *
     * @export
     * @param {AbstractType<any>} target
     * @returns {string}
     */
    function getClassName(target) {
        var classType = typeCheck.isFunction(target) ? target : getClass(target);
        if (!typeCheck.isFunction(classType)) {
            return '';
        }
        if (/^[a-z]$/.test(classType.name)) {
            var classAnnations = getClassAnnations(classType);
            return classAnnations ? classAnnations.name : classType.name;
        }
        return classType.name;
    }
    lang.getClassName = getClassName;
    /**
     * get target type parent class.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {ClassType<any>}
     */
    function getParentClass(target) {
        var p = Reflect.getPrototypeOf(target.prototype);
        return typeCheck.isClass(p) ? p : p.constructor;
    }
    lang.getParentClass = getParentClass;
    /**
     * get all parent class in chain.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {ClassType<any>[]}
     */
    function getClassChain(target) {
        var types = [];
        forInClassChain(target, function (type) {
            types.push(type);
        });
        return types;
    }
    lang.getClassChain = getClassChain;
    /**
     * iterate base classes of target in chain. return false will break iterate.
     *
     * @export
     * @param {Type<any>} target
     * @param {(token: Type<any>) => any} express
     */
    function forInClassChain(target, express) {
        while (typeCheck.isClassType(target) && target !== Object) {
            if (express(target) === false) {
                break;
            }
            target = getParentClass(target);
        }
    }
    lang.forInClassChain = forInClassChain;
    /**
     * target is extends class of baseClass or not.
     *
     * @export
     * @param {Token<any>} target
     * @param {(ClassType<any> | ((type: ClassType<any>) => boolean))} baseClass
     * @returns {boolean}
     */
    function isExtendsClass(target, baseClass) {
        var isExtnds = false;
        if (typeCheck.isClassType(target)) {
            forInClassChain(target, function (t) {
                if (typeCheck.isClassType(baseClass)) {
                    isExtnds = t === baseClass;
                }
                else {
                    isExtnds = baseClass(t);
                }
                return !isExtnds;
            });
        }
        return isExtnds;
    }
    lang.isExtendsClass = isExtendsClass;
})(lang = exports.lang || (exports.lang = {}));


});

unwrapExports(lang_1);
var lang_2 = lang_1.MapBase;
var lang_3 = lang_1.MapSet;
var lang_4 = lang_1.lang;

var typeCheck = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * check target is function or not.
 *
 * @export
 * @param {*} target
 * @returns
 */
function isFunction(target) {
    if (!target) {
        return false;
    }
    return typeof target === 'function';
}
exports.isFunction = isFunction;
/**
 * check Abstract class with @Abstract or not
 *
 * @export
 * @param {*} target
 * @returns {target is AbstractType<any>}
 */
function isAbstractClass(target) {
    return classCheck(target) && Reflect.hasOwnMetadata('@Abstract', target);
}
exports.isAbstractClass = isAbstractClass;
/**
 * check target is class or not.
 *
 * @export
 * @param {*} target
 * @returns {target is Type<any>}
 */
function isClass(target) {
    return classCheck(target) && (!Reflect.hasOwnMetadata('@Abstract', target));
}
exports.isClass = isClass;
function isClassType(target) {
    return classCheck(target);
}
exports.isClassType = isClassType;
function classCheck(target) {
    if (!isFunction(target)) {
        return false;
    }
    if (target.prototype) {
        if (!target.name || target.name === 'Object') {
            return false;
        }
        var type = target;
        // for uglify
        if (/^[a-z]$/.test(type.name)) {
            if (lang_1.lang.hasClassAnnations(type)) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (lang_1.lang.hasClassAnnations(type)) {
                return true;
            }
            if (!/^[A-Z@]/.test(target.name)) {
                return false;
            }
        }
        // for IE 8, 9
        if (!isNodejsEnv() && /MSIE [6-9]/.test(navigator.userAgent)) {
            return true;
        }
        try {
            target.arguments && target.caller;
            return false;
        }
        catch (e) {
            return true;
        }
    }
    return false;
}
/**
 * is run in nodejs or not.
 *
 * @export
 * @returns {boolean}
 */
function isNodejsEnv() {
    return (typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined');
}
exports.isNodejsEnv = isNodejsEnv;
/**
 * check target is token or not.
 *
 * @export
 * @param {*} target
 * @returns {target is Token<any>}
 */
function isToken(target) {
    if (!target) {
        return false;
    }
    if (isString(target) || isSymbol(target) || classCheck(target) || (target instanceof Registration_1.Registration)) {
        return true;
    }
    return false;
}
exports.isToken = isToken;
/**
 * is target promise or not. now check is es6 Promise only.
 *
 * @export
 * @param {*} target
 * @returns {target is Promise<any>}
 */
function isPromise(target) {
    if (!target) {
        return false;
    }
    var type = target.constructor || target.prototype.constructor;
    if (type && type.name === 'Promise') {
        return true;
    }
    return false;
}
exports.isPromise = isPromise;
/**
 * is target rxjs observable or not.
 *
 * @export
 * @param {*} target
 * @returns {boolean}
 */
function isObservable(target) {
    if (!target && !isObject(target)) {
        return false;
    }
    var type = target.constructor || target.prototype.constructor;
    if (type && type.name === 'Observable') {
        return true;
    }
    return false;
}
exports.isObservable = isObservable;
/**
 * is target base object or not.
 * eg. {}, have not self constructor;
 * @export
 * @param {*} target
 * @returns {target is Promise<any>}
 */
function isBaseObject(target) {
    if (!target) {
        return false;
    }
    if (target.constructor && target.constructor.name === 'Object') {
        return true;
    }
    return false;
}
exports.isBaseObject = isBaseObject;
/**
 * is metadata object or not.
 *
 * @export
 * @param {*} target
 * @param {...(string|string[])[]} props
 * @returns {boolean}
 */
function isMetadataObject(target) {
    var props = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        props[_i - 1] = arguments[_i];
    }
    if (!isBaseObject(target)) {
        return false;
    }
    if (props.length) {
        return lang_1.lang.keys(target).some(function (n) { return props.some(function (ps) { return isString(ps) ? ps === n : ps.indexOf(n) > 0; }); });
    }
    return true;
}
exports.isMetadataObject = isMetadataObject;
/**
 * is reftarget options or not.
 *
 * @export
 * @param {*} target
 * @returns {target is IRefTarget}
 */
function isRefTarget(target) {
    if (isBaseObject(target) !== true) {
        return false;
    }
    return isToken(target.target);
}
exports.isRefTarget = isRefTarget;
/**
 * check object is class metadata or not.
 *
 * @export
 * @param {*} target
 * @param {...(string | string[])[]} extendsProps
 * @returns {boolean}
 */
function isClassMetadata(target) {
    var extendsProps = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        extendsProps[_i - 1] = arguments[_i];
    }
    return isMetadataObject.apply(void 0, [target].concat(extendsProps.concat(['singleton', 'provide', 'alias', 'type'])));
}
exports.isClassMetadata = isClassMetadata;
/**
 * check object is property metadata or not.
 *
 * @export
 * @param {*} target
 * @param {...(string | string[])[]} extendsProps
 * @returns {boolean}
 */
function isProvideMetadata(target) {
    var extendsProps = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        extendsProps[_i - 1] = arguments[_i];
    }
    return isMetadataObject.apply(void 0, [target].concat(extendsProps.concat(['type', 'provider'])));
}
exports.isProvideMetadata = isProvideMetadata;
/**
 * check target is string or not.
 *
 * @export
 * @param {*} target
 * @returns {target is string}
 */
function isString(target) {
    return typeof target === 'string';
}
exports.isString = isString;
/**
 * check target is boolean or not.
 *
 * @export
 * @param {*} target
 * @returns {target is boolean}
 */
function isBoolean(target) {
    return typeof target === 'boolean' || (target === true || target === false);
}
exports.isBoolean = isBoolean;
/**
 * check target is number or not.
 *
 * @export
 * @param {*} target
 * @returns {target is number}
 */
function isNumber(target) {
    return typeof target === 'number';
}
exports.isNumber = isNumber;
/**
 * check target is undefined or not.
 *
 * @export
 * @param {*} target
 * @returns {target is undefined}
 */
function isUndefined(target) {
    return typeof target === 'undefined' || target === undefined;
}
exports.isUndefined = isUndefined;
/**
 * check target is unll or not.
 *
 * @export
 * @param {*} target
 * @returns {target is null}
 */
function isNull(target) {
    return target === null;
}
exports.isNull = isNull;
/**
 * is target null or undefined.
 *
 * @export
 * @param {*} target
 * @returns {boolean}
 */
function isNullOrUndefined(target) {
    return isNull(target) || isUndefined(target);
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * check target is array or not.
 *
 * @export
 * @param {*} target
 * @returns {target is Array<any>}
 */
function isArray(target) {
    return Array.isArray(target);
}
exports.isArray = isArray;
/**
 * check target is object or not.
 *
 * @export
 * @param {*} target
 * @returns {target is object}
 */
function isObject(target) {
    if (isNullOrUndefined(target)) {
        return false;
    }
    var type = typeof target;
    return type === 'object' || type === 'function';
}
exports.isObject = isObject;
/**
 * is custom class type instance or not.
 *
 * @export
 * @param {*} target
 * @returns {boolean}
 */
function isTypeObject(target) {
    if (isNullOrUndefined(target)) {
        return false;
    }
    if (typeof target !== 'object') {
        return false;
    }
    var type = lang_1.lang.getClass(target);
    if (isBaseType(type)) {
        return false;
    }
    return true;
}
exports.isTypeObject = isTypeObject;
/**
 * check target is date or not.
 *
 * @export
 * @param {*} target
 * @returns {target is Date}
 */
function isDate(target) {
    return isObject(target) && target instanceof Date;
}
exports.isDate = isDate;
/**
 * check target is symbol or not.
 *
 * @export
 * @param {*} target
 * @returns {target is Symbol}
 */
function isSymbol(target) {
    return typeof target === 'symbol' || (isObject(target) && /^Symbol\(/.test(target.toString()));
}
exports.isSymbol = isSymbol;
/**
 * check target is regexp or not.
 *
 * @export
 * @param {*} target
 * @returns {target is RegExp}
 */
function isRegExp(target) {
    return target && target instanceof RegExp;
}
exports.isRegExp = isRegExp;
/**
 * is base type or not.
 *
 * @export
 * @param {*} target
 * @returns {boolean}
 */
function isBaseType(target) {
    if (!isFunction(target)) {
        return false;
    }
    return target === Object
        || target === Boolean
        || target === String
        || target === Number
        || target === Date;
}
exports.isBaseType = isBaseType;


});

unwrapExports(typeCheck);
var typeCheck_1 = typeCheck.isFunction;
var typeCheck_2 = typeCheck.isAbstractClass;
var typeCheck_3 = typeCheck.isClass;
var typeCheck_4 = typeCheck.isClassType;
var typeCheck_5 = typeCheck.isNodejsEnv;
var typeCheck_6 = typeCheck.isToken;
var typeCheck_7 = typeCheck.isPromise;
var typeCheck_8 = typeCheck.isObservable;
var typeCheck_9 = typeCheck.isBaseObject;
var typeCheck_10 = typeCheck.isMetadataObject;
var typeCheck_11 = typeCheck.isRefTarget;
var typeCheck_12 = typeCheck.isClassMetadata;
var typeCheck_13 = typeCheck.isProvideMetadata;
var typeCheck_14 = typeCheck.isString;
var typeCheck_15 = typeCheck.isBoolean;
var typeCheck_16 = typeCheck.isNumber;
var typeCheck_17 = typeCheck.isUndefined;
var typeCheck_18 = typeCheck.isNull;
var typeCheck_19 = typeCheck.isNullOrUndefined;
var typeCheck_20 = typeCheck.isArray;
var typeCheck_21 = typeCheck.isObject;
var typeCheck_22 = typeCheck.isTypeObject;
var typeCheck_23 = typeCheck.isDate;
var typeCheck_24 = typeCheck.isSymbol;
var typeCheck_25 = typeCheck.isRegExp;
var typeCheck_26 = typeCheck.isBaseType;

var PromiseUtil_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * defer
 *
 * @export
 * @class Defer
 * @template T
 */
var Defer = /** @class */ (function () {
    function Defer() {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
    }
    Defer.create = function (then) {
        var defer = new Defer();
        if (then) {
            defer.promise = defer.promise.then(then);
            return defer;
        }
        else {
            return defer;
        }
    };
    Defer.getClassAnnations = function () {
        return { "name": "Defer", "params": { "create": ["then"], "constructor": [] } };
    };
    return Defer;
}());
exports.Defer = Defer;
/**
 * promise util.
 */
var PromiseUtil;
(function (PromiseUtil) {
    /**
     * create defer.
     *
     * @export
     * @template T
     * @param {((val: T) => T | PromiseLike<T>)} [then]
     * @returns {Defer<T>}
     */
    function defer(then) {
        return Defer.create(then);
    }
    PromiseUtil.defer = defer;
    /**
     * foreach opter for promises.
     *
     * @export
     * @template T
     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises
     * @param {Express<T, any>} express
     * @param {T} [defVal]
     * @returns
     */
    function forEach(promises, express, defVal) {
        var defer = new Defer();
        var pf = Promise.resolve(defVal);
        var length = promises ? promises.length : 0;
        if (length) {
            promises.forEach(function (p, idx) {
                pf = pf.then(function (v) { return typeCheck.isFunction(p) ? p(v) : p; })
                    .then(function (data) {
                    if (express(data) === false) {
                        defer.resolve('complete');
                        return Promise.reject('complete');
                    }
                    else if (idx === length - 1) {
                        defer.resolve('complete');
                        return Promise.reject('complete');
                    }
                    return data;
                });
            });
            pf.catch(function (err) {
                return err;
            });
        }
        else {
            defer.reject('array empty.');
        }
        return defer.promise;
    }
    PromiseUtil.forEach = forEach;
    /**
     * run promise step by step.
     *
     * @export
     * @template T
     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises
     * @returns
     */
    function step(promises) {
        var result = Promise.resolve(null);
        promises.forEach(function (p) {
            result = result.then(function (v) { return typeCheck.isFunction(p) ? p(v) : p; });
        });
        return result;
    }
    PromiseUtil.step = step;
    /**
     * find first validate value from promises.
     *
     * @export
     * @template T
     * @param {(...(T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises
     * @param {Express<T, boolean>} validate
     * @returns
     */
    function find(promises, filter, defVal) {
        var defer = new Defer();
        forEach(promises, function (val) {
            if (filter(val)) {
                defer.resolve(val);
                return false;
            }
            return true;
        }, defVal)
            .then(function () { return defer.resolve(null); })
            .catch(function () {
            defer.resolve(null);
        });
        return defer.promise;
    }
    PromiseUtil.find = find;
    /**
     * run action in chain.
     *
     * @export
     * @template T
     * @param {ActionHandle<T>[]} handles
     * @param {T} ctx
     * @param {() => Promise<void>} [next]
     * @returns {Promise<void>}
     */
    function runInChain(handles, ctx, next) {
        var index = -1;
        return dispatch(0);
        function dispatch(idx) {
            if (idx <= index) {
                return Promise.reject('next called mutiple times');
            }
            index = idx;
            var handle = idx < handles.length ? handles[idx] : null;
            if (idx === handles.length) {
                handle = next;
            }
            if (!handle) {
                return Promise.resolve();
            }
            try {
                return Promise.resolve(handle(ctx, dispatch.bind(null, idx + 1)));
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
    }
    PromiseUtil.runInChain = runInChain;
})(PromiseUtil = exports.PromiseUtil || (exports.PromiseUtil = {}));


});

unwrapExports(PromiseUtil_1);
var PromiseUtil_2 = PromiseUtil_1.Defer;
var PromiseUtil_3 = PromiseUtil_1.PromiseUtil;

var utils = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(typeCheck, exports);
tslib_1.__exportStar(lang_1, exports);
tslib_1.__exportStar(PromiseUtil_1, exports);


});

unwrapExports(utils);

var Registration_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * is registration class or not.
 *
 * @export
 * @param {*} target
 * @returns
 */
function isRegistrationClass(target) {
    if (utils.isClass(target)) {
        return target.isIocRegClass === true;
    }
    return false;
}
exports.isRegistrationClass = isRegistrationClass;
/**
 * inject token.
 * @export
 * @class Registration
 * @template T
 */
var Registration = /** @class */ (function () {
    /**
     * Creates an instance of Registration.
     * @param {(Token<T> | Token<any>)} provideType
     * @param {string} desc
     * @memberof Registration
     */
    function Registration(provideType, desc) {
        this.type = '';
        this.init(provideType, desc);
    }
    Registration.prototype.init = function (provideType, desc) {
        if (provideType instanceof Registration) {
            if (desc) {
                this.classType = provideType.toString();
                this.desc = desc;
            }
            else {
                this.classType = provideType.getProvide();
                this.desc = provideType.getDesc();
            }
        }
        else {
            this.classType = provideType;
            this.desc = desc;
        }
    };
    /**
     * get provide.
     *
     * @returns {SymbolType<any>}
     * @memberof Registration
     */
    Registration.prototype.getProvide = function () {
        return this.classType;
    };
    /**
     * get class.
     *
     * @returns
     * @memberof Registration
     */
    Registration.prototype.getClass = function () {
        if (utils.isClass(this.classType)) {
            return this.classType;
        }
        return null;
    };
    /**
     * get desc.
     *
     * @returns
     * @memberof Registration
     */
    Registration.prototype.getDesc = function () {
        return this.desc;
    };
    /**
     * to string.
     *
     * @returns {string}
     * @memberof Registration
     */
    Registration.prototype.toString = function () {
        return this.format(this);
    };
    Registration.prototype.format = function (reg) {
        if (reg instanceof Registration) {
            var name_1 = '';
            if (utils.isFunction(reg.classType)) {
                name_1 = "{" + utils.lang.getClassName(reg.classType) + "}";
            }
            else if (reg.classType) {
                name_1 = reg.classType.toString();
            }
            return [reg.type, name_1, reg.desc].filter(function (n) { return n; }).join('_');
        }
        else if (utils.isFunction(reg)) {
            return "{" + utils.lang.getClassName(reg) + "}";
        }
        else if (reg) {
            return reg.toString();
        }
        return '';
    };
    Registration.getClassAnnations = function () {
        return { "name": "Registration", "params": { "constructor": ["provideType", "desc"], "init": ["provideType", "desc"], "getProvide": [], "getClass": [], "getDesc": [], "toString": [], "format": ["reg"] } };
    };
    Registration.isIocRegClass = true;
    return Registration;
}());
exports.Registration = Registration;


});

unwrapExports(Registration_1);
var Registration_2 = Registration_1.isRegistrationClass;
var Registration_3 = Registration_1.Registration;

var InjectToken_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * inject token.
 *
 * @export
 * @class InjectToken
 * @extends {Registration<T>}
 * @template T
 */
var InjectToken = /** @class */ (function (_super) {
    tslib_1.__extends(InjectToken, _super);
    function InjectToken(desc) {
        return _super.call(this, desc, '') || this;
    }
    InjectToken.getClassAnnations = function () {
        return { "name": "InjectToken", "params": { "constructor": ["desc"] } };
    };
    return InjectToken;
}(Registration_1.Registration));
exports.InjectToken = InjectToken;


});

unwrapExports(InjectToken_1);
var InjectToken_2 = InjectToken_1.InjectToken;

var IContainer = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * IContainer token.
 * it is a symbol id, you can use  @Inject, @Autowried or @Param to get container instance in yourself class.
 */
exports.ContainerToken = new InjectToken_1.InjectToken('DI_IContainer');
/**
 * resove way
 *
 * @export
 * @enum {number}
 */
var ResoveWay;
(function (ResoveWay) {
    /**
     * current container.
     */
    ResoveWay[ResoveWay["current"] = 1] = "current";
    /**
     * traverse all curr node children.
     */
    ResoveWay[ResoveWay["traverse"] = 2] = "traverse";
    /**
     * bubble up all parent.
     */
    ResoveWay[ResoveWay["bubble"] = 4] = "bubble";
    /**
     * current and children.
     */
    ResoveWay[ResoveWay["nodes"] = 3] = "nodes";
    /**
     * current and bubble.
     */
    ResoveWay[ResoveWay["routeup"] = 5] = "routeup";
    /**
     *  traverse of curr node, children.
     */
    ResoveWay[ResoveWay["all"] = 7] = "all";
})(ResoveWay = exports.ResoveWay || (exports.ResoveWay = {}));


});

unwrapExports(IContainer);
var IContainer_1 = IContainer.ContainerToken;
var IContainer_2 = IContainer.ResoveWay;

var types = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * reference target level.
 *
 * @export
 * @enum {number}
 */
var RefTagLevel;
(function (RefTagLevel) {
    /**
     * ref taget self only
     */
    RefTagLevel[RefTagLevel["self"] = 1] = "self";
    /**
     * ref taget provider.
     */
    RefTagLevel[RefTagLevel["providers"] = 2] = "providers";
    /**
     * self provider
     */
    RefTagLevel[RefTagLevel["selfProviders"] = 3] = "selfProviders";
    /**
     * ref target class chain.
     */
    RefTagLevel[RefTagLevel["chain"] = 4] = "chain";
    /**
     * self chain.
     */
    RefTagLevel[RefTagLevel["selfChain"] = 5] = "selfChain";
    /**
     * chain providers.
     */
    RefTagLevel[RefTagLevel["chainProviders"] = 6] = "chainProviders";
    /**
     * ref all.
     */
    RefTagLevel[RefTagLevel["all"] = 7] = "all";
})(RefTagLevel = exports.RefTagLevel || (exports.RefTagLevel = {}));
/**
 * State of type in ioc.
 *
 * @export
 * @enum {number}
 */
var IocState;
(function (IocState) {
    IocState["design"] = "design";
    IocState["runtime"] = "runtime";
})(IocState = exports.IocState || (exports.IocState = {}));
/**
 * iterate way.
 *
 * @export
 * @enum {number}
 */
var Mode;
(function (Mode) {
    /**
     * route up. iterate in parents.
     */
    Mode[Mode["route"] = 1] = "route";
    /**
     * iterate in children.
     */
    Mode[Mode["children"] = 2] = "children";
    /**
     * iterate as tree map. node first
     */
    Mode[Mode["traverse"] = 3] = "traverse";
    /**
     * iterate as tree map. node last
     */
    Mode[Mode["traverseLast"] = 4] = "traverseLast";
})(Mode = exports.Mode || (exports.Mode = {}));


});

unwrapExports(types);
var types_1 = types.RefTagLevel;
var types_2 = types.IocState;
var types_3 = types.Mode;

var IMethodAccessor = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * IMethodAccessor interface symbol.
 * it is a symbol id, you can register yourself MethodAccessor for this.
 */
exports.MethodAccessorToken = new InjectToken_1.InjectToken('DI_IMethodAccessor');


});

unwrapExports(IMethodAccessor);
var IMethodAccessor_1 = IMethodAccessor.MethodAccessorToken;

var NullComponent_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * null component.
 *
 * @export
 * @class NullComponent
 * @implements {IComponent}
 */
var NullComponent = /** @class */ (function () {
    function NullComponent() {
    }
    NullComponent.prototype.isEmpty = function () {
        return true;
    };
    NullComponent.prototype.add = function (action) {
        return this;
    };
    NullComponent.prototype.remove = function (action) {
        return this;
    };
    NullComponent.prototype.find = function (express, mode) {
        return exports.NullNode;
    };
    NullComponent.prototype.filter = function (express, mode) {
        return [];
    };
    NullComponent.prototype.each = function (express, mode) {
    };
    NullComponent.prototype.trans = function (express) {
    };
    NullComponent.prototype.transAfter = function (express) {
    };
    NullComponent.prototype.routeUp = function (express) {
    };
    NullComponent.prototype.equals = function (node) {
        return node === exports.NullNode;
    };
    NullComponent.prototype.empty = function () {
        return exports.NullNode;
    };
    NullComponent.getClassAnnations = function () {
        return { "name": "NullComponent", "params": { "isEmpty": [], "add": ["action"], "remove": ["action"], "find": ["express", "mode"], "filter": ["express", "mode"], "each": ["express", "mode"], "trans": ["express"], "transAfter": ["express"], "routeUp": ["express"], "equals": ["node"], "empty": [] } };
    };
    return NullComponent;
}());
exports.NullComponent = NullComponent;
/**
 * Null node
 */
exports.NullNode = new NullComponent();


});

unwrapExports(NullComponent_1);
var NullComponent_2 = NullComponent_1.NullComponent;
var NullComponent_3 = NullComponent_1.NullNode;

var GComposite_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * generics composite
 *
 * @export
 * @class GComposite
 * @implements {GComponent<T>}
 * @template T
 */
var GComposite = /** @class */ (function () {
    function GComposite(name) {
        this.name = name;
        this.children = [];
    }
    GComposite.prototype.add = function (node) {
        node.parent = this;
        this.children.push(node);
        return this;
    };
    GComposite.prototype.remove = function (node) {
        var component;
        if (utils.isString(node)) {
            component = this.find(function (cmp) { return utils.isString(node) ? cmp.name === node : cmp.equals(node); });
        }
        else if (node) {
            component = node;
        }
        else {
            component = this;
        }
        if (!component.parent) {
            return this;
        }
        else if (this.equals(component.parent)) {
            this.children.splice(this.children.indexOf(component), 1);
            component.parent = null;
            return this;
        }
        else {
            component.parent.remove(component);
            return null;
        }
    };
    GComposite.prototype.find = function (express, mode) {
        var component;
        this.each(function (item) {
            if (component) {
                return false;
            }
            var isFinded = utils.isFunction(express) ? express(item) : express === (item);
            if (isFinded) {
                component = item;
                return false;
            }
            return true;
        }, mode);
        return (component || this.empty());
    };
    GComposite.prototype.filter = function (express, mode) {
        var nodes = [];
        this.each(function (item) {
            if (express(item)) {
                nodes.push(item);
            }
        }, mode);
        return nodes;
    };
    GComposite.prototype.each = function (iterate, mode) {
        mode = mode || types.Mode.traverse;
        var r;
        switch (mode) {
            case types.Mode.route:
                r = this.routeUp(iterate);
                break;
            case types.Mode.children:
                r = this.eachChildren(iterate);
                break;
            case types.Mode.traverse:
                r = this.trans(iterate);
                break;
            case types.Mode.traverseLast:
                r = this.transAfter(iterate);
                break;
            default:
                r = this.trans(iterate);
                break;
        }
        return r;
    };
    GComposite.prototype.eachChildren = function (iterate) {
        (this.children || []).forEach(function (item) {
            return iterate(item);
        });
    };
    /**
     *do express work in routing.
     *
     *@param {Express<T, void | boolean>} express
     *
     *@memberOf IComponent
     */
    GComposite.prototype.routeUp = function (iterate) {
        var curr = this;
        if (iterate(curr) === false) {
            return false;
        }
        
        if (this.parent && this.parent.routeUp) {
            return this.parent.routeUp(iterate);
        }
    };
    /**
     *translate all sub context to do express work.
     *
     *@param {Express<T, void | boolean>} express
     *
     *@memberOf IComponent
     */
    GComposite.prototype.trans = function (express) {
        var curr = this;
        if (express(curr) === false) {
            return false;
        }
        var children = this.children || [];
        for (var i = 0; i < children.length; i++) {
            var result = children[i].trans(express);
            if (result === false) {
                return result;
            }
        }
        return true;
    };
    GComposite.prototype.transAfter = function (express) {
        var children = this.children || [];
        for (var i = 0; i < children.length; i++) {
            var result = children[i].transAfter(express);
            if (result === false) {
                return false;
            }
        }
        var curr = this;
        if (express(curr) === false) {
            return false;
        }
        return true;
    };
    GComposite.prototype.equals = function (node) {
        return this === node;
    };
    GComposite.prototype.empty = function () {
        return NullComponent_1.NullNode;
    };
    GComposite.prototype.isEmpty = function () {
        return this.equals(this.empty());
    };
    GComposite.getClassAnnations = function () {
        return { "name": "GComposite", "params": { "constructor": ["name"], "add": ["node"], "remove": ["node"], "find": ["express", "mode"], "filter": ["express", "mode"], "each": ["iterate", "mode"], "eachChildren": ["iterate"], "routeUp": ["iterate"], "trans": ["express"], "transAfter": ["express"], "equals": ["node"], "empty": [], "isEmpty": [] } };
    };
    return GComposite;
}());
exports.GComposite = GComposite;


});

unwrapExports(GComposite_1);
var GComposite_2 = GComposite_1.GComposite;

var Composite_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * compoiste.
 *
 * @export
 * @class Composite
 * @implements {IComponent}
 */
var Composite = /** @class */ (function (_super) {
    tslib_1.__extends(Composite, _super);
    function Composite(name) {
        return _super.call(this, name) || this;
    }
    Composite.prototype.find = function (express, mode) {
        return _super.prototype.find.call(this, express, mode);
    };
    Composite.prototype.filter = function (express, mode) {
        return _super.prototype.filter.call(this, express, mode);
    };
    Composite.prototype.each = function (express, mode) {
        return _super.prototype.each.call(this, express, mode);
    };
    Composite.prototype.eachChildren = function (express) {
        _super.prototype.eachChildren.call(this, express);
    };
    Composite.getClassAnnations = function () {
        return { "name": "Composite", "params": { "constructor": ["name"], "find": ["express", "mode"], "filter": ["express", "mode"], "each": ["express", "mode"], "eachChildren": ["express"] } };
    };
    return Composite;
}(GComposite_1.GComposite));
exports.Composite = Composite;


});

unwrapExports(Composite_1);
var Composite_2 = Composite_1.Composite;

var components = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(Composite_1, exports);
tslib_1.__exportStar(GComposite_1, exports);
tslib_1.__exportStar(NullComponent_1, exports);


});

unwrapExports(components);

var NullAction = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Null action.
 *
 * @class NullActionClass
 * @extends {NullComponent}
 * @implements {ActionComponent}
 */
var NullActionClass = /** @class */ (function (_super) {
    tslib_1.__extends(NullActionClass, _super);
    function NullActionClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NullActionClass.prototype.insert = function (action, index) {
        return this;
    };
    NullActionClass.prototype.execute = function (container, data, name) {
    };
    NullActionClass.prototype.empty = function () {
        return exports.NullAction;
    };
    NullActionClass.getClassAnnations = function () {
        return { "name": "NullActionClass", "params": { "insert": ["action", "index"], "execute": ["container", "data", "name"], "empty": [] } };
    };
    return NullActionClass;
}(components.NullComponent));
/**
 * Null Action
 */
exports.NullAction = new NullActionClass();


});

unwrapExports(NullAction);
var NullAction_1 = NullAction.NullAction;

var ActionComposite_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * action composite
 *
 * @export
 * @class ActionComposite
 * @extends {GComposite<ActionComponent>}
 * @implements {ActionComponent}
 */
var ActionComposite = /** @class */ (function (_super) {
    tslib_1.__extends(ActionComposite, _super);
    function ActionComposite(name) {
        var _this = _super.call(this, name) || this;
        _this.children = [];
        return _this;
    }
    ActionComposite.prototype.insert = function (node, index) {
        node.parent = this;
        if (index < 0) {
            index = 0;
        }
        else if (index >= this.children.length) {
            index = this.children.length - 1;
        }
        this.children.splice(index, 0, node);
        return this;
    };
    ActionComposite.prototype.execute = function (container, data, name) {
        if (name) {
            this.find(function (it) { return it.name === name; })
                .execute(container, data);
        }
        else {
            this.trans(function (action) {
                if (action instanceof ActionComposite) {
                    action.working(container, data);
                }
            });
        }
    };
    ActionComposite.prototype.empty = function () {
        return NullAction.NullAction;
    };
    ActionComposite.prototype.working = function (container, data) {
        // do nothing.
    };
    ActionComposite.getClassAnnations = function () {
        return { "name": "ActionComposite", "params": { "constructor": ["name"], "insert": ["node", "index"], "execute": ["container", "data", "name"], "empty": [], "working": ["container", "data"] } };
    };
    return ActionComposite;
}(components.GComposite));
exports.ActionComposite = ActionComposite;


});

unwrapExports(ActionComposite_1);
var ActionComposite_2 = ActionComposite_1.ActionComposite;

var LifeState_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * life state.
 *
 * @export
 * @enum {number}
 */
var LifeState;
(function (LifeState) {
    /**
     * before create constructor Args
     */
    LifeState["beforeCreateArgs"] = "beforeCreateArgs";
    /**
     * before constructor advice action.
     */
    LifeState["beforeConstructor"] = "beforeConstructor";
    /**
     * after constructor advice action.
     */
    LifeState["afterConstructor"] = "afterConstructor";
    /**
     * on init.
     */
    LifeState["onInit"] = "onInit";
    /**
     * after init.
     */
    LifeState["AfterInit"] = "AfterInit";
})(LifeState = exports.LifeState || (exports.LifeState = {}));


});

unwrapExports(LifeState_1);
var LifeState_2 = LifeState_1.LifeState;

var CoreActions_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * cores decorator actions
 *
 * @export
 */
var CoreActions;
(function (CoreActions) {
    /**
     * the action bind parameter type form metadata.
     */
    CoreActions["bindParameterType"] = "bindParameterType";
    /**
     * the action bind Property type from metadata.
     */
    CoreActions["bindPropertyType"] = "bindPropertyType";
    /**
     * inject property action.
     */
    CoreActions["injectProperty"] = "injectProperty";
    /**
     * class provider bind action.
     */
    CoreActions["bindProvider"] = "bindProvider";
    /**
     * bind parameter provider action.
     */
    CoreActions["bindParameterProviders"] = "bindParameterProviders";
    /**
     * cache action.
     */
    CoreActions["cache"] = "cache";
    /**
     * component init action.  after constructor befor property inject.
     */
    CoreActions["componentBeforeInit"] = "componentBeforeInit";
    /**
     * component on init hooks. after property inject.
     */
    CoreActions["componentInit"] = "componentInit";
    /**
     * component after init hooks. after component init.
     */
    CoreActions["componentAfterInit"] = "componentAfterInit";
    /**
     * singleton action.
     */
    CoreActions["singletion"] = "singletion";
    /**
     * autorun action.
     */
    CoreActions["autorun"] = "autorun";
    /**
     * method autorun action.
     */
    CoreActions["methodAutorun"] = "methodAutorun";
})(CoreActions = exports.CoreActions || (exports.CoreActions = {}));


});

unwrapExports(CoreActions_1);
var CoreActions_2 = CoreActions_1.CoreActions;

var ArgsIterator_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * args iterator.s
 *
 * @export
 * @class ArgsIterator
 */
var ArgsIterator = /** @class */ (function () {
    function ArgsIterator(args) {
        this.args = args;
        this.idx = -1;
        this.metadata = null;
    }
    ArgsIterator.prototype.isCompeted = function () {
        return this.idx >= this.args.length;
    };
    ArgsIterator.prototype.end = function () {
        this.idx = this.args.length;
    };
    ArgsIterator.prototype.next = function (express) {
        this.idx++;
        if (this.isCompeted()) {
            return null;
        }
        var arg = this.args[this.idx];
        if (express.isMetadata && express.isMetadata(arg)) {
            this.metadata = utils.lang.assign(this.metadata || {}, arg);
            this.end();
        }
        else if (express.match(arg)) {
            this.metadata = this.metadata || {};
            express.setMetadata(this.metadata, arg);
        }
        else if (utils.isMetadataObject(arg)) { // when match failed then check is base metadata.
            this.metadata = utils.lang.assign(this.metadata || {}, arg);
            this.end();
        }
        else {
            this.end();
        }
    };
    ArgsIterator.prototype.getArgs = function () {
        return this.args;
    };
    ArgsIterator.prototype.getMetadata = function () {
        return this.metadata;
    };
    ArgsIterator.getClassAnnations = function () {
        return { "name": "ArgsIterator", "params": { "constructor": ["args"], "isCompeted": [], "end": [], "next": ["express"], "getArgs": [], "getMetadata": [] } };
    };
    return ArgsIterator;
}());
exports.ArgsIterator = ArgsIterator;


});

unwrapExports(ArgsIterator_1);
var ArgsIterator_2 = ArgsIterator_1.ArgsIterator;

var DecoratorType_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * decorator type category.
 *
 * @export
 * @enum {number}
 */
var DecoratorType;
(function (DecoratorType) {
    /**
     * Class decorator
     */
    DecoratorType[DecoratorType["Class"] = 1] = "Class";
    /**
     * Parameter decorator
     */
    DecoratorType[DecoratorType["Parameter"] = 2] = "Parameter";
    /**
     * Property decorator
     */
    DecoratorType[DecoratorType["Property"] = 4] = "Property";
    /**
     * Method decorator
     */
    DecoratorType[DecoratorType["Method"] = 8] = "Method";
    /**
     * decorator for any where.
     */
    DecoratorType[DecoratorType["All"] = 15] = "All";
})(DecoratorType = exports.DecoratorType || (exports.DecoratorType = {}));


});

unwrapExports(DecoratorType_1);
var DecoratorType_2 = DecoratorType_1.DecoratorType;

var DecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




exports.ParamerterName = 'paramerter_names';
/**
 * create dectorator for class params props methods.
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {*}
 */
function createDecorator(name, adapter, metadataExtends) {
    var metaName = "@" + name;
    var factory = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var metadata = null;
        if (args.length < 1) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return storeMetadata(name, metaName, args, metadata, metadataExtends);
            };
        }
        metadata = argsToMetadata(args, adapter);
        if (metadata) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return storeMetadata(name, metaName, args, metadata, metadataExtends);
            };
        }
        else {
            if (args.length === 1) {
                if (!utils.isClass(args[0])) {
                    return function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return storeMetadata(name, metaName, args, metadata, metadataExtends);
                    };
                }
            }
        }
        return storeMetadata(name, metaName, args, metadata, metadataExtends);
    };
    factory.toString = function () { return metaName; };
    factory.decoratorType = DecoratorType_1.DecoratorType.All;
    return factory;
}
exports.createDecorator = createDecorator;
function argsToMetadata(args, adapter) {
    var metadata = null;
    if (args.length) {
        if (adapter) {
            var iterator = new ArgsIterator_1.ArgsIterator(args);
            adapter(iterator);
            metadata = iterator.getMetadata();
        }
        else if (args.length === 1 && utils.isMetadataObject(args[0])) {
            metadata = args[0];
        }
    }
    return metadata;
}
function storeMetadata(name, metaName, args, metadata, metadataExtends) {
    var target;
    switch (args.length) {
        case 1:
            target = args[0];
            if (utils.isClass(target) || utils.isAbstractClass(target)) {
                setTypeMetadata(name, metaName, target, metadata, metadataExtends);
                return target;
            }
            break;
        case 2:
            target = args[0];
            var propertyKey = args[1];
            setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);
            break;
        case 3:
            if (utils.isNumber(args[2])) {
                target = args[0];
                var propertyKey_1 = args[1];
                var parameterIndex = args[2];
                setParamMetadata(name, metaName, target, propertyKey_1, parameterIndex, metadata, metadataExtends);
            }
            else if (utils.isUndefined(args[2])) {
                target = args[0];
                var propertyKey_2 = args[1];
                setPropertyMetadata(name, metaName, target, propertyKey_2, metadata, metadataExtends);
            }
            else {
                target = args[0];
                var propertyKey_3 = args[1];
                var descriptor = args[2];
                setMethodMetadata(name, metaName, target, propertyKey_3, descriptor, metadata, metadataExtends);
                return descriptor;
            }
            break;
        default:
            throw new Error("Invalid @" + name + " Decorator declaration.");
    }
}
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getClassDecorators(target) {
    return Reflect.getOwnMetadataKeys(target)
        .filter(function (d) {
        if (!(d && utils.isString(d))) {
            return false;
        }
        if (!/^@/.test(d)) {
            return false;
        }
        return !/__\w+$/.test(d);
    });
}
exports.getClassDecorators = getClassDecorators;
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getMethodDecorators(target) {
    return Reflect.getMetadataKeys(target)
        .filter(function (d) { return d && utils.isString(d) && /^@\S+__method$/.test(d); })
        .map(function (d) { return d.replace(/__method$/ig, ''); });
}
exports.getMethodDecorators = getMethodDecorators;
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getPropDecorators(target) {
    return Reflect.getMetadataKeys(target)
        .filter(function (d) { return d && utils.isString(d) && /^@\S+__props$/.test(d); })
        .map(function (d) { return d.replace(/__props$/ig, ''); });
}
exports.getPropDecorators = getPropDecorators;
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getParamDecorators(target, propertyKey) {
    return ((propertyKey && propertyKey !== 'constructor') ? Reflect.getMetadataKeys(target, propertyKey) : Reflect.getOwnMetadataKeys(utils.lang.getClass(target)) || [])
        .filter(function (d) { return d && utils.isString(d) && /^@\S+__params$/.test(d); })
        .map(function (d) { return d.replace(/__params$/ig, ''); });
}
exports.getParamDecorators = getParamDecorators;
/**
 * get all class metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns
 */
function getTypeMetadata(decorator, target) {
    var annotations = Reflect.getOwnMetadata(utils.isFunction(decorator) ? decorator.toString() : decorator, target);
    annotations = utils.isArray(annotations) ? annotations : [];
    return annotations;
}
exports.getTypeMetadata = getTypeMetadata;
/**
 * get own class metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns
 */
function getOwnTypeMetadata(decorator, target) {
    var annotations = Reflect.getOwnMetadata(utils.isFunction(decorator) ? decorator.toString() : decorator, target);
    annotations = utils.isArray(annotations) ? annotations : [];
    return annotations;
}
exports.getOwnTypeMetadata = getOwnTypeMetadata;
/**
 * has class decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @returns {boolean}
 */
function hasClassMetadata(decorator, target) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasMetadata(name, target);
}
exports.hasClassMetadata = hasClassMetadata;
/**
 * has own class decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @returns {boolean}
 */
function hasOwnClassMetadata(decorator, target) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasOwnMetadata(name, target);
}
exports.hasOwnClassMetadata = hasOwnClassMetadata;
function setTypeMetadata(name, metaName, target, metadata, metadataExtends) {
    var annotations = getOwnTypeMetadata(metaName, target).slice(0);
    var typeMetadata = (metadata || {});
    if (!typeMetadata.type) {
        typeMetadata.type = target;
    }
    typeMetadata.decorator = name;
    if (metadataExtends) {
        metadataExtends(typeMetadata);
    }
    annotations.unshift(typeMetadata);
    setParamerterNames(target);
    Reflect.defineMetadata(metaName, annotations, target);
}
var methodMetadataExt = '__method';
/**
 * get all method metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getMethodMetadata(decorator, target) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    var meta = Reflect.getMetadata(name + methodMetadataExt, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getMetadata(name + methodMetadataExt, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getMethodMetadata = getMethodMetadata;
/**
 * get own method metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getOwnMethodMetadata(decorator, target) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    var meta = Reflect.getOwnMetadata(name + methodMetadataExt, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getOwnMetadata(name + methodMetadataExt, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getOwnMethodMetadata = getOwnMethodMetadata;
/**
 * has own method decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
function hasOwnMethodMetadata(decorator, target, propertyKey) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    if (propertyKey) {
        var meta = getOwnMethodMetadata(name, target);
        return meta && meta.hasOwnProperty(propertyKey);
    }
    else {
        return Reflect.hasOwnMetadata(name + methodMetadataExt, target);
    }
}
exports.hasOwnMethodMetadata = hasOwnMethodMetadata;
/**
 * has method decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
function hasMethodMetadata(decorator, target, propertyKey) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    if (propertyKey) {
        var meta = getMethodMetadata(name, target);
        return meta && meta.hasOwnProperty(propertyKey);
    }
    else {
        return Reflect.hasMetadata(name + methodMetadataExt, target);
    }
}
exports.hasMethodMetadata = hasMethodMetadata;
function setMethodMetadata(name, metaName, target, propertyKey, descriptor, metadata, metadataExtends) {
    var meta = utils.lang.assign({}, getOwnMethodMetadata(metaName, target));
    meta[propertyKey] = meta[propertyKey] || [];
    var methodMeadata = (metadata || {});
    methodMeadata.decorator = name;
    methodMeadata.propertyKey = propertyKey;
    // methodMeadata.descriptor = descriptor;
    if (metadataExtends) {
        metadataExtends(methodMeadata);
    }
    meta[propertyKey].unshift(methodMeadata);
    Reflect.defineMetadata(metaName + methodMetadataExt, meta, target.constructor);
}
var propertyMetadataExt = '__props';
/**
 * get all property metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getPropertyMetadata(decorator, target) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    var meta = Reflect.getMetadata(name + propertyMetadataExt, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getMetadata(name + propertyMetadataExt, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getPropertyMetadata = getPropertyMetadata;
/**
 * get own property metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getOwnPropertyMetadata(decorator, target) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    var meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getOwnPropertyMetadata = getOwnPropertyMetadata;
/**
 * has property decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
function hasPropertyMetadata(decorator, target, propertyKey) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    if (propertyKey) {
        var meta = getPropertyMetadata(name, target);
        return meta && meta.hasOwnProperty(propertyKey);
    }
    else {
        return Reflect.hasMetadata(name + propertyMetadataExt, target);
    }
}
exports.hasPropertyMetadata = hasPropertyMetadata;
function setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends) {
    var meta = utils.lang.assign({}, getOwnPropertyMetadata(metaName, target));
    var propmetadata = (metadata || {});
    propmetadata.propertyKey = propertyKey;
    propmetadata.decorator = name;
    if (!propmetadata.type) {
        var t = Reflect.getMetadata('design:type', target, propertyKey);
        if (!t) {
            // Needed to support react native inheritance
            t = Reflect.getMetadata('design:type', target.constructor, propertyKey);
        }
        propmetadata.type = t;
    }
    if (metadataExtends) {
        metadataExtends(propmetadata);
    }
    if (!meta[propertyKey] || !utils.isArray(meta[propertyKey])) {
        meta[propertyKey] = [];
    }
    meta[propertyKey].unshift(propmetadata);
    Reflect.defineMetadata(metaName + propertyMetadataExt, meta, target.constructor);
}
var paramsMetadataExt = '__params';
/**
 * get paramerter metadata of one specail decorator in target method.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {T[][]}
 */
function getParamMetadata(decorator, target, propertyKey) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    var parameters = Reflect.getMetadata(name + paramsMetadataExt, target, propertyKey);
    parameters = utils.isArray(parameters) ? parameters : [];
    return parameters;
}
exports.getParamMetadata = getParamMetadata;
/**
 * get own paramerter metadata of one specail decorator in target method.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {T[][]}
 */
function getOwnParamMetadata(decorator, target, propertyKey) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    var parameters = Reflect.getOwnMetadata(name + paramsMetadataExt, target, propertyKey);
    parameters = utils.isArray(parameters) ? parameters : [];
    return parameters;
}
exports.getOwnParamMetadata = getOwnParamMetadata;
/**
 * has param decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {boolean}
 */
function hasParamMetadata(decorator, target, propertyKey) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasMetadata(name + paramsMetadataExt, target, propertyKey);
}
exports.hasParamMetadata = hasParamMetadata;
/**
 * has param decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {boolean}
 */
function hasOwnParamMetadata(decorator, target, propertyKey) {
    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasOwnMetadata(name + paramsMetadataExt, target, propertyKey);
}
exports.hasOwnParamMetadata = hasOwnParamMetadata;
function setParamMetadata(name, metaName, target, propertyKey, parameterIndex, metadata, metadataExtends) {
    var parameters = getOwnParamMetadata(metaName, target, propertyKey).slice(0);
    // there might be gaps if some in between parameters do not have annotations.
    // we pad with nulls.
    while (parameters.length <= parameterIndex) {
        parameters.push(null);
    }
    parameters[parameterIndex] = parameters[parameterIndex] || [];
    var paramMeadata = (metadata || {});
    if (!paramMeadata.type) {
        var t = Reflect.getOwnMetadata('design:type', target, propertyKey);
        if (!t) {
            // Needed to support react native inheritance
            t = Reflect.getOwnMetadata('design:type', target.constructor, propertyKey);
        }
        paramMeadata.type = t;
    }
    paramMeadata.propertyKey = propertyKey;
    paramMeadata.decorator = name;
    paramMeadata.index = parameterIndex;
    if (metadataExtends) {
        metadataExtends(paramMeadata);
    }
    parameters[parameterIndex].unshift(paramMeadata);
    Reflect.defineMetadata(metaName + paramsMetadataExt, parameters, target, propertyKey);
}
function getParamerterNames(target) {
    var meta = Reflect.getMetadata(exports.ParamerterName, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getMetadata(exports.ParamerterName, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getParamerterNames = getParamerterNames;
function getOwnParamerterNames(target) {
    var meta = Reflect.getOwnMetadata(exports.ParamerterName, target);
    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {
        meta = Reflect.getOwnMetadata(exports.ParamerterName, target.constructor);
    }
    return utils.isArray(meta) ? {} : (meta || {});
}
exports.getOwnParamerterNames = getOwnParamerterNames;
function setParamerterNames(target) {
    var meta = utils.lang.assign({}, getParamerterNames(target));
    var descriptors = Object.getOwnPropertyDescriptors(target.prototype);
    var isUglify = /^[a-z]/.test(target.name);
    var anName = '';
    var classAnnations = utils.lang.getClassAnnations(target);
    if (classAnnations && classAnnations.params) {
        anName = classAnnations.name;
        meta = utils.lang.assign(meta, classAnnations.params);
    }
    if (!isUglify && target.name !== anName) {
        utils.lang.forIn(descriptors, function (item, name) {
            if (name !== 'constructor') {
                if (item.value) {
                    meta[name] = getParamNames(item.value);
                }
                if (item.set) {
                    meta[name] = getParamNames(item.set);
                }
            }
        });
        meta['constructor'] = getParamNames(target.prototype.constructor);
    }
    Reflect.defineMetadata(exports.ParamerterName, meta, target);
}
exports.setParamerterNames = setParamerterNames;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
function getParamNames(func) {
    if (!utils.isFunction(func)) {
        return [];
    }
    var fnStr = func.toString().replace(STRIP_COMMENTS, '');
    var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
    if (result === null) {
        result = [];
    }
    return result;
}


});

unwrapExports(DecoratorFactory);
var DecoratorFactory_1 = DecoratorFactory.ParamerterName;
var DecoratorFactory_2 = DecoratorFactory.createDecorator;
var DecoratorFactory_3 = DecoratorFactory.getClassDecorators;
var DecoratorFactory_4 = DecoratorFactory.getMethodDecorators;
var DecoratorFactory_5 = DecoratorFactory.getPropDecorators;
var DecoratorFactory_6 = DecoratorFactory.getParamDecorators;
var DecoratorFactory_7 = DecoratorFactory.getTypeMetadata;
var DecoratorFactory_8 = DecoratorFactory.getOwnTypeMetadata;
var DecoratorFactory_9 = DecoratorFactory.hasClassMetadata;
var DecoratorFactory_10 = DecoratorFactory.hasOwnClassMetadata;
var DecoratorFactory_11 = DecoratorFactory.getMethodMetadata;
var DecoratorFactory_12 = DecoratorFactory.getOwnMethodMetadata;
var DecoratorFactory_13 = DecoratorFactory.hasOwnMethodMetadata;
var DecoratorFactory_14 = DecoratorFactory.hasMethodMetadata;
var DecoratorFactory_15 = DecoratorFactory.getPropertyMetadata;
var DecoratorFactory_16 = DecoratorFactory.getOwnPropertyMetadata;
var DecoratorFactory_17 = DecoratorFactory.hasPropertyMetadata;
var DecoratorFactory_18 = DecoratorFactory.getParamMetadata;
var DecoratorFactory_19 = DecoratorFactory.getOwnParamMetadata;
var DecoratorFactory_20 = DecoratorFactory.hasParamMetadata;
var DecoratorFactory_21 = DecoratorFactory.hasOwnParamMetadata;
var DecoratorFactory_22 = DecoratorFactory.getParamerterNames;
var DecoratorFactory_23 = DecoratorFactory.getOwnParamerterNames;
var DecoratorFactory_24 = DecoratorFactory.setParamerterNames;

var ClassDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * create class decorator
 *
 * @export
 * @template T metadata type.
 * @param {string} name decorator name.
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {*}
 */
function createClassDecorator(name, adapter, metadataExtends) {
    var classAdapter = (function (args) {
        if (adapter) {
            adapter(args);
        }
        args.next({
            match: function (arg) { return arg && (utils.isSymbol(arg) || utils.isString(arg) || (utils.isObject(arg) && arg instanceof Registration_1.Registration)); },
            setMetadata: function (metadata, arg) {
                metadata.provide = arg;
            }
        });
        args.next({
            match: function (arg) { return utils.isString(arg); },
            setMetadata: function (metadata, arg) {
                metadata.alias = arg;
            }
        });
        args.next({
            match: function (arg) { return utils.isBoolean(arg) || utils.isNumber(arg) || utils.isToken(arg); },
            setMetadata: function (metadata, arg) {
                if (utils.isBoolean(arg)) {
                    metadata.singleton = arg;
                }
                else if (utils.isNumber(arg)) {
                    metadata.expires = arg;
                }
                else if (utils.isToken(arg)) {
                    metadata.refs = { target: arg, provide: metadata.provide || metadata.type, alias: metadata.alias };
                }
            }
        });
        args.next({
            match: function (arg) { return utils.isToken(arg); },
            setMetadata: function (metadata, arg) {
                metadata.expires = arg;
            }
        });
    });
    var decorator = DecoratorFactory.createDecorator(name, classAdapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Class;
    return decorator;
}
exports.createClassDecorator = createClassDecorator;


});

unwrapExports(ClassDecoratorFactory);
var ClassDecoratorFactory_1 = ClassDecoratorFactory.createClassDecorator;

var MethodDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * create method decorator.
 *
 * @export
 * @template T metadata type.
 * @param {string} name decorator name.
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns
 */
function createMethodDecorator(name, adapter, metadataExtends) {
    var methodAdapter = function (args) {
        if (adapter) {
            adapter(args);
        }
        args.next({
            match: function (arg) { return utils.isArray(arg); },
            setMetadata: function (metadata, arg) {
                metadata.providers = arg;
            }
        });
    };
    var decorator = DecoratorFactory.createDecorator(name, methodAdapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Method;
    return decorator;
}
exports.createMethodDecorator = createMethodDecorator;


});

unwrapExports(MethodDecoratorFactory);
var MethodDecoratorFactory_1 = MethodDecoratorFactory.createMethodDecorator;

var ParamDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * create parameter decorator.
 *
 * @export
 * @template T metadata type.
 * @param {string} name decorator name.
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns
 */
function createParamDecorator(name, adapter, metadataExtends) {
    var paramAdapter = (function (args) {
        if (adapter) {
            adapter(args);
        }
        args.next({
            isMetadata: function (arg) { return utils.isProvideMetadata(arg, 'index'); },
            match: function (arg) { return utils.isToken(arg); },
            setMetadata: function (metadata, arg) {
                metadata.provider = arg;
            }
        });
        // args.next<T>({
        //     match: (arg) => isString(arg),
        //     setMetadata: (metadata, arg) => {
        //         metadata.alias = arg;
        //     }
        // });
    });
    var decorator = DecoratorFactory.createDecorator(name, paramAdapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Parameter;
    return decorator;
}
exports.createParamDecorator = createParamDecorator;


});

unwrapExports(ParamDecoratorFactory);
var ParamDecoratorFactory_1 = ParamDecoratorFactory.createParamDecorator;

var PropertyDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * create property decorator.
 *
 * @export
 * @template T metadata type.
 * @param {string} name decorator name.
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns
 */
function createPropDecorator(name, adapter, metadataExtends) {
    var propPropAdapter = (function (args) {
        if (adapter) {
            adapter(args);
        }
        args.next({
            isMetadata: function (arg) { return utils.isProvideMetadata(arg); },
            match: function (arg) { return utils.isToken(arg); },
            setMetadata: function (metadata, arg) {
                metadata.provider = arg;
            }
        });
    });
    var decorator = DecoratorFactory.createDecorator(name, propPropAdapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Property;
    return decorator;
}
exports.createPropDecorator = createPropDecorator;


});

unwrapExports(PropertyDecoratorFactory);
var PropertyDecoratorFactory_1 = PropertyDecoratorFactory.createPropDecorator;

var ParamPropDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * create parameter or property decorator
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {IParamPropDecorator<T>}
 */
function createParamPropDecorator(name, adapter, metadataExtends) {
    var paramPropAdapter = (function (args) {
        if (adapter) {
            adapter(args);
        }
        args.next({
            isMetadata: function (arg) { return utils.isProvideMetadata(arg, 'index'); },
            match: function (arg) { return utils.isToken(arg); },
            setMetadata: function (metadata, arg) {
                metadata.provider = arg;
            }
        });
        // args.next<T>({
        //     match: (arg) => isString(arg),
        //     setMetadata: (metadata, arg) => {
        //         metadata.alias = arg;
        //     }
        // });
    });
    var decorator = DecoratorFactory.createDecorator(name, paramPropAdapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Property | DecoratorType_1.DecoratorType.Parameter;
    return decorator;
}
exports.createParamPropDecorator = createParamPropDecorator;


});

unwrapExports(ParamPropDecoratorFactory);
var ParamPropDecoratorFactory_1 = ParamPropDecoratorFactory.createParamPropDecorator;

var ClassMethodDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * create decorator for class and method.
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {IClassMethodDecorator<T>}
 */
function createClassMethodDecorator(name, adapter, metadataExtends) {
    var decorator = DecoratorFactory.createDecorator(name, adapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Class | DecoratorType_1.DecoratorType.Method;
    return decorator;
}
exports.createClassMethodDecorator = createClassMethodDecorator;


});

unwrapExports(ClassMethodDecoratorFactory);
var ClassMethodDecoratorFactory_1 = ClassMethodDecoratorFactory.createClassMethodDecorator;

var MethodPropDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * create method or property decorator
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {IMethodPropDecorator<T>}
 */
function createMethodPropDecorator(name, adapter, metadataExtends) {
    var decorator = DecoratorFactory.createDecorator(name, adapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Method | DecoratorType_1.DecoratorType.Property;
    return decorator;
}
exports.createMethodPropDecorator = createMethodPropDecorator;


});

unwrapExports(MethodPropDecoratorFactory);
var MethodPropDecoratorFactory_1 = MethodPropDecoratorFactory.createMethodPropDecorator;

var MethodPropParamDecoratorFactory = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * create method, property or parameter decorator.
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {IMethodPropParamDecorator<T>}
 */
function createMethodPropParamDecorator(name, adapter, metadataExtends) {
    var decorator = DecoratorFactory.createDecorator(name, adapter, metadataExtends);
    decorator.decoratorType = DecoratorType_1.DecoratorType.Method | DecoratorType_1.DecoratorType.Property | DecoratorType_1.DecoratorType.Parameter;
    return decorator;
}
exports.createMethodPropParamDecorator = createMethodPropParamDecorator;


});

unwrapExports(MethodPropParamDecoratorFactory);
var MethodPropParamDecoratorFactory_1 = MethodPropParamDecoratorFactory.createMethodPropParamDecorator;

var factories = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(ArgsIterator_1, exports);
tslib_1.__exportStar(DecoratorType_1, exports);
tslib_1.__exportStar(DecoratorFactory, exports);
tslib_1.__exportStar(ClassDecoratorFactory, exports);
tslib_1.__exportStar(MethodDecoratorFactory, exports);
tslib_1.__exportStar(ParamDecoratorFactory, exports);
tslib_1.__exportStar(PropertyDecoratorFactory, exports);
tslib_1.__exportStar(ParamPropDecoratorFactory, exports);
tslib_1.__exportStar(ClassMethodDecoratorFactory, exports);
tslib_1.__exportStar(MethodPropDecoratorFactory, exports);
tslib_1.__exportStar(MethodPropParamDecoratorFactory, exports);


});

unwrapExports(factories);

var InjectReference_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * Reference registration.
 *
 * @export
 * @class RefRegistration
 * @extends {Registration<T>}
 * @template T
 */
var RefRegistration = /** @class */ (function (_super) {
    tslib_1.__extends(RefRegistration, _super);
    function RefRegistration(provideType, desc) {
        var _this = _super.call(this, provideType, desc) || this;
        _this.type = 'Ref';
        return _this;
    }
    RefRegistration.getClassAnnations = function () {
        return { "name": "RefRegistration", "params": { "constructor": ["provideType", "desc"] } };
    };
    return RefRegistration;
}(Registration_1.Registration));
exports.RefRegistration = RefRegistration;
/**
 * inject reference.
 *
 * @export
 * @class InjectReference
 * @extends {Registration<T>}
 * @template T
 */
var InjectReference = /** @class */ (function (_super) {
    tslib_1.__extends(InjectReference, _super);
    function InjectReference(provideType, target) {
        var _this = _super.call(this, provideType, '') || this;
        _this.target = target;
        return _this;
    }
    InjectReference.prototype.init = function (provideType) {
        this.classType = this.format(provideType);
    };
    /**
     * to string.
     *
     * @returns {string}
     * @memberof Registration
     */
    InjectReference.prototype.toString = function () {
        var key = _super.prototype.toString.call(this);
        var target = this.format(this.target);
        return "Ref " + key + " for " + target;
    };
    InjectReference.getClassAnnations = function () {
        return { "name": "InjectReference", "params": { "constructor": ["provideType", "target"], "init": ["provideType"], "toString": [] } };
    };
    return InjectReference;
}(Registration_1.Registration));
exports.InjectReference = InjectReference;
/**
 * is inject reference token or not.
 *
 * @export
 * @template T
 * @param {*} target
 * @returns {target is InjectReference<T>}
 */
function isInjectReference(target) {
    if (!target) {
        return false;
    }
    return target instanceof InjectReference || (utils.isString(target) && /^Ref\s+[\w\{\}]+\sfor/.test(target));
}
exports.isInjectReference = isInjectReference;
/**
 * inject class provides token.
 *
 * @export
 * @class InjectClassProvidesToken
 * @extends {RefRegistration<IClassProvides>}
 */
var InjectClassProvidesToken = /** @class */ (function (_super) {
    tslib_1.__extends(InjectClassProvidesToken, _super);
    function InjectClassProvidesToken(provideType) {
        return _super.call(this, provideType, 'class_provides') || this;
    }
    InjectClassProvidesToken.getClassAnnations = function () {
        return { "name": "InjectClassProvidesToken", "params": { "constructor": ["provideType"] } };
    };
    return InjectClassProvidesToken;
}(RefRegistration));
exports.InjectClassProvidesToken = InjectClassProvidesToken;


});

unwrapExports(InjectReference_1);
var InjectReference_2 = InjectReference_1.RefRegistration;
var InjectReference_3 = InjectReference_1.InjectReference;
var InjectReference_4 = InjectReference_1.isInjectReference;
var InjectReference_5 = InjectReference_1.InjectClassProvidesToken;

var BindProviderAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * bind provider action. for binding a factory to an token.
 *
 * @export
 * @class BindProviderAction
 * @extends {ActionComposite}
 */
var BindProviderAction = /** @class */ (function (_super) {
    tslib_1.__extends(BindProviderAction, _super);
    function BindProviderAction() {
        return _super.call(this, CoreActions_1.CoreActions.bindProvider) || this;
    }
    BindProviderAction.prototype.working = function (container, data) {
        var type = data.targetType;
        var raiseContainer = data.raiseContainer;
        var lifeScope = container.getLifeScope();
        var matchs = lifeScope.getClassDecorators(type, function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.bindProvider); });
        var clpds = new InjectReference_1.InjectClassProvidesToken(type);
        // has binding.
        var classPds = raiseContainer.resolveValue(clpds) || { provides: [clpds.toString()], decors: [] };
        if (classPds.decors.length) {
            matchs = matchs.filter(function (d) { return classPds.decors.indexOf(d.name) < 0; });
        }
        if (matchs.length < 1) {
            data.execResult = classPds.provides;
            return;
        }
        matchs.forEach(function (surm) {
            var metadata = factories.getOwnTypeMetadata(surm.name, type);
            classPds.decors.push(surm.name);
            if (Array.isArray(metadata) && metadata.length > 0) {
                // bind all provider.
                metadata.forEach(function (c) {
                    if (!c) {
                        return;
                    }
                    if (c.provide) {
                        var provide = raiseContainer.getToken(c.provide, c.alias);
                        classPds.provides.push(provide);
                        raiseContainer.bindProvider(provide, c.type);
                    }
                    if (c.refs && c.refs.target) {
                        raiseContainer.bindRefProvider(c.refs.target, c.refs.provide ? c.refs.provide : c.type, c.type, c.refs.provide ? c.refs.alias : '', function (tk) { return classPds.provides.push(tk); });
                    }
                    // class private provider.
                    if (c.providers && c.providers.length) {
                        raiseContainer.bindProviders.apply(raiseContainer, [c.type,
                            function (refKey) { return classPds.provides.push(refKey); }].concat(c.providers));
                    }
                });
            }
        });
        raiseContainer.bindProvider(clpds, classPds);
        data.execResult = classPds.provides;
    };
    BindProviderAction.getClassAnnations = function () {
        return { "name": "BindProviderAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return BindProviderAction;
}(ActionComposite_1.ActionComposite));
exports.BindProviderAction = BindProviderAction;


});

unwrapExports(BindProviderAction_1);
var BindProviderAction_2 = BindProviderAction_1.BindProviderAction;

var BindParameterTypeAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * bind parameter type action.
 *
 * @export
 * @class BindParameterTypeAction
 * @extends {ActionComposite}
 */
var BindParameterTypeAction = /** @class */ (function (_super) {
    tslib_1.__extends(BindParameterTypeAction, _super);
    function BindParameterTypeAction() {
        return _super.call(this, CoreActions_1.CoreActions.bindParameterType) || this;
    }
    BindParameterTypeAction.prototype.working = function (container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        var target = data.target;
        var type = data.targetType;
        var propertyKey = data.propertyKey;
        var lifeScope = container.getLifeScope();
        var designParams;
        if (target && propertyKey) {
            designParams = Reflect.getMetadata('design:paramtypes', target, propertyKey) || [];
        }
        else {
            designParams = Reflect.getMetadata('design:paramtypes', type) || [];
        }
        designParams = designParams.slice(0);
        designParams.forEach(function (dtype) {
            if (lifeScope.isVaildDependence(dtype)) {
                if (!container.has(dtype)) {
                    container.register(dtype);
                }
            }
        });
        var matchs = lifeScope.getParameterDecorators(target || type, propertyKey, function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.bindParameterType); });
        matchs.forEach(function (surm) {
            var parameters = (target || propertyKey !== 'constructor') ? factories.getParamMetadata(surm.name, target, propertyKey) : factories.getOwnParamMetadata(surm.name, type);
            if (utils.isArray(parameters) && parameters.length) {
                parameters.forEach(function (params) {
                    var parm = (utils.isArray(params) && params.length > 0) ? params[0] : null;
                    if (parm && parm.index >= 0) {
                        if (lifeScope.isVaildDependence(parm.provider)) {
                            if (!container.has(parm.provider, parm.alias)) {
                                container.register(container.getToken(parm.provider, parm.alias));
                            }
                        }
                        if (lifeScope.isVaildDependence(parm.type)) {
                            if (!container.has(parm.type)) {
                                container.register(parm.type);
                            }
                        }
                        var token = parm.provider ? container.getTokenKey(parm.provider, parm.alias) : parm.type;
                        if (token) {
                            designParams[parm.index] = token;
                        }
                    }
                });
            }
        });
        data.execResult = designParams;
    };
    BindParameterTypeAction.getClassAnnations = function () {
        return { "name": "BindParameterTypeAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return BindParameterTypeAction;
}(ActionComposite_1.ActionComposite));
exports.BindParameterTypeAction = BindParameterTypeAction;


});

unwrapExports(BindParameterTypeAction_1);
var BindParameterTypeAction_2 = BindParameterTypeAction_1.BindParameterTypeAction;

var BindPropertyTypeAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * bind property type action. to get the property autowride token of Type calss.
 *
 * @export
 * @class SetPropAction
 * @extends {ActionComposite}
 */
var BindPropertyTypeAction = /** @class */ (function (_super) {
    tslib_1.__extends(BindPropertyTypeAction, _super);
    function BindPropertyTypeAction() {
        return _super.call(this, CoreActions_1.CoreActions.bindPropertyType) || this;
    }
    BindPropertyTypeAction.prototype.working = function (container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        var type = data.targetType;
        var lifeScope = container.getLifeScope();
        var matchs = lifeScope.getPropertyDecorators(type, function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.bindPropertyType); });
        var list = [];
        matchs.forEach(function (surm) {
            var propMetadata = factories.getPropertyMetadata(surm.name, type);
            for (var n in propMetadata) {
                list = list.concat(propMetadata[n]);
            }
            list = list.filter(function (n) { return !!n; });
            list.forEach(function (prop) {
                if (lifeScope.isVaildDependence(prop.provider)) {
                    if (!container.has(prop.provider, prop.alias)) {
                        container.register(container.getToken(prop.provider, prop.alias));
                    }
                }
                if (lifeScope.isVaildDependence(prop.type)) {
                    if (!container.has(prop.type)) {
                        container.register(prop.type);
                    }
                }
            });
        });
        data.execResult = list;
    };
    BindPropertyTypeAction.getClassAnnations = function () {
        return { "name": "BindPropertyTypeAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return BindPropertyTypeAction;
}(ActionComposite_1.ActionComposite));
exports.BindPropertyTypeAction = BindPropertyTypeAction;


});

unwrapExports(BindPropertyTypeAction_1);
var BindPropertyTypeAction_2 = BindPropertyTypeAction_1.BindPropertyTypeAction;

var Provider_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 *  provider, to dynamic resovle instance of params in run time.
 *
 * @export
 * @class Provider
 */
var Provider = /** @class */ (function () {
    function Provider(type, value) {
        this.type = type;
        this.value = value;
    }
    /**
     * resolve provider value.
     *
     * @template T
     * @param {IContainer} container
     * @param {ProviderTypes[]} providers
     * @returns {T}
     * @memberof Provider
     */
    Provider.prototype.resolve = function (container) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        if (utils.isUndefined(this.value)) {
            return container.has(this.type) ? container.resolve.apply(container, [this.type].concat(providers)) : null;
        }
        else {
            return this.value;
        }
    };
    /**
     * create provider.
     *
     * @static
     * @param {Token<any>} type
     * @param {(any)} value
     * @returns Provider
     * @memberof Provider
     */
    Provider.create = function (type, value) {
        return new Provider(type, value);
    };
    /**
     * create extends provider.
     *
     * @static
     * @param {Token<any>} token
     * @param {(any)} value
     * @param {Express2<any, ExtendsProvider, void>} [extendsTarget]
     * @returns {ExtendsProvider}
     * @memberof Provider
     */
    Provider.createExtends = function (token, value, extendsTarget) {
        return new ExtendsProvider(token, value, extendsTarget);
    };
    /**
     * create invoked provider.
     *
     * @static
     * @param {Token<any>} token
     * @param {string} method
     * @param {(any)} [value]
     * @returns {InvokeProvider}
     * @memberof Provider
     */
    Provider.createInvoke = function (token, method, value) {
        return new InvokeProvider(token, method, value);
    };
    /**
     * create param provider.
     *
     * @static
     * @param {Token<any>} token
     * @param {(any)} value
     * @param {number} [index]
     * @param {string} [method]
     * @returns {ParamProvider}
     * @memberof Provider
     */
    Provider.createParam = function (token, value, index, method) {
        return new ParamProvider(token, value, index, method);
    };
    Provider.getClassAnnations = function () {
        return { "name": "Provider", "params": { "constructor": ["type", "value"], "resolve": ["container", "providers"], "create": ["type", "value"], "createExtends": ["token", "value", "extendsTarget"], "createInvoke": ["token", "method", "value"], "createParam": ["token", "value", "index", "method"] } };
    };
    return Provider;
}());
exports.Provider = Provider;
/**
 * InvokeProvider
 *
 * @export
 * @class InvokeProvider
 * @extends {Provider}
 */
var InvokeProvider = /** @class */ (function (_super) {
    tslib_1.__extends(InvokeProvider, _super);
    function InvokeProvider(type, method, value) {
        var _this = _super.call(this, type, value) || this;
        _this.method = method;
        return _this;
    }
    InvokeProvider.prototype.resolve = function (container) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        if (this.method) {
            return container.syncInvoke.apply(container, [this.type, this.method].concat(providers));
        }
        return _super.prototype.resolve.apply(this, [container].concat(providers));
    };
    InvokeProvider.getClassAnnations = function () {
        return { "name": "InvokeProvider", "params": { "constructor": ["type", "method", "value"], "resolve": ["container", "providers"] } };
    };
    return InvokeProvider;
}(Provider));
exports.InvokeProvider = InvokeProvider;
/**
 * param provider.
 *
 * @export
 * @interface ParamProvider
 */
var ParamProvider = /** @class */ (function (_super) {
    tslib_1.__extends(ParamProvider, _super);
    function ParamProvider(token, value, index, method) {
        var _this = _super.call(this, token, method, value) || this;
        _this.index = index;
        return _this;
    }
    /**
     * resolve param
     *
     * @template T
     * @param {IContainer} container
     * @param {...ProviderTypes[]} providers
     * @returns {T}
     * @memberof ParamProvider
     */
    ParamProvider.prototype.resolve = function (container) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        return _super.prototype.resolve.apply(this, [container].concat(providers));
    };
    ParamProvider.getClassAnnations = function () {
        return { "name": "ParamProvider", "params": { "constructor": ["token", "value", "index", "method"], "resolve": ["container", "providers"] } };
    };
    return ParamProvider;
}(InvokeProvider));
exports.ParamProvider = ParamProvider;
/**
 * Provider enable exntends target with provider in dynamic.
 *
 * @export
 * @class ExtendsProvider
 * @extends {Provider}
 */
var ExtendsProvider = /** @class */ (function (_super) {
    tslib_1.__extends(ExtendsProvider, _super);
    function ExtendsProvider(token, value, extendsTarget) {
        var _this = _super.call(this, token, value) || this;
        _this.extendsTarget = extendsTarget;
        return _this;
    }
    ExtendsProvider.prototype.resolve = function (container) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        return _super.prototype.resolve.apply(this, [container].concat(providers));
    };
    ExtendsProvider.prototype.extends = function (target) {
        if (utils.isObject(target) && utils.isFunction(this.extendsTarget)) {
            this.extendsTarget(target, this);
        }
    };
    ExtendsProvider.getClassAnnations = function () {
        return { "name": "ExtendsProvider", "params": { "constructor": ["token", "value", "extendsTarget"], "resolve": ["container", "providers"], "extends": ["target"] } };
    };
    return ExtendsProvider;
}(Provider));
exports.ExtendsProvider = ExtendsProvider;


});

unwrapExports(Provider_1);
var Provider_2 = Provider_1.Provider;
var Provider_3 = Provider_1.InvokeProvider;
var Provider_4 = Provider_1.ParamProvider;
var Provider_5 = Provider_1.ExtendsProvider;

var ProviderMap_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




// use core-js in browser.
exports.ProviderMapToken = new InjectToken_1.InjectToken('DI_ProviderMap');
/**
 * Provider Map.
 *
 * note: object map provider can not resolve token.
 *
 * @export
 * @class Providers
 */
var ProviderMap = /** @class */ (function (_super) {
    tslib_1.__extends(ProviderMap, _super);
    function ProviderMap(container) {
        var _this = _super.call(this) || this;
        _this.container = container;
        return _this;
    }
    /**
     * has provide or not.
     *
     * @param {(Token<any> | number)} provide
     * @returns {boolean}
     * @memberof ProviderMap
     */
    ProviderMap.prototype.has = function (provide) {
        return this.map.has(this.getTokenKey(provide));
    };
    ProviderMap.prototype.provides = function () {
        return this.keys().filter(function (k) { return utils.isToken(k); });
    };
    /**
     * get token key.
     *
     * @param {(Token<any> | number)} token
     * @returns {(SymbolType<any> | number)}
     * @memberof ProviderMap
     */
    ProviderMap.prototype.getTokenKey = function (token) {
        if (utils.isToken(token)) {
            return this.container.getTokenKey(token);
        }
        return token;
    };
    /**
     * get token factory.
     *
     * @template T
     * @param {(Token<T> | number)} provide
     * @returns {InstanceFactory<T>}
     * @memberof ProviderMap
     */
    ProviderMap.prototype.get = function (provide) {
        return this.map.get(this.getTokenKey(provide));
    };
    ProviderMap.prototype.getTokenImpl = function (token, resway) {
        return this.container.getTokenImpl(token, resway);
    };
    ProviderMap.prototype.unregister = function (token, resway) {
        var key = this.getTokenKey(token);
        if (this.map.has(key)) {
            this.map.delete(key);
        }
        return this;
    };
    /**
     * add and bind token provider.
     *
     * @template T
     * @param {(Token<T> | number)} provide
     * @param {(Token<T> | Factory<T>)} provider
     * @returns {this}
     * @memberof ProviderMap
     */
    ProviderMap.prototype.add = function (provide, provider) {
        var _this = this;
        var key = this.getTokenKey(provide);
        if (utils.isUndefined(key)) {
            return this;
        }
        var factory;
        if (utils.isToken(provider) && this.container.has(provider)) {
            factory = function () {
                var providers = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    providers[_i] = arguments[_i];
                }
                var _a;
                return (_a = _this.container).resolve.apply(_a, [provider].concat(providers));
            };
        }
        else {
            if (utils.isFunction(provider)) {
                factory = provider;
            }
            else {
                factory = function () {
                    return provider;
                };
            }
        }
        if (factory) {
            this.map.set(key, factory);
        }
        return this;
    };
    /**
     * resolve instance via provide token.
     *
     * @template T
     * @param {Token<T>} provide
     * @param {...ProviderTypes[]} providers
     * @returns {T}
     * @memberof ProviderMap
     */
    ProviderMap.prototype.resolve = function (provide, resway) {
        var providers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers[_i - 2] = arguments[_i];
        }
        var key = this.getTokenKey(provide);
        var way;
        if (utils.isNumber(resway)) {
            way = resway;
        }
        else {
            if (resway) {
                providers.unshift(resway);
            }
            way = IContainer.ResoveWay.current;
        }
        if ((way & IContainer.ResoveWay.current) && this.map.has(key)) {
            var provider = this.map.get(key);
            return utils.isFunction(provider) ? provider.apply(void 0, providers) : null;
        }
        return null;
    };
    ProviderMap.prototype.forEach = function (callbackfn) {
        var _this = this;
        this.map.forEach(function (fac, key) {
            !utils.isNumber(key) && callbackfn(key, fac, _this);
        });
    };
    /**
     * copy provider map.
     *
     * @param {ProviderMap} map
     * @returns
     * @memberof ProviderMap
     */
    ProviderMap.prototype.copy = function (map) {
        var _this = this;
        if (!map) {
            return this;
        }
        this.map.forEach(function (fac, key) {
            _this.map.set(key, fac);
        });
        return this;
    };
    ProviderMap.getClassAnnations = function () {
        return { "name": "ProviderMap", "params": { "constructor": ["container"], "has": ["provide"], "provides": [], "getTokenKey": ["token"], "get": ["provide"], "getTokenImpl": ["token", "resway"], "unregister": ["token", "resway"], "add": ["provide", "provider"], "resolve": ["provide", "resway", "providers"], "forEach": ["callbackfn"], "copy": ["map"] } };
    };
    return ProviderMap;
}(utils.MapBase));
exports.ProviderMap = ProviderMap;
/**
 * object is provider map or not.
 *
 * @export
 * @param {object} target
 * @returns {target is ProviderMap}
 */
function isProviderMap(target) {
    if (!utils.isObject(target)) {
        return false;
    }
    return target instanceof ProviderMap;
}
exports.isProviderMap = isProviderMap;


});

unwrapExports(ProviderMap_1);
var ProviderMap_2 = ProviderMap_1.ProviderMapToken;
var ProviderMap_3 = ProviderMap_1.ProviderMap;
var ProviderMap_4 = ProviderMap_1.isProviderMap;

var IProviderParser = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Providers parser token.
 */
exports.ProviderParserToken = new InjectToken_1.InjectToken('DI_IProviderParser');


});

unwrapExports(IProviderParser);
var IProviderParser_1 = IProviderParser.ProviderParserToken;

var ProviderParser_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * provider matcher. use to find custome providers in resolve.
 *
 * note: object map provider can not resolve token.
 *
 * @export
 * @class ProviderMatcher
 * @implements {IProviderMatcher}
 */
var ProviderParser = /** @class */ (function () {
    function ProviderParser(container) {
        this.container = container;
    }
    ProviderParser.prototype.parse = function () {
        var _this = this;
        var providers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            providers[_i] = arguments[_i];
        }
        if (providers.length === 1 && ProviderMap_1.isProviderMap(providers[0])) {
            return providers[0];
        }
        var map = this.container.resolve(ProviderMap_1.ProviderMapToken);
        providers.forEach(function (p, index) {
            if (utils.isUndefined(p) || utils.isNull(p)) {
                return;
            }
            if (ProviderMap_1.isProviderMap(p)) {
                map.copy(p);
            }
            else if (p instanceof Provider_1.Provider) {
                if (p instanceof Provider_1.ParamProvider) {
                    if (!p.type && utils.isNumber(p.index)) {
                        map.add(p.index, function () {
                            var providers = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                providers[_i] = arguments[_i];
                            }
                            return p.resolve.apply(p, [_this.container].concat(providers));
                        });
                    }
                    else {
                        map.add(p.type, function () {
                            var providers = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                providers[_i] = arguments[_i];
                            }
                            return p.resolve.apply(p, [_this.container].concat(providers));
                        });
                    }
                }
                else {
                    map.add(p.type, function () {
                        var providers = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            providers[_i] = arguments[_i];
                        }
                        return p.resolve.apply(p, [_this.container].concat(providers));
                    });
                }
            }
            else if (utils.isClass(p)) {
                if (!_this.container.has(p)) {
                    _this.container.register(p);
                }
                map.add(p, p);
            }
            else if (utils.isBaseObject(p)) {
                var pr_1 = p;
                var isobjMap = false;
                if (utils.isToken(pr_1.provide)) {
                    if (utils.isArray(pr_1.deps) && pr_1.deps.length) {
                        pr_1.deps.forEach(function (d) {
                            if (utils.isClass(d) && !_this.container.has(d)) {
                                _this.container.register(d);
                            }
                        });
                    }
                    if (!utils.isUndefined(pr_1.useValue)) {
                        map.add(pr_1.provide, function () { return pr_1.useValue; });
                    }
                    else if (utils.isClass(pr_1.useClass)) {
                        if (!_this.container.has(pr_1.useClass)) {
                            _this.container.register(pr_1.useClass);
                        }
                        map.add(pr_1.provide, pr_1.useClass);
                    }
                    else if (utils.isFunction(pr_1.useFactory)) {
                        map.add(pr_1.provide, function () {
                            var providers = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                providers[_i] = arguments[_i];
                            }
                            var args = [];
                            if (utils.isArray(pr_1.deps) && pr_1.deps.length) {
                                args = pr_1.deps.map(function (d) {
                                    var _a;
                                    if (utils.isToken(d)) {
                                        return (_a = _this.container).resolve.apply(_a, [d].concat(providers));
                                    }
                                    else {
                                        return d;
                                    }
                                });
                            }
                            return pr_1.useFactory.apply(pr_1, args);
                        });
                    }
                    else if (utils.isToken(pr_1.useExisting)) {
                        map.add(pr_1.provide, function () {
                            var providers = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                providers[_i] = arguments[_i];
                            }
                            var _a;
                            return (_a = _this.container).resolve.apply(_a, [pr_1.useExisting].concat(providers));
                        });
                    }
                    else {
                        isobjMap = true;
                    }
                }
                else {
                    isobjMap = true;
                }
                if (isobjMap) {
                    utils.lang.forIn(p, function (val, name) {
                        if (name && utils.isString(name)) {
                            // object map can not resolve token. set all fileld as value factory.
                            map.add(name, function () { return val; });
                        }
                    });
                }
            }
            else if (utils.isFunction(p)) {
                map.add(name, function () { return p; });
            }
        });
        return map;
    };
    ProviderParser.getClassAnnations = function () {
        return { "name": "ProviderParser", "params": { "constructor": ["container"], "parse": ["providers"] } };
    };
    return ProviderParser;
}());
exports.ProviderParser = ProviderParser;
function isProvider(target) {
    return ProviderMap_1.isProviderMap(target) || utils.isBaseObject(target) || target instanceof Provider_1.Provider;
}
exports.isProvider = isProvider;


});

unwrapExports(ProviderParser_1);
var ProviderParser_2 = ProviderParser_1.ProviderParser;
var ProviderParser_3 = ProviderParser_1.isProvider;

var providers = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(Provider_1, exports);
tslib_1.__exportStar(ProviderMap_1, exports);
tslib_1.__exportStar(IProviderParser, exports);
tslib_1.__exportStar(ProviderParser_1, exports);


});

unwrapExports(providers);

var InjectPropertyAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });






/**
 * inject property value action, to inject property value for resolve instance.
 *
 * @export
 * @class SetPropAction
 * @extends {ActionComposite}
 */
var InjectPropertyAction = /** @class */ (function (_super) {
    tslib_1.__extends(InjectPropertyAction, _super);
    function InjectPropertyAction() {
        return _super.call(this, CoreActions_1.CoreActions.injectProperty) || this;
    }
    InjectPropertyAction.prototype.working = function (container, data) {
        if (!data.execResult) {
            this.parent.find(function (act) { return act.name === CoreActions_1.CoreActions.bindPropertyType; }).execute(container, data);
        }
        if (data.target && data.execResult && data.execResult.length) {
            var providerMap_1 = data.providerMap;
            data.injecteds = data.injecteds || {};
            data.execResult.forEach(function (prop, idx) {
                if (prop && !data.injecteds[prop.propertyKey]) {
                    var token = prop.provider ? container.getToken(prop.provider, prop.alias) : prop.type;
                    var pdrMap = container.get(new InjectReference_1.InjectReference(providers.ProviderMap, data.targetType));
                    if (token === IContainer.ContainerToken) {
                        Object.defineProperty(data.target, prop.propertyKey, { enumerable: false, writable: true });
                    }
                    if (pdrMap && pdrMap.has(token)) {
                        data.target[prop.propertyKey] = pdrMap.resolve(token, providerMap_1);
                        data.injecteds[prop.propertyKey] = true;
                    }
                    else if (providerMap_1 && providerMap_1.has(token)) {
                        data.target[prop.propertyKey] = providerMap_1.resolve(token, providerMap_1);
                        data.injecteds[prop.propertyKey] = true;
                    }
                    else if (container.has(token)) {
                        data.target[prop.propertyKey] = container.resolve(token, providerMap_1);
                        data.injecteds[prop.propertyKey] = true;
                    }
                }
            });
        }
    };
    InjectPropertyAction.getClassAnnations = function () {
        return { "name": "InjectPropertyAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return InjectPropertyAction;
}(ActionComposite_1.ActionComposite));
exports.InjectPropertyAction = InjectPropertyAction;


});

unwrapExports(InjectPropertyAction_1);
var InjectPropertyAction_2 = InjectPropertyAction_1.InjectPropertyAction;

var BindParameterProviderAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * bind parameters action.
 *
 * @export
 * @class BindParameterProviderAction
 * @extends {ActionComposite}
 */
var BindParameterProviderAction = /** @class */ (function (_super) {
    tslib_1.__extends(BindParameterProviderAction, _super);
    function BindParameterProviderAction() {
        return _super.call(this, CoreActions_1.CoreActions.bindParameterProviders) || this;
    }
    BindParameterProviderAction.prototype.working = function (container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        var type = data.targetType;
        var propertyKey = data.propertyKey;
        var lifeScope = container.getLifeScope();
        var matchs = lifeScope.getMethodDecorators(type, function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.bindParameterProviders) && factories.hasOwnMethodMetadata(surm.name, type); });
        var providers = [];
        matchs.forEach(function (surm) {
            var methodmtas = factories.getOwnMethodMetadata(surm.name, type);
            var metadatas = methodmtas[propertyKey];
            if (metadatas && utils.isArray(metadatas) && metadatas.length > 0) {
                metadatas.forEach(function (meta) {
                    if (meta.providers && meta.providers.length > 0) {
                        providers = providers.concat(meta.providers);
                    }
                });
            }
        });
        data.execResult = providers;
    };
    BindParameterProviderAction.getClassAnnations = function () {
        return { "name": "BindParameterProviderAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return BindParameterProviderAction;
}(ActionComposite_1.ActionComposite));
exports.BindParameterProviderAction = BindParameterProviderAction;


});

unwrapExports(BindParameterProviderAction_1);
var BindParameterProviderAction_2 = BindParameterProviderAction_1.BindParameterProviderAction;

var ComponentBeforeInitAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * component before init action, to run @Component decorator class before init hooks.
 *
 * @export
 * @class ComponentBeforeInitAction
 * @extends {ActionComposite}
 */
var ComponentBeforeInitAction = /** @class */ (function (_super) {
    tslib_1.__extends(ComponentBeforeInitAction, _super);
    function ComponentBeforeInitAction() {
        return _super.call(this, CoreActions_1.CoreActions.componentBeforeInit) || this;
    }
    ComponentBeforeInitAction.prototype.working = function (container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.targetType && data.target) {
            if (container.getLifeScope().hasDecorator(data.targetType, factories.DecoratorType.Class, function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.componentBeforeInit); })) {
                var component = data.target;
                if (utils.isFunction(component.beforeInit)) {
                    container.syncInvoke(data.target || data.targetType, 'beforeInit', data.target);
                }
            }
        }
    };
    ComponentBeforeInitAction.getClassAnnations = function () {
        return { "name": "ComponentBeforeInitAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return ComponentBeforeInitAction;
}(ActionComposite_1.ActionComposite));
exports.ComponentBeforeInitAction = ComponentBeforeInitAction;


});

unwrapExports(ComponentBeforeInitAction_1);
var ComponentBeforeInitAction_2 = ComponentBeforeInitAction_1.ComponentBeforeInitAction;

var ComponentInitAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * component before init action, to run @Component decorator class before init hooks.
 *
 * @export
 * @class ComponentInitAction
 * @extends {ActionComposite}
 */
var ComponentInitAction = /** @class */ (function (_super) {
    tslib_1.__extends(ComponentInitAction, _super);
    function ComponentInitAction() {
        return _super.call(this, CoreActions_1.CoreActions.componentInit) || this;
    }
    ComponentInitAction.prototype.working = function (container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.targetType && data.target) {
            if (container.getLifeScope().hasDecorator(data.targetType, factories.DecoratorType.Class, function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.componentInit); })) {
                var component = data.target;
                if (utils.isFunction(component.onInit)) {
                    container.syncInvoke(data.target || data.targetType, 'onInit', data.target);
                }
            }
        }
    };
    ComponentInitAction.getClassAnnations = function () {
        return { "name": "ComponentInitAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return ComponentInitAction;
}(ActionComposite_1.ActionComposite));
exports.ComponentInitAction = ComponentInitAction;


});

unwrapExports(ComponentInitAction_1);
var ComponentInitAction_2 = ComponentInitAction_1.ComponentInitAction;

var ComponentAfterInitAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * component after init action, to run @Component decorator class after init hooks.
 *
 * @export
 * @class ComponentAfterInitAction
 * @extends {ActionComposite}
 */
var ComponentAfterInitAction = /** @class */ (function (_super) {
    tslib_1.__extends(ComponentAfterInitAction, _super);
    function ComponentAfterInitAction() {
        return _super.call(this, CoreActions_1.CoreActions.componentAfterInit) || this;
    }
    ComponentAfterInitAction.prototype.working = function (container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.targetType && data.target) {
            if (container.getLifeScope().hasDecorator(data.targetType, factories.DecoratorType.Class, function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.componentAfterInit); })) {
                var component = data.target;
                if (utils.isFunction(component.afterInit)) {
                    container.syncInvoke(data.target || data.targetType, 'afterInit', data.target);
                }
            }
        }
    };
    ComponentAfterInitAction.getClassAnnations = function () {
        return { "name": "ComponentAfterInitAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return ComponentAfterInitAction;
}(ActionComposite_1.ActionComposite));
exports.ComponentAfterInitAction = ComponentAfterInitAction;


});

unwrapExports(ComponentAfterInitAction_1);
var ComponentAfterInitAction_2 = ComponentAfterInitAction_1.ComponentAfterInitAction;

var ICacheManager = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * ICacheManager interface token.
 * it is a token id, you can register yourself ICacheManager for this.
 */
exports.CacheManagerToken = new InjectToken_1.InjectToken('DI_ICacheManager');


});

unwrapExports(ICacheManager);
var ICacheManager_1 = ICacheManager.CacheManagerToken;

var CacheAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });






/**
 * cache action. To cache instance of Token. define cache expires in decorator.
 *
 * @export
 * @class CacheAction
 * @extends {ActionComposite}
 */
var CacheAction = /** @class */ (function (_super) {
    tslib_1.__extends(CacheAction, _super);
    function CacheAction() {
        return _super.call(this, CoreActions_1.CoreActions.cache) || this;
    }
    CacheAction.prototype.working = function (container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return data;
        }
        if (data.singleton || !data.targetType || !utils.isClass(data.targetType)) {
            return data;
        }
        var cacheManager = container.get(ICacheManager.CacheManagerToken);
        if (data.target) {
            if (!cacheManager.hasCache(data.targetType)) {
                var cacheMetadata = this.getCacheMetadata(container, data);
                if (cacheMetadata) {
                    cacheManager.cache(data.targetType, data.target, cacheMetadata.expires);
                }
            }
        }
        else {
            var target = cacheManager.get(data.targetType);
            if (target) {
                var cacheMetadata = this.getCacheMetadata(container, data);
                if (cacheMetadata) {
                    cacheManager.cache(data.targetType, target, cacheMetadata.expires);
                    data.execResult = target;
                }
            }
        }
        return data;
    };
    CacheAction.prototype.getCacheMetadata = function (container, data) {
        var lifeScope = container.getLifeScope();
        var matchs = lifeScope.getClassDecorators(data.targetType);
        var cacheMetadata;
        for (var i = 0; i < matchs.length; i++) {
            var surm = matchs[i];
            var metadata = factories.getOwnTypeMetadata(surm.name, data.targetType);
            if (Array.isArray(metadata) && metadata.length > 0) {
                cacheMetadata = metadata.find(function (c) { return c && utils.isNumber(c.expires) && c.expires > 0; });
                if (cacheMetadata) {
                    break;
                }
            }
        }
        return cacheMetadata;
    };
    CacheAction.getClassAnnations = function () {
        return { "name": "CacheAction", "params": { "constructor": [], "working": ["container", "data"], "getCacheMetadata": ["container", "data"] } };
    };
    return CacheAction;
}(ActionComposite_1.ActionComposite));
exports.CacheAction = CacheAction;


});

unwrapExports(CacheAction_1);
var CacheAction_2 = CacheAction_1.CacheAction;

var SingletonAction = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * singleton action, to set the factory of Token as singleton.
 *
 * @export
 * @class SingletionAction
 * @extends {ActionComposite}
 */
var SingletionAction = /** @class */ (function (_super) {
    tslib_1.__extends(SingletionAction, _super);
    function SingletionAction() {
        return _super.call(this, CoreActions_1.CoreActions.singletion) || this;
    }
    SingletionAction.prototype.working = function (container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.tokenKey && data.target && data.singleton) {
            container.registerValue(data.tokenKey, data.target);
        }
    };
    SingletionAction.getClassAnnations = function () {
        return { "name": "SingletionAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return SingletionAction;
}(ActionComposite_1.ActionComposite));
exports.SingletionAction = SingletionAction;


});

unwrapExports(SingletonAction);
var SingletonAction_1 = SingletonAction.SingletionAction;

var AutoRun = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Autorun decorator, for class or method.  use to define the class auto run (via a method or not) after registered.
 *
 * @Autorun
 */
exports.Autorun = factories.createClassMethodDecorator('Autorun', function (args) {
    args.next({
        isMetadata: function (arg) { return utils.isClassMetadata(arg, 'autorun'); },
        match: function (arg) { return utils.isString(arg) || utils.isNumber(arg); },
        setMetadata: function (metadata, arg) {
            if (utils.isString(arg)) {
                metadata.autorun = arg;
            }
            else {
                metadata.order = arg;
            }
        }
    });
}, function (metadata) {
    metadata.singleton = true;
    return metadata;
});


});

unwrapExports(AutoRun);
var AutoRun_1 = AutoRun.Autorun;

var IocExt = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.
 *
 * @IocExt
 */
exports.IocExt = factories.createClassDecorator('IocExt', function (args) {
    args.next({
        isMetadata: function (arg) { return utils.isClassMetadata(arg, 'autorun'); },
        match: function (arg) { return utils.isString(arg); },
        setMetadata: function (metadata, arg) {
            metadata.autorun = arg;
        }
    });
}, function (metadata) {
    metadata.singleton = true;
    return metadata;
});
exports.IocModule = exports.IocExt;


});

unwrapExports(IocExt);
var IocExt_1 = IocExt.IocExt;
var IocExt_2 = IocExt.IocModule;

var AutorunAction_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });







/**
 * Inject DrawType action.
 *
 * @export
 * @class SetPropAction
 * @extends {ActionComposite}
 */
var AutorunAction = /** @class */ (function (_super) {
    tslib_1.__extends(AutorunAction, _super);
    function AutorunAction() {
        return _super.call(this, CoreActions_1.CoreActions.autorun) || this;
    }
    AutorunAction.prototype.getDecorator = function () {
        return [IocExt.IocExt, AutoRun.Autorun];
    };
    AutorunAction.prototype.working = function (container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.tokenKey && data.targetType) {
            var decorators = this.getDecorator();
            decorators.forEach(function (decorator) {
                if (factories.hasClassMetadata(decorator, data.targetType)) {
                    var metas = factories.getTypeMetadata(decorator, data.targetType);
                    var meta = metas.find(function (it) { return !!it.autorun; });
                    if (!meta && metas.length) {
                        meta = metas[0];
                    }
                    if (meta) {
                        var instance = container.get(data.tokenKey);
                        if (instance && meta.autorun && utils.isFunction(instance[meta.autorun])) {
                            container.syncInvoke(instance, meta.autorun);
                        }
                    }
                }
            });
        }
    };
    AutorunAction.getClassAnnations = function () {
        return { "name": "AutorunAction", "params": { "constructor": [], "getDecorator": [], "working": ["container", "data"] } };
    };
    return AutorunAction;
}(ActionComposite_1.ActionComposite));
exports.AutorunAction = AutorunAction;


});

unwrapExports(AutorunAction_1);
var AutorunAction_2 = AutorunAction_1.AutorunAction;

var actions = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(ActionComposite_1, exports);
tslib_1.__exportStar(LifeState_1, exports);
tslib_1.__exportStar(CoreActions_1, exports);
tslib_1.__exportStar(NullAction, exports);
tslib_1.__exportStar(BindProviderAction_1, exports);
tslib_1.__exportStar(BindParameterTypeAction_1, exports);
tslib_1.__exportStar(BindPropertyTypeAction_1, exports);
tslib_1.__exportStar(InjectPropertyAction_1, exports);
tslib_1.__exportStar(BindParameterProviderAction_1, exports);
tslib_1.__exportStar(ComponentBeforeInitAction_1, exports);
tslib_1.__exportStar(ComponentInitAction_1, exports);
tslib_1.__exportStar(ComponentAfterInitAction_1, exports);
tslib_1.__exportStar(CacheAction_1, exports);
tslib_1.__exportStar(SingletonAction, exports);
tslib_1.__exportStar(AutorunAction_1, exports);


});

unwrapExports(actions);

var basic = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * define the property enumerable of not.
 *
 * @export
 * @param {boolean} value
 * @returns
 */
function enumerable(value) {
    return function (target, propertyKey, descriptor) {
        if (descriptor) {
            descriptor.enumerable = value;
        }
        else {
            descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || { writable: true };
            descriptor.enumerable = value;
            Object.defineProperty(target, propertyKey, descriptor);
        }
    };
}
exports.enumerable = enumerable;
function configurable(value) {
    return function (target, propertyKey, descriptor) {
        if (descriptor) {
            descriptor.configurable = value;
        }
        else {
            descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || { writable: true };
            descriptor.configurable = value;
            Object.defineProperty(target, propertyKey, descriptor);
        }
    };
}
exports.configurable = configurable;
/**
 * define class is sealed.
 *
 * @param {Function} constructor
 */
function sealed(constructor) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}
exports.sealed = sealed;


});

unwrapExports(basic);
var basic_1 = basic.enumerable;
var basic_2 = basic.configurable;
var basic_3 = basic.sealed;

var Component = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Component decorator, define for class. use to define the class. it can setting provider to some token, singleton or not. it will execute  [`ComponentLifecycle`]
 *
 * @Component
 */
exports.Component = factories.createClassDecorator('Component');


});

unwrapExports(Component);
var Component_1 = Component.Component;

var Injectable = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Injectable decorator, define for class.  use to define the class. it can setting provider to some token, singleton or not.
 *
 * @Injectable
 */
exports.Injectable = factories.createClassDecorator('Injectable');


});

unwrapExports(Injectable);
var Injectable_1 = Injectable.Injectable;

var Refs = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Refs decorator, for class. use to define the class as service of target.
 *
 * @Refs
 */
exports.Refs = factories.createDecorator('Refs', (function (args) {
    args.next({
        match: function (arg) { return utils.isToken(arg); },
        setMetadata: function (metadata, arg) {
            metadata.refs = { target: arg };
        }
    });
    args.next({
        match: function (arg) { return utils.isToken(arg); },
        setMetadata: function (metadata, arg) {
            metadata.refs.provide = arg;
        }
    });
    args.next({
        match: function (arg) { return utils.isString(arg); },
        setMetadata: function (metadata, arg) {
            metadata.refs.alias = arg;
        }
    });
}));


});

unwrapExports(Refs);
var Refs_1 = Refs.Refs;

var Providers = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Providers decorator, for class. use to add ref service to the class.
 *
 * @Providers
 */
exports.Providers = factories.createDecorator('Providers', (function (args) {
    args.next({
        match: function (arg) { return utils.isArray(arg); },
        setMetadata: function (metadata, arg) {
            metadata.providers = arg;
        }
    });
}));


});

unwrapExports(Providers);
var Providers_1 = Providers.Providers;

var Inject = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Inject decorator, for property or param, use to auto wried type instance or value to the instance of one class with the decorator.
 *
 * @Inject
 */
exports.Inject = factories.createParamPropDecorator('Inject');


});

unwrapExports(Inject);
var Inject_1 = Inject.Inject;

var AutoWried = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * AutoWired decorator, for property or param. use to auto wried type instance or value to the instance of one class with the decorator.
 *
 * @AutoWired
 */
exports.AutoWired = factories.createParamPropDecorator('AutoWired');


});

unwrapExports(AutoWried);
var AutoWried_1 = AutoWried.AutoWired;

var Param = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * param decorator, define for parameter. use to auto wried type instance or value to the instance of one class with the decorator.
 *
 * @Param
 */
exports.Param = factories.createParamDecorator('Param');


});

unwrapExports(Param);
var Param_1 = Param.Param;

var Method = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * method decorator.
 *
 * @Method
 */
exports.Method = factories.createMethodDecorator('Method');


});

unwrapExports(Method);
var Method_1 = Method.Method;

var Singleton = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Singleton decorator, for class. use to define the class is singleton.
 *
 * @Singleton
 */
exports.Singleton = factories.createClassDecorator('Singleton', null, function (metadata) {
    metadata.singleton = true;
    return metadata;
});


});

unwrapExports(Singleton);
var Singleton_1 = Singleton.Singleton;

var Abstract = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Abstract decorator. define for class.
 *
 * @Abstract
 */
exports.Abstract = factories.createClassDecorator('Abstract');


});

unwrapExports(Abstract);
var Abstract_1 = Abstract.Abstract;

var decorators = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(basic, exports);
tslib_1.__exportStar(Component, exports);
tslib_1.__exportStar(Injectable, exports);
tslib_1.__exportStar(Refs, exports);
tslib_1.__exportStar(Providers, exports);
tslib_1.__exportStar(Inject, exports);
tslib_1.__exportStar(AutoWried, exports);
tslib_1.__exportStar(Param, exports);
tslib_1.__exportStar(Method, exports);
tslib_1.__exportStar(Singleton, exports);
tslib_1.__exportStar(Abstract, exports);
tslib_1.__exportStar(AutoRun, exports);
tslib_1.__exportStar(IocExt, exports);


});

unwrapExports(decorators);

var IRecognizer = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * IRecognizer interface token.
 * it is a token id, you can register yourself IRecognizer for this.
 */
exports.RecognizerToken = new InjectToken_1.InjectToken('DI_IRecognizer');


});

unwrapExports(IRecognizer);
var IRecognizer_1 = IRecognizer.RecognizerToken;

var MethodAutorun_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });






/**
 * Inject DrawType action.
 *
 * @export
 * @class SetPropAction
 * @extends {ActionComposite}
 */
var MethodAutorun = /** @class */ (function (_super) {
    tslib_1.__extends(MethodAutorun, _super);
    function MethodAutorun() {
        return _super.call(this, CoreActions_1.CoreActions.methodAutorun) || this;
    }
    MethodAutorun.prototype.working = function (container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.target && data.targetType) {
            if (factories.hasMethodMetadata(decorators.Autorun, data.targetType)) {
                var metas = factories.getMethodMetadata(decorators.Autorun, data.targetType);
                var lastmetas_1 = [];
                var idx_1 = utils.lang.keys(metas).length;
                utils.lang.forIn(metas, function (mm, key) {
                    if (mm && mm.length) {
                        var m = mm[0];
                        m.autorun = key;
                        idx_1++;
                        if (!utils.isNumber(m.order)) {
                            m.order = idx_1;
                        }
                        lastmetas_1.push(m);
                    }
                });
                lastmetas_1.sort(function (au1, au2) {
                    return au1.order - au1.order;
                }).forEach(function (aut) {
                    container.syncInvoke(data.target || data.targetType, aut.autorun, data.target);
                });
            }
        }
    };
    MethodAutorun.getClassAnnations = function () {
        return { "name": "MethodAutorun", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return MethodAutorun;
}(ActionComposite_1.ActionComposite));
exports.MethodAutorun = MethodAutorun;


});

unwrapExports(MethodAutorun_1);
var MethodAutorun_2 = MethodAutorun_1.MethodAutorun;

var ActionFactory_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * action factory.
 *
 * @export
 * @class ActionFactory
 */
var ActionFactory = /** @class */ (function () {
    function ActionFactory() {
    }
    /**
     * create action by action type. type in 'CoreActions'
     *
     * @param {string} type
     * @returns {ActionComponent}
     * @memberof ActionFactory
     */
    ActionFactory.prototype.create = function (type) {
        var action;
        switch (type) {
            case actions.CoreActions.bindParameterType:
                action = new actions.BindParameterTypeAction();
                break;
            case actions.CoreActions.bindPropertyType:
                action = new actions.BindPropertyTypeAction();
                break;
            case actions.CoreActions.injectProperty:
                action = new actions.InjectPropertyAction();
                break;
            case actions.CoreActions.bindProvider:
                action = new actions.BindProviderAction();
                break;
            case actions.CoreActions.bindParameterProviders:
                action = new actions.BindParameterProviderAction();
                break;
            case actions.CoreActions.componentInit:
                action = new actions.ComponentInitAction();
                break;
            case actions.CoreActions.componentBeforeInit:
                action = new actions.ComponentBeforeInitAction();
                break;
            case actions.CoreActions.componentAfterInit:
                action = new actions.ComponentAfterInitAction();
                break;
            case actions.CoreActions.cache:
                action = new actions.CacheAction();
                break;
            case actions.CoreActions.singletion:
                action = new actions.SingletionAction();
                break;
            case actions.CoreActions.autorun:
                action = new actions.AutorunAction();
                break;
            case actions.CoreActions.methodAutorun:
                action = new MethodAutorun_1.MethodAutorun();
                break;
            default:
                action = new actions.ActionComposite(type);
                break;
        }
        return action;
    };
    ActionFactory.getClassAnnations = function () {
        return { "name": "ActionFactory", "params": { "create": ["type"] } };
    };
    return ActionFactory;
}());
exports.ActionFactory = ActionFactory;


});

unwrapExports(ActionFactory_1);
var ActionFactory_2 = ActionFactory_1.ActionFactory;

var IMetaAccessor = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * application service token.
 *
 * @export
 * @class InjectMetaAccessorToken
 * @extends {Registration<MetaAccessor<T>>}
 * @template T
 */
var InjectMetaAccessorToken = /** @class */ (function (_super) {
    tslib_1.__extends(InjectMetaAccessorToken, _super);
    function InjectMetaAccessorToken(type) {
        return _super.call(this, type, 'metaAccessor') || this;
    }
    InjectMetaAccessorToken.getClassAnnations = function () {
        return { "name": "InjectMetaAccessorToken", "params": { "constructor": ["type"] } };
    };
    return InjectMetaAccessorToken;
}(InjectReference_1.RefRegistration));
exports.InjectMetaAccessorToken = InjectMetaAccessorToken;
/**
 * MetaAccessor token.
 */
exports.MetaAccessorToken = new InjectMetaAccessorToken(Object);


});

unwrapExports(IMetaAccessor);
var IMetaAccessor_1 = IMetaAccessor.InjectMetaAccessorToken;
var IMetaAccessor_2 = IMetaAccessor.MetaAccessorToken;

var DefaultLifeScope_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });







/**
 * default implement life scope.
 *
 * @export
 * @class DefaultLifeScope
 * @implements {LifeScope}
 */
var DefaultLifeScope = /** @class */ (function () {
    function DefaultLifeScope(container) {
        this.container = container;
        this.decorators = [];
        this.buildAction();
    }
    DefaultLifeScope.prototype.addAction = function (action) {
        var nodepaths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            nodepaths[_i - 1] = arguments[_i];
        }
        var parent = this.action;
        nodepaths.forEach(function (pathname) {
            parent = parent.find(function (act) { return act.name === pathname; });
        });
        if (parent) {
            parent.add(action);
        }
        return this;
    };
    DefaultLifeScope.prototype.registerDecorator = function (decorator) {
        var actions$$2 = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            actions$$2[_i - 1] = arguments[_i];
        }
        var type = this.getDecoratorType(decorator);
        return this.registerCustomDecorator.apply(this, [decorator, type].concat(actions$$2));
    };
    DefaultLifeScope.prototype.registerCustomDecorator = function (decorator, type) {
        var actions$$2 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            actions$$2[_i - 2] = arguments[_i];
        }
        var types$$2 = this.toActionName(type);
        var name = decorator.toString();
        if (!this.decorators.some(function (d) { return d.name === name; })) {
            this.decorators.push({
                name: name,
                types: types$$2,
                actions: actions$$2
            });
        }
        return this;
    };
    DefaultLifeScope.prototype.execute = function (data) {
        var names = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            names[_i - 1] = arguments[_i];
        }
        names = names.filter(function (n) { return !!n; });
        var act = this.action;
        names.forEach(function (name) {
            act = act.find(function (itm) { return itm.name === name; });
        });
        if (act) {
            act.execute(this.container, data);
        }
    };
    DefaultLifeScope.prototype.routeExecute = function (data) {
        var names = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            names[_i - 1] = arguments[_i];
        }
        var _a;
        this.execute.apply(this, [data].concat(names));
        var container = this.container.parent;
        while (container) {
            (_a = container.getLifeScope()).execute.apply(_a, [utils.lang.assign({}, data)].concat(names));
            container = container.parent;
        }
    };
    DefaultLifeScope.prototype.hasDecorator = function (target, dtype, match) {
        var _this = this;
        var decors;
        switch (dtype) {
            case factories.DecoratorType.Class:
                decors = factories.getClassDecorators(target);
                break;
            case factories.DecoratorType.Property:
                decors = factories.getPropDecorators(target);
                break;
            case factories.DecoratorType.Parameter:
                decors = factories.getParamDecorators(target);
                break;
            case factories.DecoratorType.Method:
                decors = factories.getMethodDecorators(target);
                break;
        }
        if (decors) {
            return decors.some(function (dec) { return _this.decorators.some(function (d) { return d.name === dec && match(d); }); });
        }
        return false;
    };
    DefaultLifeScope.prototype.getClassDecorators = function (type, match) {
        var _this = this;
        return factories.getClassDecorators(type)
            .map(function (dec) { return _this.decorators.find(function (d) { return d.name === dec; }); })
            .filter(function (d) { return d && (match ? match(d) : true); });
    };
    DefaultLifeScope.prototype.getMethodDecorators = function (type, match) {
        var _this = this;
        return factories.getMethodDecorators(type)
            .map(function (dec) { return _this.decorators.find(function (d) { return d.name === dec; }); })
            .filter(function (d) { return d && (match ? match(d) : true); });
    };
    DefaultLifeScope.prototype.getPropertyDecorators = function (type, match) {
        var _this = this;
        return factories.getPropDecorators(type)
            .map(function (dec) { return _this.decorators.find(function (d) { return d.name === dec; }); })
            .filter(function (d) { return d && (match ? match(d) : true); });
    };
    DefaultLifeScope.prototype.getParameterDecorators = function (target, propertyKey, match) {
        var _this = this;
        return factories.getParamDecorators(target, propertyKey)
            .map(function (dec) { return _this.decorators.find(function (d) { return d.name === dec; }); })
            .filter(function (d) { return d && (match ? match(d) : true); });
    };
    DefaultLifeScope.prototype.getDecoratorType = function (decirator) {
        return decirator.decoratorType || factories.DecoratorType.All;
    };
    /**
     * is vaildate dependence type or not. dependence type must with class decorator.
     *
     * @template T
     * @param {Type<T>} target
     * @returns {boolean}
     * @memberof Container
     */
    DefaultLifeScope.prototype.isVaildDependence = function (target) {
        if (!target) {
            return false;
        }
        if (!utils.isClass(target)) {
            return false;
        }
        if (utils.isAbstractClass(target)) {
            return false;
        }
        return this.getClassDecorators(target).length > 0;
    };
    DefaultLifeScope.prototype.getAtionByName = function (name) {
        return this.action.find(function (action) { return action.name === name; });
    };
    DefaultLifeScope.prototype.getClassAction = function () {
        return this.getAtionByName(this.toActionName(factories.DecoratorType.Class));
    };
    DefaultLifeScope.prototype.getMethodAction = function () {
        return this.getAtionByName(this.toActionName(factories.DecoratorType.Method));
    };
    DefaultLifeScope.prototype.getPropertyAction = function () {
        return this.getAtionByName(this.toActionName(factories.DecoratorType.Property));
    };
    DefaultLifeScope.prototype.getParameterAction = function () {
        return this.getAtionByName(this.toActionName(factories.DecoratorType.Parameter));
    };
    /**
     * get constructor parameters metadata.
     *
     * @template T
     * @param {Type<T>} type
     * @returns {IParameter[]}
     * @memberof IContainer
     */
    DefaultLifeScope.prototype.getConstructorParameters = function (type) {
        return this.getParameters(type);
    };
    /**
     * get method params metadata.
     *
     * @template T
     * @param {Type<T>} type
     * @param {T} instance
     * @param {(string | symbol)} propertyKey
     * @returns {IParameter[]}
     * @memberof IContainer
     */
    DefaultLifeScope.prototype.getMethodParameters = function (type, instance, propertyKey) {
        return this.getParameters(type, instance, propertyKey);
    };
    /**
     * get paramerter names.
     *
     * @template T
     * @param {Type<T>} type
     * @param {string} propertyKey
     * @returns {string[]}
     * @memberof DefaultLifeScope
     */
    DefaultLifeScope.prototype.getParamerterNames = function (type, propertyKey) {
        var metadata = factories.getOwnParamerterNames(type);
        var paramNames = [];
        if (metadata && metadata.hasOwnProperty(propertyKey)) {
            paramNames = metadata[propertyKey];
        }
        if (!utils.isArray(paramNames)) {
            paramNames = [];
        }
        return paramNames;
    };
    DefaultLifeScope.prototype.isSingletonType = function (type) {
        if (factories.hasOwnClassMetadata(Singleton.Singleton, type)) {
            return true;
        }
        var metadata = this.container.get(IMetaAccessor.MetaAccessorToken).find(type, this.container, function (m) { return m.singleton === true; });
        return !!metadata;
    };
    DefaultLifeScope.prototype.getMethodMetadatas = function (type, propertyKey) {
        var metadatas = [];
        this.getMethodDecorators(type)
            .forEach(function (dec) {
            var metas = factories.getOwnMethodMetadata(dec.name, type);
            if (metas.hasOwnProperty(propertyKey)) {
                metadatas = metadatas.concat(metas[propertyKey] || []);
            }
        });
        return metadatas;
    };
    DefaultLifeScope.prototype.filerDecorators = function (express) {
        return this.decorators.filter(express);
    };
    DefaultLifeScope.prototype.getParameters = function (type, instance, propertyKey) {
        propertyKey = propertyKey || 'constructor';
        var data = {
            target: instance,
            targetType: type,
            propertyKey: propertyKey
        };
        this.execute(data, actions.LifeState.onInit, actions.CoreActions.bindParameterType);
        var paramNames = this.getParamerterNames(type, propertyKey);
        if (data.execResult.length) {
            return data.execResult.map(function (typ, idx) {
                return {
                    type: typ,
                    name: paramNames[idx]
                };
            });
        }
        else {
            return paramNames.map(function (name) {
                return {
                    name: name,
                    type: undefined
                };
            });
        }
    };
    DefaultLifeScope.prototype.getTypeDecorators = function (decType, match) {
        return this.filerDecorators(function (value) {
            var flag = (value.types || '').indexOf(decType) >= 0;
            if (flag && match) {
                flag = match(value);
            }
            return flag;
        });
    };
    DefaultLifeScope.prototype.buildAction = function () {
        var factory = new ActionFactory_1.ActionFactory();
        var action = factory.create('');
        action
            .add(factory.create(types.IocState.design)
            .add(factory.create(actions.CoreActions.bindProvider))
            .add(factory.create(actions.CoreActions.autorun)))
            .add(factory.create(types.IocState.runtime)
            .add(factory.create(actions.LifeState.beforeCreateArgs))
            .add(factory.create(actions.LifeState.beforeConstructor))
            .add(factory.create(actions.LifeState.afterConstructor))
            .add(factory.create(actions.LifeState.onInit)
            .add(factory.create(actions.CoreActions.componentBeforeInit))
            .add(factory.create(this.toActionName(factories.DecoratorType.Class)))
            .add(factory.create(this.toActionName(factories.DecoratorType.Method)))
            .add(factory.create(this.toActionName(factories.DecoratorType.Property))
            .add(factory.create(actions.CoreActions.bindPropertyType))
            .add(factory.create(actions.CoreActions.injectProperty)))
            .add(factory.create(this.toActionName(factories.DecoratorType.Parameter))
            .add(factory.create(actions.CoreActions.bindParameterType))
            .add(factory.create(actions.CoreActions.bindParameterProviders)))
            .add(factory.create(actions.CoreActions.componentInit)))
            .add(factory.create(actions.LifeState.AfterInit)
            .add(factory.create(actions.CoreActions.singletion))
            .add(factory.create(actions.CoreActions.componentAfterInit))
            .add(factory.create(actions.CoreActions.methodAutorun))))
            .add(factory.create(actions.CoreActions.cache));
        this.action = action;
    };
    DefaultLifeScope.prototype.toActionName = function (type) {
        var types$$2 = [];
        if (type & factories.DecoratorType.Class) {
            types$$2.push('ClassDecorator');
        }
        if (type & factories.DecoratorType.Method) {
            types$$2.push('MethodDecorator');
        }
        if (type & factories.DecoratorType.Property) {
            types$$2.push('PropertyDecorator');
        }
        if (type & factories.DecoratorType.Parameter) {
            types$$2.push('ParameterDecorator');
        }
        return types$$2.join(',');
    };
    DefaultLifeScope.getClassAnnations = function () {
        return { "name": "DefaultLifeScope", "params": { "constructor": ["container"], "addAction": ["action", "nodepaths"], "registerDecorator": ["decorator", "actions"], "registerCustomDecorator": ["decorator", "type", "actions"], "execute": ["data", "names"], "routeExecute": ["data", "names"], "hasDecorator": ["target", "dtype", "match"], "getClassDecorators": ["type", "match"], "getMethodDecorators": ["type", "match"], "getPropertyDecorators": ["type", "match"], "getParameterDecorators": ["target", "propertyKey", "match"], "getDecoratorType": ["decirator"], "isVaildDependence": ["target"], "getAtionByName": ["name"], "getClassAction": [], "getMethodAction": [], "getPropertyAction": [], "getParameterAction": [], "getConstructorParameters": ["type"], "getMethodParameters": ["type", "instance", "propertyKey"], "getParamerterNames": ["type", "propertyKey"], "isSingletonType": ["type"], "getMethodMetadatas": ["type", "propertyKey"], "filerDecorators": ["express"], "getParameters": ["type", "instance", "propertyKey"], "getTypeDecorators": ["decType", "match"], "buildAction": [], "toActionName": ["type"] } };
    };
    return DefaultLifeScope;
}());
exports.DefaultLifeScope = DefaultLifeScope;


});

unwrapExports(DefaultLifeScope_1);
var DefaultLifeScope_2 = DefaultLifeScope_1.DefaultLifeScope;

var MetaAccessor_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * class metadata accessor.
 *
 * @export
 * @class MetaAccessor
 * @implements {IMetaAccessor<any>}
 */
var MetaAccessor = /** @class */ (function () {
    function MetaAccessor() {
    }
    MetaAccessor.prototype.getDecorators = function (type) {
        return factories.getClassDecorators(type);
    };
    /**
     * get metadata config of target type. via decorators in order.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {IAnnotationMetadata<any>} [extConfig]
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>}
     * @memberof MetaAccessor
     */
    MetaAccessor.prototype.getMetadata = function (token, container, extConfig, decorFilter) {
        var type = utils.isClass(token) ? token : container.getTokenImpl(token);
        var cfg;
        if (utils.isClass(type)) {
            var decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            var classmeta_1 = {};
            decors.forEach(function (decor) {
                var metas = factories.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    metas.forEach(function (meta) {
                        if (meta) {
                            classmeta_1 = utils.lang.assign({}, classmeta_1, meta);
                        }
                    });
                }
            });
            cfg = classmeta_1;
        }
        if (cfg) {
            return utils.lang.assign({}, cfg, extConfig || {});
        }
        else {
            return extConfig || {};
        }
    };
    /**
     * find metadata accessor.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {Express<IAnnotationMetadata<any>, boolean>} filter
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>}
     * @memberof MetaAccessor
     */
    MetaAccessor.prototype.find = function (token, container, filter, decorFilter) {
        var type = utils.isClass(token) ? token : container.getTokenImpl(token);
        var metadata = null;
        if (utils.isClass(type)) {
            var decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            decors.some(function (decor) {
                var metas = factories.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    return metas.some(function (meta) {
                        if (meta && filter(meta)) {
                            metadata = meta;
                        }
                        return !!metadata;
                    });
                }
                return false;
            });
        }
        return metadata;
    };
    /**
     * filter metadata accessor.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {Express<IAnnotationMetadata<any>, boolean>} filter
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>[]}
     * @memberof MetaAccessor
     */
    MetaAccessor.prototype.filter = function (token, container, filter, decorFilter) {
        var type = utils.isClass(token) ? token : container.getTokenImpl(token);
        var metadatas = [];
        if (utils.isClass(type)) {
            var decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            decors.forEach(function (decor) {
                var metas = factories.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    metas.filter(function (meta) { return meta && filter(meta); }).forEach(function (meta) {
                        metadatas.push(meta);
                    });
                }
            });
        }
        return metadatas;
    };
    /**
     * get token of metadata config.
     *
     * @param {IAnnotationMetadata<any>} config
     * @param {IContainer} [container] vaild token in container or not.
     * @returns {Token<any>}
     * @memberof MetadataManager
     */
    MetaAccessor.prototype.getToken = function (config, container) {
        var token = this.getTokenInConfig(config);
        if (this.validateToken(token, container)) {
            return token;
        }
        else {
            return null;
        }
    };
    /**
     * get module boot token from module configure.
     *
     * @param {IAnnotationMetadata<any>} config
     * @param {IContainer} [container]  vaild container.
     * @returns {Token<any>}
     * @memberof ModuelValidate
     */
    MetaAccessor.prototype.getBootToken = function (config, container) {
        var token = this.getBootTokenInConfig(config);
        if (this.validateToken(token, container)) {
            return token;
        }
        else {
            return null;
        }
    };
    MetaAccessor.prototype.validateToken = function (token, container) {
        return utils.isToken(token);
    };
    MetaAccessor.prototype.getTokenInConfig = function (config) {
        return config.token || config.type;
    };
    MetaAccessor.prototype.getBootTokenInConfig = function (config) {
        return config.bootstrap;
    };
    MetaAccessor.getClassAnnations = function () {
        return { "name": "MetaAccessor", "params": { "constructor": [], "getDecorators": ["type"], "getMetadata": ["token", "container", "extConfig", "decorFilter"], "find": ["token", "container", "filter", "decorFilter"], "filter": ["token", "container", "filter", "decorFilter"], "getToken": ["config", "container"], "getBootToken": ["config", "container"], "validateToken": ["token", "container"], "getTokenInConfig": ["config"], "getBootTokenInConfig": ["config"] } };
    };
    return MetaAccessor;
}());
exports.MetaAccessor = MetaAccessor;


});

unwrapExports(MetaAccessor_1);
var MetaAccessor_2 = MetaAccessor_1.MetaAccessor;

var MethodAccessor_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * method accessor
 *
 * @export
 * @class MethodAccessor
 * @implements {IMethodAccessor}
 */
var MethodAccessor = /** @class */ (function () {
    function MethodAccessor(container) {
        this.container = container;
    }
    MethodAccessor.prototype.invoke = function (target, propertyKey, instance) {
        var providers$$2 = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            providers$$2[_i - 3] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, targetClass, actionData, lifeScope, parameters, paramInstances;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (providers.isProvider(instance)) {
                            providers$$2.unshift(instance);
                            instance = undefined;
                        }
                        if (utils.isToken(target)) {
                            if (utils.isNullOrUndefined(instance)) {
                                targetClass = this.container.getTokenImpl(target);
                                instance = (_a = this.container).resolve.apply(_a, [target].concat(providers$$2));
                            }
                            else {
                                targetClass = utils.lang.getClass(instance) || this.container.getTokenImpl(target);
                            }
                            utils.lang.assert(targetClass, target.toString() + ' is not implements by any class.');
                        }
                        else {
                            targetClass = utils.lang.getClass(target);
                            instance = target;
                        }
                        utils.lang.assertExp(instance && utils.isFunction(instance[propertyKey]), "type: " + targetClass + " has no method " + propertyKey.toString() + ".");
                        actionData = {
                            target: instance,
                            targetType: targetClass,
                            propertyKey: propertyKey,
                        };
                        lifeScope = this.container.getLifeScope();
                        lifeScope.execute(actionData, actions.LifeState.onInit, actions.CoreActions.bindParameterProviders);
                        providers$$2 = providers$$2.concat(actionData.execResult);
                        parameters = lifeScope.getMethodParameters(targetClass, instance, propertyKey);
                        return [4 /*yield*/, this.createParams.apply(this, [parameters].concat(providers$$2))];
                    case 1:
                        paramInstances = _b.sent();
                        return [2 /*return*/, instance[propertyKey].apply(instance, paramInstances)];
                }
            });
        });
    };
    MethodAccessor.prototype.syncInvoke = function (target, propertyKey, instance) {
        var providers$$2 = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            providers$$2[_i - 3] = arguments[_i];
        }
        var _a;
        var targetClass;
        if (providers.isProvider(instance)) {
            providers$$2.unshift(instance);
            instance = undefined;
        }
        if (utils.isToken(target)) {
            targetClass = this.container.getTokenImpl(target);
            utils.lang.assert(targetClass, target.toString() + ' is not implements by any class.');
            if (utils.isNullOrUndefined(instance)) {
                instance = (_a = this.container).resolve.apply(_a, [target].concat(providers$$2));
            }
        }
        else {
            targetClass = utils.lang.getClass(target);
            instance = target;
        }
        utils.lang.assertExp(instance && utils.isFunction(instance[propertyKey]), "type: " + targetClass + " has no method " + propertyKey.toString() + ".");
        var actionData = {
            target: instance,
            targetType: targetClass,
            propertyKey: propertyKey,
        };
        var lifeScope = this.container.getLifeScope();
        lifeScope.execute(actionData, actions.LifeState.onInit, actions.CoreActions.bindParameterProviders);
        providers$$2 = providers$$2.concat(actionData.execResult);
        var parameters = lifeScope.getMethodParameters(targetClass, instance, propertyKey);
        var paramInstances = this.createSyncParams.apply(this, [parameters].concat(providers$$2));
        return instance[propertyKey].apply(instance, paramInstances);
    };
    MethodAccessor.prototype.createSyncParams = function (params) {
        var _this = this;
        var providers$$2 = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers$$2[_i - 1] = arguments[_i];
        }
        var _a;
        var providerMap = (_a = this.container.getProviderParser()).parse.apply(_a, providers$$2);
        return params.map(function (param, index) {
            if (param.name && providerMap.has(param.name)) {
                return providerMap.resolve(param.name);
            }
            else if (utils.isToken(param.type)) {
                if (providerMap.has(param.type)) {
                    return providerMap.resolve(param.type);
                }
                return _this.container.resolve(param.type, providerMap);
            }
            else {
                return undefined;
            }
        });
    };
    MethodAccessor.prototype.createParams = function (params) {
        var _this = this;
        var providers$$2 = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers$$2[_i - 1] = arguments[_i];
        }
        var _a;
        var providerMap = (_a = this.container.getProviderParser()).parse.apply(_a, providers$$2);
        return Promise.all(params.map(function (param, index) {
            if (param.name && providerMap.has(param.name)) {
                return providerMap.resolve(param.name);
            }
            else if (utils.isToken(param.type)) {
                if (providerMap.has(param.type)) {
                    return providerMap.resolve(param.type);
                }
                return _this.container.resolve(param.type, providerMap);
            }
            else {
                return undefined;
            }
        }));
    };
    MethodAccessor.getClassAnnations = function () {
        return { "name": "MethodAccessor", "params": { "constructor": ["container"], "invoke": ["target", "propertyKey", "instance", "providers"], "syncInvoke": ["target", "propertyKey", "instance", "providers"], "createSyncParams": ["params", "providers"], "createParams": ["params", "providers"] } };
    };
    return MethodAccessor;
}());
exports.MethodAccessor = MethodAccessor;


});

unwrapExports(MethodAccessor_1);
var MethodAccessor_2 = MethodAccessor_1.MethodAccessor;

var CacheManager_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * cache manager.
 *
 * @export
 * @class CacheManager
 * @implements {ICacheManager}
 */
var CacheManager = /** @class */ (function () {
    function CacheManager(container) {
        this.container = container;
        this.cacheTokens = new Map();
    }
    CacheManager.prototype.isChecking = function () {
        return !!this.timeout;
    };
    CacheManager.prototype.hasCache = function (targetType) {
        return this.cacheTokens.has(targetType);
    };
    CacheManager.prototype.cache = function (targetType, target, expires) {
        var cache;
        if (this.hasCache(targetType)) {
            cache = this.cacheTokens.get(targetType);
            cache.expires = Date.now() + expires;
        }
        else {
            cache = {
                target: target,
                expires: Date.now() + expires
            };
        }
        this.cacheTokens.set(targetType, cache);
        if (!this.isChecking()) {
            this.checkExpires();
        }
    };
    CacheManager.prototype.get = function (targetType, expires) {
        var result = null;
        if (!this.cacheTokens.has(targetType)) {
            return null;
        }
        var cache = this.cacheTokens.get(targetType);
        if (cache.expires <= Date.now()) {
            result = cache.target;
            if (utils.isNumber(expires) && expires > 0) {
                cache.expires = Date.now() + expires;
                this.cacheTokens.set(targetType, cache);
            }
        }
        else {
            this.destroy(targetType, cache.target);
        }
        return result;
    };
    CacheManager.prototype.checkExpires = function () {
        var _this = this;
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = 0;
        }
        if (this.cacheTokens.size > 0) {
            var timeoutCaches_1 = [];
            this.cacheTokens.forEach(function (cache, targetType) {
                if (cache.expires >= Date.now()) {
                    timeoutCaches_1.push(targetType);
                }
            });
            if (timeoutCaches_1.length) {
                timeoutCaches_1.forEach(function (targetType) {
                    _this.destroy(targetType, _this.cacheTokens.get(targetType).target);
                });
            }
            this.timeout = setTimeout(function () {
                _this.checkExpires();
            }, 60000);
        }
    };
    CacheManager.prototype.destroy = function (targetType, target) {
        if (!this.hasCache(targetType)) {
            return;
        }
        if (!target) {
            target = this.cacheTokens.get(targetType).target;
        }
        try {
            var component = target;
            if (utils.isFunction(component.onDestroy)) {
                this.container.syncInvoke(target || targetType, 'onDestroy', target);
            }
            this.cacheTokens.delete(targetType);
        }
        catch (err) {
            console.error && console.error(err);
        }
    };
    CacheManager.getClassAnnations = function () {
        return { "name": "CacheManager", "params": { "constructor": ["container"], "isChecking": [], "hasCache": ["targetType"], "cache": ["targetType", "target", "expires"], "get": ["targetType", "expires"], "checkExpires": [], "destroy": ["targetType", "target"] } };
    };
    return CacheManager;
}());
exports.CacheManager = CacheManager;


});

unwrapExports(CacheManager_1);
var CacheManager_2 = CacheManager_1.CacheManager;

var core = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(actions, exports);
tslib_1.__exportStar(decorators, exports);
tslib_1.__exportStar(factories, exports);
tslib_1.__exportStar(IRecognizer, exports);
tslib_1.__exportStar(ActionFactory_1, exports);
tslib_1.__exportStar(DefaultLifeScope_1, exports);
tslib_1.__exportStar(IMetaAccessor, exports);
tslib_1.__exportStar(MetaAccessor_1, exports);
tslib_1.__exportStar(MethodAccessor_1, exports);
tslib_1.__exportStar(CacheManager_1, exports);


});

unwrapExports(core);

var IContainerBuilder = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * ContainerBuilder interface token.
 * it is a token id, you can register yourself IContainerBuilder for this.
 */
exports.ContainerBuilderToken = new InjectToken_1.InjectToken('DI_IContainerBuilder');


});

unwrapExports(IContainerBuilder);
var IContainerBuilder_1 = IContainerBuilder.ContainerBuilderToken;

var LifeScope = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * life scope interface symbol.
 * it is a symbol id, you can register yourself MethodAccessor for this.
 */
exports.LifeScopeToken = new InjectToken_1.InjectToken('DI_LifeScope');


});

unwrapExports(LifeScope);
var LifeScope_1 = LifeScope.LifeScopeToken;

var ResolverChain_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 *  resolver chain token.
 */
exports.ResolverChainToken = new InjectToken_1.InjectToken('di_ResolverChain');
/**
 * resover chain.
 *
 * resove by setp.
 *
 * @export
 * @class ResolverChain
 * @implements {IResolver}
 */
var ResolverChain = /** @class */ (function () {
    function ResolverChain(container) {
        this.container = container;
        this.resolvers = [];
    }
    Object.defineProperty(ResolverChain.prototype, "size", {
        get: function () {
            return this.resolvers.length + 1;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * reigister next resolver.
     *
     * @param {IResolver} resolver
     * @memberof ResolverChain
     */
    ResolverChain.prototype.next = function (resolver) {
        if (!this.hasResolver(resolver)) {
            this.resolvers.push(resolver);
        }
    };
    /**
     * has resolver or not.
     *
     * @param {IResolver} resolver
     * @returns
     * @memberof ResolverChain
     */
    ResolverChain.prototype.hasResolver = function (resolver) {
        if (resolver === this.container) {
            return true;
        }
        return this.resolvers.indexOf(resolver) >= 0;
    };
    /**
     * resove token via registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof ResolverChain
     */
    ResolverChain.prototype.resolve = function (token, resway) {
        var providers$$2 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers$$2[_i - 2] = arguments[_i];
        }
        var _a;
        var key = this.container.getTokenKey(token, utils.isString(resway) ? resway : null);
        var way;
        if (utils.isNumber(resway)) {
            way = resway;
        }
        else {
            if (resway) {
                providers$$2.unshift(resway);
            }
            way = IContainer.ResoveWay.all;
        }
        var providerMap;
        if (providers$$2.length) {
            if (providers$$2.length === 1 && providers.isProviderMap(providers$$2[0])) {
                providerMap = providers$$2[0];
            }
            else {
                providerMap = (_a = this.container.getProviderParser()).parse.apply(_a, providers$$2);
            }
        }
        if (providerMap && providerMap.has(token)) {
            return providerMap.resolve(token, providerMap);
        }
        if ((way & IContainer.ResoveWay.current) && this.container.hasRegister(key)) {
            return this.container.resolveValue(key, providerMap);
        }
        if ((way & IContainer.ResoveWay.traverse)) {
            var resolver = this.resolvers.find(function (r) { return r.has(key, IContainer.ResoveWay.nodes); });
            if (resolver) {
                return resolver.resolve(key, IContainer.ResoveWay.nodes, providerMap);
            }
        }
        if (this.container.parent && (way & IContainer.ResoveWay.bubble)) {
            return this.container.parent.resolve(key, resway, providerMap);
        }
        return null;
    };
    /**
     * unregister token in registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @memberof ResolverChain
     */
    ResolverChain.prototype.unregister = function (token, resway) {
        resway = resway || IContainer.ResoveWay.all;
        var tokenKey = this.container.getTokenKey(token);
        if (resway & IContainer.ResoveWay.current) {
            this.container.unregisterValue(tokenKey);
        }
        if (resway & IContainer.ResoveWay.traverse) {
            this.resolvers.forEach(function (r) {
                if (utils.isFunction(r.unregister)) {
                    r.unregister(tokenKey, IContainer.ResoveWay.nodes);
                }
            });
        }
        if ((resway & IContainer.ResoveWay.bubble) && this.container.parent) {
            this.container.parent.unregister(token, resway);
        }
        return this;
    };
    /**
     * get token implements class in the registered resolver chain.
     *
     * @template T
     * @param {Token<T>} token
     * @returns {Type<T>}
     * @memberof ResolverChain
     */
    ResolverChain.prototype.getTokenImpl = function (token, resway) {
        if (utils.isClass(token)) {
            return token;
        }
        resway = resway || IContainer.ResoveWay.nodes;
        var tokenKey = this.container.getTokenKey(token);
        var provider;
        if (resway & IContainer.ResoveWay.current) {
            provider = this.container.getTokenProvider(tokenKey);
        }
        if (!provider && (resway & IContainer.ResoveWay.traverse)) {
            this.resolvers.some(function (r) {
                if (!utils.isFunction(r.getTokenImpl)) {
                    return false;
                }
                provider = r.getTokenImpl(tokenKey, IContainer.ResoveWay.nodes);
                return !!provider;
            });
        }
        if (!provider && (resway & IContainer.ResoveWay.bubble) && this.container.parent) {
            provider = this.container.parent.getTokenImpl(token, resway);
        }
        return provider || null;
    };
    /**
     * has token or not in the registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @returns {boolean}
     * @memberof ResolverChain
     */
    ResolverChain.prototype.has = function (token, aliasOrway) {
        var key = this.container.getTokenKey(token, utils.isString(aliasOrway) ? aliasOrway : null);
        var resway = utils.isNumber(aliasOrway) ? aliasOrway : IContainer.ResoveWay.all;
        if ((resway & IContainer.ResoveWay.current) && this.container.hasRegister(key)) {
            return true;
        }
        if ((resway & IContainer.ResoveWay.traverse) && this.resolvers.some(function (r) { return r.has(key, IContainer.ResoveWay.nodes); })) {
            return true;
        }
        if ((resway & IContainer.ResoveWay.bubble) && this.container.parent) {
            return this.container.parent.has(token, resway);
        }
        return false;
    };
    /**
     * resolver chain to array.
     *
     * @returns {IResolver[]}
     * @memberof ResolverChain
     */
    ResolverChain.prototype.toArray = function (resway) {
        if (resway === void 0) { resway = IContainer.ResoveWay.all; }
        if (resway & IContainer.ResoveWay.nodes) {
            return [this.container].concat(this.resolvers);
        }
        else if (resway & IContainer.ResoveWay.current) {
            return [this.container];
        }
        else if (resway & IContainer.ResoveWay.traverse) {
            return this.resolvers;
        }
        return [];
    };
    ResolverChain.prototype.forEach = function (callbackfn) {
        if (this.container.forEach(callbackfn) === false) {
            return false;
        }
        return !this.resolvers.some(function (r) {
            if (utils.isFunction(r.forEach)) {
                return r.forEach(callbackfn) === false;
            }
            return false;
        });
    };
    /**
     * iterator all resolvers.
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void} callbackfn
     * @memberof ResolverChain
     */
    ResolverChain.prototype.iterator = function (callbackfn, resway) {
        if (resway === void 0) { resway = IContainer.ResoveWay.all; }
        if (resway & IContainer.ResoveWay.current) {
            if (this.container.forEach(callbackfn) === false) {
                return false;
            }
        }
        if (resway & IContainer.ResoveWay.traverse) {
            if (this.resolvers.some(function (r) {
                if (utils.isFunction(r.forEach)) {
                    return r.forEach(callbackfn) === false;
                }
                return false;
            })) {
                return false;
            }
        }
        if (this.container.parent && (resway & IContainer.ResoveWay.bubble)) {
            return this.container.parent.iterator(callbackfn, resway);
        }
    };
    ResolverChain.getClassAnnations = function () {
        return { "name": "ResolverChain", "params": { "constructor": ["container"], "next": ["resolver"], "hasResolver": ["resolver"], "resolve": ["token", "resway", "providers"], "unregister": ["token", "resway"], "getTokenImpl": ["token", "resway"], "has": ["token", "aliasOrway"], "toArray": ["resway"], "forEach": ["callbackfn"], "iterator": ["callbackfn", "resway"] } };
    };
    return ResolverChain;
}());
exports.ResolverChain = ResolverChain;


});

unwrapExports(ResolverChain_1);
var ResolverChain_2 = ResolverChain_1.ResolverChainToken;
var ResolverChain_3 = ResolverChain_1.ResolverChain;

var resolves = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(ResolverChain_1, exports);


});

unwrapExports(resolves);

var registerCores_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });






/**
 * register core for container.
 *
 * @export
 * @param {IContainer} container
 */
function registerCores(container) {
    container.registerSingleton(LifeScope.LifeScopeToken, function () { return new core.DefaultLifeScope(container); });
    container.registerSingleton(ICacheManager.CacheManagerToken, function () { return new core.CacheManager(container); });
    container.registerSingleton(resolves.ResolverChainToken, function () { return new resolves.ResolverChain(container); });
    container.register(providers.ProviderMapToken, function () { return new providers.ProviderMap(container); });
    container.bindProvider(providers.ProviderMap, providers.ProviderMapToken);
    container.registerSingleton(providers.ProviderParserToken, function () { return new providers.ProviderParser(container); });
    container.registerSingleton(IMethodAccessor.MethodAccessorToken, function () { return new core.MethodAccessor(container); });
    container.registerSingleton(core.MetaAccessorToken, core.MetaAccessor);
    var lifeScope = container.get(LifeScope.LifeScopeToken);
    lifeScope.registerDecorator(core.Injectable, core.CoreActions.bindProvider, core.CoreActions.cache);
    lifeScope.registerDecorator(core.Component, core.CoreActions.bindProvider, core.CoreActions.cache, core.CoreActions.componentBeforeInit, core.CoreActions.componentInit, core.CoreActions.componentAfterInit);
    lifeScope.registerDecorator(core.Singleton, core.CoreActions.bindProvider);
    lifeScope.registerDecorator(core.Refs, core.CoreActions.bindProvider);
    lifeScope.registerDecorator(core.Providers, core.CoreActions.bindProvider);
    lifeScope.registerDecorator(core.Abstract, core.CoreActions.bindProvider, core.CoreActions.cache);
    lifeScope.registerDecorator(core.AutoWired, core.CoreActions.bindParameterType, core.CoreActions.bindPropertyType);
    lifeScope.registerDecorator(core.Inject, core.CoreActions.bindParameterType, core.CoreActions.bindPropertyType);
    lifeScope.registerDecorator(core.Param, core.CoreActions.bindParameterType, core.CoreActions.bindPropertyType);
    lifeScope.registerDecorator(core.Method, core.CoreActions.bindParameterProviders);
    lifeScope.registerDecorator(core.Autorun, core.CoreActions.autorun, core.CoreActions.methodAutorun);
    lifeScope.registerDecorator(core.IocExt, core.CoreActions.autorun, core.CoreActions.componentBeforeInit, core.CoreActions.componentInit, core.CoreActions.componentAfterInit);
    container.register(Date, function () { return new Date(); });
    container.register(String, function () { return ''; });
    container.register(Number, function () { return Number.NaN; });
    container.register(Boolean, function () { return undefined; });
    container.register(Array, function () { return []; });
}
exports.registerCores = registerCores;


});

unwrapExports(registerCores_1);
var registerCores_2 = registerCores_1.registerCores;

var Container_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });














/**
 * singleton reg token.
 */
var SingletonRegToken = '___IOC__Singleton___';
/**
 * Container
 *
 * @export
 * @class Container
 * @implements {IContainer}
 */
var Container = /** @class */ (function () {
    function Container() {
        // @enumerable(false)
        this.children = [];
        this.init();
    }
    Object.defineProperty(Container.prototype, "size", {
        get: function () {
            return this.factories.size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * get root container.
     *
     * @returns {IContainer}
     * @memberof Container
     */
    Container.prototype.getRoot = function () {
        var root = this;
        while (root.parent) {
            root = root.parent;
        }
        return root;
    };
    Container.prototype.getProviderParser = function () {
        if (!this.parser) {
            this.parser = this.resolveValue(providers.ProviderParserToken);
        }
        return this.parser;
    };
    /**
     * get container builder.
     *
     * @returns {IContainerBuilder}
     * @memberof Container
     */
    Container.prototype.getBuilder = function () {
        return this.resolveValue(IContainerBuilder.ContainerBuilderToken);
    };
    /**
    * resolve token value in this container only.
    *
    * @template T
    * @param {Token<T>} token
    * @param {...ParamProviders[]} providers
    * @returns {T}
    * @memberof Container
    */
    Container.prototype.getResolvers = function () {
        return this.resolveValue(resolves.ResolverChainToken);
    };
    /**
     * has register the token or not.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [aliasOrway]
     * @returns {boolean}
     * @memberof Container
     */
    Container.prototype.has = function (token, aliasOrway) {
        return this.getResolvers().has(token, aliasOrway);
    };
    /**
     * has register type.
     *
     * @template T
     * @param {Token<T>} key
     * @returns
     * @memberof Container
     */
    Container.prototype.hasRegister = function (key) {
        return this.factories.has(this.getTokenKey(key));
    };
    /**
     * Retrieves an instance from the container based on the provided token.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    Container.prototype.get = function (token, alias) {
        var providers$$1 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers$$1[_i - 2] = arguments[_i];
        }
        return this.resolve.apply(this, [alias ? this.getTokenKey(token, alias) : token].concat(providers$$1));
    };
    /**
     * resolve type instance with token and param provider.
     *
     * @template T
     * @param {Token<T>} token
     * @param {T} [notFoundValue]
     * @param {...ParamProviders[]} providers
     * @memberof Container
     */
    Container.prototype.resolve = function (token, resway) {
        var providers$$1 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers$$1[_i - 2] = arguments[_i];
        }
        var _a;
        return (_a = this.getResolvers()).resolve.apply(_a, [token, resway].concat(providers$$1));
    };
    /**
     * resolve first token when not null.
     *
     * @template T
     * @param {Token<T>[]} tokens
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    Container.prototype.resolveFirst = function (tokens) {
        var _this = this;
        var providers$$1 = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers$$1[_i - 1] = arguments[_i];
        }
        var inst;
        tokens.some(function (tk) {
            inst = _this.resolve.apply(_this, [tk].concat(providers$$1));
            return inst !== null;
        });
        return inst;
    };
    /**
     * resolve token value in this container only.
     *
     * @template T
     * @param {Token<T>} token
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    Container.prototype.resolveValue = function (token) {
        var providers$$1 = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers$$1[_i - 1] = arguments[_i];
        }
        var key = this.getTokenKey(token);
        if (!this.hasRegister(key)) {
            return null;
        }
        var factory = this.factories.get(key);
        return factory.apply(void 0, providers$$1);
    };
    /**
     * get service or target reference service.
     *
     * @template T
     * @param {(Token<T> | Token<any>[])} token servive token.
     * @param {(RefTarget | RefTarget[])} [target] service refrence target.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    Container.prototype.getService = function (token, target, toRefToken, defaultToken) {
        var _this = this;
        var providers$$1 = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            providers$$1[_i - 4] = arguments[_i];
        }
        if (utils.isArray(target) || utils.isToken(target) || utils.isRefTarget(target) || utils.isTypeObject(target)) {
            var tokens_1 = [];
            (utils.isArray(token) ? token : [token]).forEach(function (tk) {
                tokens_1.push(tk);
                if (!utils.isClass(tk)) {
                    tokens_1.push(_this.getTokenImpl(tk));
                }
            });
            var fac_1;
            var defToken = void 0;
            var prds = [];
            if (utils.isBoolean(toRefToken)) {
                if (toRefToken) {
                    defToken = token;
                }
                else {
                    defToken = null;
                }
            }
            else if (utils.isToken(toRefToken)) {
                defToken = toRefToken;
            }
            else if (utils.isFunction(toRefToken)) {
                fac_1 = toRefToken;
                if (utils.isBoolean(defaultToken)) {
                    if (defaultToken) {
                        defToken = token;
                    }
                    else {
                        defToken = null;
                    }
                }
                else if (utils.isToken(defaultToken)) {
                    defToken = defaultToken;
                }
                else if (defaultToken) {
                    prds.push(defaultToken);
                }
            }
            else if (toRefToken) {
                prds.unshift(toRefToken);
            }
            defToken = defToken === null ? null : (defToken || token);
            prds = prds.concat(providers$$1);
            return this.getRefService.apply(this, [tokens_1.map(function (tk) { return { service: tk, isPrivate: true }; }).concat(fac_1 ? [function (tk) { return fac_1(tk); }] : [], tokens_1.map(function (t) { return function (tk) { return new InjectReference_1.InjectReference(t, tk); }; })), target,
                defToken].concat(prds));
        }
        else {
            return this.resolveFirst.apply(this, [utils.isArray(token) ? token : [token]].concat([target, toRefToken, defaultToken].concat(providers$$1).filter(function (a) { return a; })));
        }
    };
    /**
     * get target reference service.
     *
     * @template T
     * @param {Type<Registration<T>>} [refToken] reference service Registration Injector
     * @param {RefTarget | RefTarget[]} target  the service reference to.
     * @param {Token<T>} [defaultToken] default service token.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    Container.prototype.getRefService = function (refToken, target, defaultToken) {
        var _this = this;
        var providers$$1 = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            providers$$1[_i - 3] = arguments[_i];
        }
        var service = null;
        (utils.isArray(target) ? target : [target])
            .some(function (tag) {
            _this.forInRefTarget(tag, function (tk) {
                // exclude ref registration.
                if (InjectReference_1.isInjectReference(tk)) {
                    return true;
                }
                return !(utils.isArray(refToken) ? refToken : [refToken]).some(function (stk) {
                    var tokens = _this.getRefToken(stk, tk);
                    return (utils.isArray(tokens) ? tokens : [tokens]).some(function (rtk) {
                        service = _this.resolveRef.apply(_this, [rtk, tk].concat(providers$$1));
                        return service !== null;
                    });
                });
            });
            return service !== null;
        });
        if (!service && defaultToken) {
            service = this.resolveFirst.apply(this, [utils.isArray(defaultToken) ? defaultToken : [defaultToken]].concat(providers$$1));
        }
        return service;
    };
    /**
     * get all service extends type and reference target.
     *
     * @template T
     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.
     * @param {(Token<any> | Token<any>[])} [target] service refrence target.
     * @param {(boolean|ParamProviders)} [both]
     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    Container.prototype.getServices = function (token, target, both, resway) {
        var providers$$1 = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            providers$$1[_i - 4] = arguments[_i];
        }
        var services = [];
        this.iteratorServices.apply(this, [function (tk, fac, resolver) {
                var pds = [];
                for (var _i = 3; _i < arguments.length; _i++) {
                    pds[_i - 3] = arguments[_i];
                }
                services.push(fac.apply(void 0, pds));
            }, token, target, both, resway].concat(providers$$1));
        return services;
    };
    /**
     * get all service extends type and reference target.
     *
     * @template T
     * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express
     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.
     * @param {(Token<any> | Token<any>[])} [target] service refrence target.
     * @param {(boolean|ParamProviders)} [both]
     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    Container.prototype.iteratorServices = function (express, token, target, both, resway) {
        var _this = this;
        var providers$$1 = [];
        for (var _i = 5; _i < arguments.length; _i++) {
            providers$$1[_i - 5] = arguments[_i];
        }
        var withTag;
        var rway = IContainer.ResoveWay.all;
        var withBoth = false;
        var matchExp;
        if (utils.isToken(token)) {
            var type_1 = utils.isClassType(token) ? token : this.getTokenImpl(token);
            matchExp = function (tk) { return utils.lang.isExtendsClass(tk, type_1); };
        }
        else if (utils.isFunction(token)) {
            matchExp = token;
        }
        if (utils.isNumber(resway)) {
            rway = resway;
        }
        else {
            providers$$1.unshift(resway);
        }
        if (utils.isToken(target) || utils.isArray(target)) {
            withTag = true;
            if (utils.isBoolean(both)) {
                withBoth = both;
            }
            else if (utils.isNumber(both)) {
                rway = both;
            }
            else {
                providers$$1.unshift(both);
            }
            var tags_1 = (utils.isArray(target) ? target : [target]).map(function (t) {
                if (utils.isClass(t)) {
                    return t;
                }
                else if (utils.isAbstractClass(t)) {
                    return t;
                }
                else {
                    return _this.getTokenImpl(t);
                }
            });
            // target private service.
            this.getResolvers().toArray().some(function (resolver) {
                return tags_1.some(function (tg) {
                    var priMapTk = new InjectReference_1.InjectReference(providers.ProviderMap, tg);
                    if (resolver.has(priMapTk, IContainer.ResoveWay.nodes)) {
                        var priMap_1 = resolver.resolve(priMapTk, IContainer.ResoveWay.nodes);
                        return priMap_1.keys().some(function (ptk) {
                            if (utils.isClassType(ptk) && matchExp(ptk)) {
                                return express.apply(void 0, [ptk, priMap_1.get(ptk), priMap_1].concat(providers$$1)) !== false;
                            }
                            return false;
                        });
                    }
                    return false;
                });
            });
        }
        else {
            if (utils.isNumber(target)) {
                rway = target;
            }
            else {
                providers$$1.unshift(target);
            }
            withTag = false;
        }
        if (!withTag || (withTag && withBoth)) {
            this.iterator(function (tk, fac, resolver) {
                if (utils.isClassType(tk) && matchExp(tk)) {
                    return express.apply(void 0, [tk, fac, resolver].concat(providers$$1));
                }
            }, rway);
        }
    };
    /**
     * iterator all registered factory
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean} callbackfn
     * @param {ResoveWay} [resway= ResoveWay.all]
     * @memberof Container
     */
    Container.prototype.iterator = function (callbackfn, resway) {
        if (resway === void 0) { resway = IContainer.ResoveWay.all; }
        this.getResolvers().iterator(callbackfn, resway);
    };
    /**
     * iterator.
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>) => void | boolean} callbackfn
     * @memberof IExports
     */
    Container.prototype.forEach = function (callbackfn) {
        var _this = this;
        return !Array.from(this.factories.keys()).some(function (tk) {
            return callbackfn(tk, _this.factories.get(tk), _this) === false;
        });
    };
    Container.prototype.getRefToken = function (ref, tk) {
        if (Registration_1.isRegistrationClass(ref)) {
            return new ref(tk);
        }
        if (utils.isToken(ref)) {
            return ref;
        }
        if (utils.isFunction(ref)) {
            return ref(tk);
        }
        return ref;
    };
    Container.prototype.resolveRef = function (refToken, target) {
        var providers$$1 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers$$1[_i - 2] = arguments[_i];
        }
        var tk;
        var isPrivate = false;
        if (utils.isToken(refToken)) {
            tk = refToken;
        }
        else {
            tk = refToken.service;
            isPrivate = refToken.isPrivate !== false;
        }
        if (!tk) {
            return null;
        }
        // resolve private first.
        if (utils.isClass(target) && !InjectReference_1.isInjectReference(tk)) {
            var pdrmap = this.resolve(new InjectReference_1.InjectReference(providers.ProviderMap, target));
            if (pdrmap && pdrmap.has(tk)) {
                return pdrmap.resolve.apply(pdrmap, [tk].concat(providers$$1));
            }
        }
        // have not private registered.
        if (isPrivate) {
            return null;
        }
        return this.resolve.apply(this, [tk].concat(providers$$1));
    };
    /**
     * get tocken key.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @returns {SymbolType<T>}
     * @memberof Container
     */
    Container.prototype.getTokenKey = function (token, alias) {
        if (alias) {
            return new Registration_1.Registration(token, alias).toString();
        }
        else if (token instanceof Registration_1.Registration) {
            return token.toString();
        }
        return token;
    };
    /**
     * register type.
     * @abstract
     * @template T
     * @param {Token<T>} token
     * @param {T} [value]
     * @returns {this}
     * @memberOf Container
     */
    Container.prototype.register = function (token, value) {
        this.registerFactory(token, value);
        return this;
    };
    /**
     * register stingleton type.
     * @abstract
     * @template T
     * @param {Token<T>} token
     * @param {Factory<T>} [value]
     * @returns {this}
     * @memberOf Container
     */
    Container.prototype.registerSingleton = function (token, value) {
        this.registerFactory(token, value, true);
        return this;
    };
    /**
     * register value.
     *
     * @template T
     * @param {Token<T>} token
     * @param {T} value
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.registerValue = function (token, value) {
        var _this = this;
        var key = this.getTokenKey(token);
        this.getSingleton().set(key, value);
        if (!this.factories.has(key)) {
            this.factories.set(key, function () {
                return _this.getSingleton().get(key);
            });
        }
        return this;
    };
    /**
     * bind provider.
     *
     * @template T
     * @param {Token<T>} provide
     * @param {Token<T>} provider
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.bindProvider = function (provide, provider) {
        var _this = this;
        var provideKey = this.getTokenKey(provide);
        var factory;
        if (utils.isToken(provider)) {
            factory = function () {
                var providers$$1 = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    providers$$1[_i] = arguments[_i];
                }
                return _this.resolve.apply(_this, [provider].concat(providers$$1));
            };
        }
        else {
            if (utils.isFunction(provider)) {
                factory = function () {
                    var providers$$1 = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        providers$$1[_i] = arguments[_i];
                    }
                    return provider.apply(void 0, [_this].concat(providers$$1));
                };
            }
            else {
                factory = function () {
                    return provider;
                };
            }
        }
        if (utils.isClass(provider)) {
            if (!this.has(provider)) {
                this.register(provider);
            }
            this.provideTypes.set(provideKey, provider);
        }
        else if (utils.isToken(provider)) {
            var token = provider;
            while (this.provideTypes.has(token) && !utils.isClass(token)) {
                token = this.provideTypes.get(token);
                if (utils.isClass(token)) {
                    this.provideTypes.set(provideKey, token);
                    break;
                }
            }
        }
        this.factories.set(provideKey, factory);
        return this;
    };
    /**
     * bind providers for only target class.
     *
     * @param {Token<any>} target
     * @param {ParamProviders[]} providers
     * @param {(mapTokenKey: Token<any>) => void} [onceBinded]
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.bindProviders = function (target, onceBinded) {
        var _this = this;
        var providers$$1 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers$$1[_i - 2] = arguments[_i];
        }
        var _a;
        var tgt;
        var complete;
        var prods = providers$$1;
        if (utils.isFunction(onceBinded)) {
            complete = onceBinded;
        }
        else if (onceBinded) {
            prods.unshift(onceBinded);
        }
        if (utils.isToken(target)) {
            tgt = target;
        }
        else if (target) {
            tgt = null;
            prods.unshift(target);
        }
        var maps = (_a = this.getProviderParser()).parse.apply(_a, prods);
        if (tgt) {
            var refKey = new InjectReference_1.InjectReference(providers.ProviderMap, utils.isClass(tgt) ? tgt : this.getTokenImpl(tgt));
            if (this.hasRegister(refKey)) {
                this.resolveValue(refKey).copy(maps);
            }
            else {
                this.bindProvider(refKey, maps);
                complete && complete(refKey);
            }
        }
        else {
            maps.keys().forEach(function (key) {
                utils.isToken(key) && _this.factories.set(key, function () {
                    var prds = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        prds[_i] = arguments[_i];
                    }
                    return maps.resolve.apply(maps, [key].concat(prds));
                });
            });
        }
        return this;
    };
    /**
     * bind provider ref to target.
     *
     * @template T
     * @param {Token<any>} target
     * @param {Token<T>} provide
     * @param {(Token<T> | Factory<T>)} provider
     * @param {string} [alias]
     * @param {(refToken: Token<T>) => void} [onceBinded]
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.bindRefProvider = function (target, provide, provider, alias, onceBinded) {
        var refToken = new InjectReference_1.InjectReference(this.getTokenKey(provide, alias), target);
        this.bindProvider(refToken, provider);
        onceBinded && onceBinded(refToken);
        return this;
    };
    Container.prototype.unregisterValue = function (token) {
        var key = this.getTokenKey(token);
        if (this.hasRegister(key)) {
            this.factories.delete(key);
            if (this.provideTypes.has(key)) {
                this.provideTypes.delete(key);
            }
            if (utils.isClass(key)) {
                this.clearCache(key);
            }
        }
        return this;
    };
    /**
     * unregister the token
     *
     * @template T
     * @param {Token<T>} token
     * @param {ResoveWay} [resway]
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.unregister = function (token, resway) {
        this.getResolvers().unregister(token, resway);
        return this;
    };
    /**
     * clear cache.
     *
     * @param {Type<any>} targetType
     * @memberof IContainer
     */
    Container.prototype.clearCache = function (targetType) {
        this.resolveValue(ICacheManager.CacheManagerToken).destroy(targetType);
    };
    /**
     * get token.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @returns {Token<T>}
     * @memberof Container
     */
    Container.prototype.getToken = function (token, alias) {
        if (alias) {
            return new Registration_1.Registration(token, alias);
        }
        return token;
    };
    Container.prototype.getTokenProvider = function (token) {
        if (utils.isClass(token)) {
            return token;
        }
        var tokenKey = this.getTokenKey(token);
        if (this.provideTypes.has(tokenKey)) {
            return this.provideTypes.get(tokenKey);
        }
        return null;
    };
    /**
     * get token implements class type.
     *
     * @template T
     * @param {Token<T>} token
     * @param {boolean} [inchain]
     * @returns {Type<T>}
     * @memberof Container
     */
    Container.prototype.getTokenImpl = function (token, resway) {
        return this.getResolvers().getTokenImpl(token, resway);
    };
    /**
     * iterate token  in  token class chain.  return false will break iterate.
     *
     * @param {RefTarget} target
     * @param {(token: Token<any>) => boolean} express
     * @memberof Container
     */
    Container.prototype.forInRefTarget = function (target, express) {
        var _this = this;
        var type;
        var token;
        var level;
        if (utils.isToken(target)) {
            token = target;
            level = types.RefTagLevel.all;
        }
        else if (target) {
            if (utils.isRefTarget(target)) {
                token = target.target;
                level = target.level || types.RefTagLevel.self;
            }
            else if (utils.isTypeObject(target)) {
                token = utils.lang.getClass(target);
                level = types.RefTagLevel.all;
            }
        }
        if (!utils.isToken(token)) {
            return;
        }
        if (utils.isClassType(token)) {
            type = token;
            if (utils.isClass(type) && !this.has(type)) {
                this.use(type);
            }
        }
        else {
            type = this.getTokenImpl(token);
        }
        if (!utils.isClassType(token) || (types.RefTagLevel.self === level)) {
            express(token);
            return;
        }
        var inChain = (level & types.RefTagLevel.chain) > 0;
        var inProviders = (level & types.RefTagLevel.providers) > 0;
        utils.lang.forInClassChain(type, function (ty) {
            var tokens;
            if (inProviders) {
                var prdKey = new InjectReference_1.InjectClassProvidesToken(ty);
                var prds = _this.get(prdKey);
                if (prds && prds.provides && prds.provides.length) {
                    var ppdkey_1 = prdKey.toString();
                    var pmapKey_1 = new InjectReference_1.InjectReference(providers.ProviderMap, ty).toString();
                    tokens = prds.provides.slice(1).filter(function (p) {
                        var key = _this.getTokenKey(p);
                        return key !== ppdkey_1 && key !== pmapKey_1;
                    });
                }
            }
            tokens = tokens || [];
            return !(tokens.concat(ty).some(function (tk) { return express(tk) === false; })) && inChain;
        });
    };
    /**
     * get token implement class and base classes.
     *
     * @param {Token<any>} token
     * @returns {Token<any>[]}
     * @memberof Container
     */
    Container.prototype.getTokenClassChain = function (token, chain) {
        if (chain === void 0) { chain = true; }
        var tokens = [];
        this.forInRefTarget(token, function (tk) {
            tokens.push(tk);
            return chain;
        });
        return tokens;
    };
    /**
    * get life scope of container.
    *
    * @returns {LifeScope}
    * @memberof IContainer
    */
    Container.prototype.getLifeScope = function () {
        return this.get(LifeScope.LifeScopeToken);
    };
    /**
     * use modules.
     *
     * @param {...Modules[]} modules
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.use = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        var _a;
        (_a = this.getBuilder()).syncLoadModule.apply(_a, [this].concat(modules));
        return this;
    };
    /**
     * async use modules.
     *
     * @param {...LoadType[]} modules load modules.
     * @returns {Promise<Type<any>[]>}  types loaded.
     * @memberof IContainer
     */
    Container.prototype.loadModule = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        var _a;
        return (_a = this.getBuilder()).loadModule.apply(_a, [this].concat(modules));
    };
    /**
     * invoke method async.
     *
     * @template T
     * @param {any} target
     * @param {string} propertyKey
     * @param {*} [instance]
     * @param {...ParamProviders[]} providers
     * @returns {Promise<T>}
     * @memberof Container
     */
    Container.prototype.invoke = function (target, propertyKey, instance) {
        var providers$$1 = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            providers$$1[_i - 3] = arguments[_i];
        }
        var _a;
        return (_a = this.resolveValue(IMethodAccessor.MethodAccessorToken)).invoke.apply(_a, [target, propertyKey, instance].concat(providers$$1));
    };
    /**
     * invoke method.
     *
     * @template T
     * @param {any} target
     * @param {string} propertyKey
     * @param {*} [instance]
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    Container.prototype.syncInvoke = function (target, propertyKey, instance) {
        var providers$$1 = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            providers$$1[_i - 3] = arguments[_i];
        }
        var _a;
        return (_a = this.resolveValue(IMethodAccessor.MethodAccessorToken)).syncInvoke.apply(_a, [target, propertyKey, instance].concat(providers$$1));
    };
    Container.prototype.createSyncParams = function (params) {
        var providers$$1 = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers$$1[_i - 1] = arguments[_i];
        }
        var _a;
        return (_a = this.resolveValue(IMethodAccessor.MethodAccessorToken)).createSyncParams.apply(_a, [params].concat(providers$$1));
    };
    Container.prototype.createParams = function (params) {
        var providers$$1 = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers$$1[_i - 1] = arguments[_i];
        }
        var _a;
        return (_a = this.resolveValue(IMethodAccessor.MethodAccessorToken)).createParams.apply(_a, [params].concat(providers$$1));
    };
    Container.prototype.cacheDecorator = function (map, action) {
        if (!map.has(action.name)) {
            map.set(action.name, action);
        }
    };
    Container.prototype.init = function () {
        var _this = this;
        this.factories = new Map();
        this.provideTypes = new Map();
        this.bindProvider(IContainer.ContainerToken, function () { return _this; });
        registerCores_1.registerCores(this);
    };
    Container.prototype.getSingleton = function () {
        if (!this.hasRegister(SingletonRegToken)) {
            this.bindProvider(SingletonRegToken, new Map());
        }
        return this.resolveValue(SingletonRegToken);
    };
    Container.prototype.registerFactory = function (token, value, singleton) {
        var key = this.getTokenKey(token);
        if (this.factories.has(key)) {
            return;
        }
        var classFactory;
        if (!utils.isUndefined(value)) {
            if (utils.isFunction(value)) {
                if (utils.isClass(value)) {
                    this.bindTypeFactory(key, value, singleton);
                }
                else {
                    classFactory = this.createCustomFactory(key, value, singleton);
                }
            }
            else if (singleton && value !== undefined) {
                classFactory = this.createCustomFactory(key, function () { return value; }, singleton);
            }
        }
        else if (!utils.isString(token) && !utils.isSymbol(token)) {
            var ClassT = (token instanceof Registration_1.Registration) ? token.getClass() : token;
            if (utils.isClass(ClassT)) {
                this.bindTypeFactory(key, ClassT, singleton);
            }
        }
        if (classFactory) {
            this.factories.set(key, classFactory);
        }
    };
    Container.prototype.createCustomFactory = function (key, factory, singleton) {
        var _this = this;
        return singleton ?
            function () {
                var providers$$1 = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    providers$$1[_i] = arguments[_i];
                }
                if (_this.getSingleton().has(key)) {
                    return _this.getSingleton().get(key);
                }
                var instance = factory.apply(void 0, [_this].concat(providers$$1));
                _this.getSingleton().set(key, instance);
                return instance;
            }
            : function () {
                var providers$$1 = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    providers$$1[_i] = arguments[_i];
                }
                return factory.apply(void 0, [_this].concat(providers$$1));
            };
    };
    Container.prototype.bindTypeFactory = function (key, ClassT, singleton) {
        var _this = this;
        if (!Reflect.isExtensible(ClassT)) {
            return;
        }
        var lifeScope = this.getLifeScope();
        var parameters = lifeScope.getConstructorParameters(ClassT);
        if (!singleton) {
            singleton = lifeScope.isSingletonType(ClassT);
        }
        var factory = function () {
            var providers$$1 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                providers$$1[_i] = arguments[_i];
            }
            var _a;
            if (singleton && _this.getSingleton().has(key)) {
                return _this.getSingleton().get(key);
            }
            if (providers$$1.length < 1) {
                var lifecycleData = {
                    tokenKey: key,
                    targetType: ClassT,
                    // raiseContainer: this,
                    singleton: singleton
                };
                lifeScope.execute(lifecycleData, core.CoreActions.cache);
                if (lifecycleData.execResult && lifecycleData.execResult instanceof ClassT) {
                    return lifecycleData.execResult;
                }
            }
            var providerMap = (_a = _this.getProviderParser()).parse.apply(_a, providers$$1);
            lifeScope.execute({
                tokenKey: key,
                targetType: ClassT,
                raiseContainer: _this,
                params: parameters,
                providers: providers$$1,
                providerMap: providerMap,
                singleton: singleton
            }, types.IocState.runtime, core.LifeState.beforeCreateArgs);
            var args = _this.createSyncParams(parameters, providerMap);
            lifeScope.routeExecute({
                tokenKey: key,
                targetType: ClassT,
                raiseContainer: _this,
                args: args,
                params: parameters,
                providers: providers$$1,
                providerMap: providerMap,
                singleton: singleton
            }, types.IocState.runtime, core.LifeState.beforeConstructor);
            var instance = new (ClassT.bind.apply(ClassT, [void 0].concat(args)))();
            lifeScope.routeExecute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: _this,
                args: args,
                params: parameters,
                providers: providers$$1,
                providerMap: providerMap,
                singleton: singleton
            }, types.IocState.runtime, core.LifeState.afterConstructor);
            lifeScope.execute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: _this,
                args: args,
                params: parameters,
                providers: providers$$1,
                providerMap: providerMap,
                singleton: singleton
            }, types.IocState.runtime, core.LifeState.onInit);
            lifeScope.routeExecute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: _this,
                args: args,
                params: parameters,
                providers: providers$$1,
                providerMap: providerMap,
                singleton: singleton
            }, types.IocState.runtime, core.LifeState.AfterInit);
            lifeScope.execute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: _this
            }, core.CoreActions.cache);
            return instance;
        };
        this.factories.set(key, factory);
        lifeScope.routeExecute({
            tokenKey: key,
            targetType: ClassT,
            raiseContainer: this
        }, types.IocState.design);
    };
    Container.getClassAnnations = function () {
        return { "name": "Container", "params": { "constructor": [], "getRoot": [], "getProviderParser": [], "getBuilder": [], "getResolvers": [], "has": ["token", "aliasOrway"], "hasRegister": ["key"], "get": ["token", "alias", "providers"], "resolve": ["token", "resway", "providers"], "resolveFirst": ["tokens", "providers"], "resolveValue": ["token", "providers"], "getService": ["token", "target", "toRefToken", "defaultToken", "providers"], "getRefService": ["refToken", "target", "defaultToken", "providers"], "getServices": ["token", "target", "both", "resway", "providers"], "iteratorServices": ["express", "token", "target", "both", "resway", "providers"], "iterator": ["callbackfn", "resway"], "forEach": ["callbackfn"], "getRefToken": ["ref", "tk"], "resolveRef": ["refToken", "target", "providers"], "getTokenKey": ["token", "alias"], "register": ["token", "value"], "registerSingleton": ["token", "value"], "registerValue": ["token", "value"], "bindProvider": ["provide", "provider"], "bindProviders": ["target", "onceBinded", "providers"], "bindRefProvider": ["target", "provide", "provider", "alias", "onceBinded"], "unregisterValue": ["token"], "unregister": ["token", "resway"], "clearCache": ["targetType"], "getToken": ["token", "alias"], "getTokenProvider": ["token"], "getTokenImpl": ["token", "resway"], "forInRefTarget": ["target", "express"], "getTokenClassChain": ["token", "chain"], "getLifeScope": [], "use": ["modules"], "loadModule": ["modules"], "invoke": ["target", "propertyKey", "instance", "providers"], "syncInvoke": ["target", "propertyKey", "instance", "providers"], "createSyncParams": ["params", "providers"], "createParams": ["params", "providers"], "cacheDecorator": ["map", "action"], "init": [], "getSingleton": [], "registerFactory": ["token", "value", "singleton"], "createCustomFactory": ["key", "factory", "singleton"], "bindTypeFactory": ["key", "ClassT", "singleton"] } };
    };
    return Container;
}());
exports.Container = Container;


});

unwrapExports(Container_1);
var Container_2 = Container_1.Container;

var IModuleLoader = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * module loader token.
 */
exports.ModuleLoaderToken = new InjectToken_1.InjectToken('DI_ModuleLoader');


});

unwrapExports(IModuleLoader);
var IModuleLoader_1 = IModuleLoader.ModuleLoaderToken;

var DefaultModuleLoader_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * default module loader.
 *
 * @export
 * @class DefaultModuleLoader
 * @implements {IModuleLoader}
 */
var DefaultModuleLoader = /** @class */ (function () {
    function DefaultModuleLoader() {
    }
    DefaultModuleLoader.prototype.getLoader = function () {
        if (!this._loader) {
            this._loader = this.createLoader();
        }
        return this._loader;
    };
    /**
     * load module.
     *
     * @param {...LoadType[]} modules
     * @returns {Promise<Modules[]>}
     * @memberof DefaultModuleLoader
     */
    DefaultModuleLoader.prototype.load = function (modules) {
        var _this = this;
        if (modules.length) {
            return Promise.all(modules.map(function (mdty) {
                if (utils.isString(mdty)) {
                    return _this.isFile(mdty) ? _this.loadFile(mdty) : _this.loadModule(mdty);
                }
                else if (utils.isObject(mdty) && (mdty['modules'] || mdty['files'])) {
                    return _this.loadPathModule(mdty);
                }
                else {
                    return mdty ? [mdty] : [];
                }
            }))
                .then(function (allms) {
                var rmodules = [];
                allms.forEach(function (ms) {
                    rmodules = rmodules.concat(ms);
                });
                return rmodules;
            });
        }
        else {
            return Promise.resolve([]);
        }
    };
    /**
     * load types from module.
     *
     * @param {...LoadType[]} modules
     * @returns {Promise<Type<any>[]>}
     * @memberof IContainerBuilder
     */
    DefaultModuleLoader.prototype.loadTypes = function (modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var mdls;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.load(modules)];
                    case 1:
                        mdls = _a.sent();
                        return [2 /*return*/, this.getTypes(mdls)];
                }
            });
        });
    };
    /**
     * get all class type in modules.
     *
     * @param {Modules[]} modules
     * @param {...Express<Type<any>, boolean>[]} filters
     * @returns {Type<any>[]}
     * @memberof DefaultModuleLoader
     */
    DefaultModuleLoader.prototype.getTypes = function (modules) {
        var _this = this;
        var regModules = [];
        modules.forEach(function (m) {
            var types = _this.getContentTypes(m);
            regModules.push(types);
        });
        return regModules;
    };
    DefaultModuleLoader.prototype.loadFile = function (files, basePath) {
        var loader = this.getLoader();
        var fRes;
        if (utils.isArray(files)) {
            fRes = Promise.all(files.map(function (f) { return loader(f); }))
                .then(function (allms) {
                var rms = [];
                allms.forEach(function (ms) {
                    rms = rms.concat(ms);
                });
                return rms;
            });
        }
        else {
            fRes = loader(files);
        }
        return fRes.then(function (ms) { return ms.filter(function (it) { return !!it; }); });
    };
    DefaultModuleLoader.prototype.isFile = function (str) {
        return str && /\/((\w|%|\.))+\.\w+$/.test(str.replace(/\\\\/gi, '/'));
    };
    DefaultModuleLoader.prototype.loadModule = function (moduleName) {
        var loader = this.getLoader();
        return loader(moduleName).then(function (ms) { return ms.filter(function (it) { return !!it; }); });
    };
    DefaultModuleLoader.prototype.loadPathModule = function (pmd) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var modules;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        modules = [];
                        if (!pmd.files) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadFile(pmd.files, pmd.basePath)
                                .then(function (allmoduls) {
                                allmoduls.forEach(function (ms) {
                                    modules = modules.concat(ms);
                                });
                                return modules;
                            })];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!pmd.modules) return [3 /*break*/, 4];
                        return [4 /*yield*/, Promise.all(pmd.modules.map(function (nmd) {
                                return utils.isString(nmd) ? _this.loadModule(nmd) : nmd;
                            })).then(function (ms) {
                                modules = modules.concat(ms);
                                return modules;
                            })];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/, modules];
                }
            });
        });
    };
    DefaultModuleLoader.prototype.createLoader = function () {
        if (typeof commonjsRequire !== 'undefined') {
            return function (modulepath) {
                return new Promise(function (resolve, reject) {
                    commonjsRequire(modulepath, function (mud) {
                        resolve(mud);
                    }, function (err) {
                        reject(err);
                    });
                });
            };
        }
        else {
            throw new Error('has not module loader');
        }
    };
    DefaultModuleLoader.prototype.getContentTypes = function (regModule) {
        var regModules = [];
        if (utils.isClass(regModule)) {
            regModules.push(regModule);
        }
        else if (regModule) {
            var rmodules = regModule['exports'] ? regModule['exports'] : regModule;
            for (var p in rmodules) {
                var type = rmodules[p];
                if (utils.isClass(type)) {
                    regModules.push(type);
                }
            }
        }
        return regModules;
    };
    DefaultModuleLoader.getClassAnnations = function () {
        return { "name": "DefaultModuleLoader", "params": { "constructor": [], "getLoader": [], "load": ["modules"], "loadTypes": ["modules"], "getTypes": ["modules"], "loadFile": ["files", "basePath"], "isFile": ["str"], "loadModule": ["moduleName"], "loadPathModule": ["pmd"], "createLoader": [], "getContentTypes": ["regModule"] } };
    };
    return DefaultModuleLoader;
}());
exports.DefaultModuleLoader = DefaultModuleLoader;


});

unwrapExports(DefaultModuleLoader_1);
var DefaultModuleLoader_2 = DefaultModuleLoader_1.DefaultModuleLoader;

var IModuleValidate = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * inject module validate token for decorator or class.
 *
 * @export
 * @class InjectMetadataManagerToken
 * @extends {RefRegistration<IMetadataManager>}
 * @template T
 */
var InjectModuleValidateToken = /** @class */ (function (_super) {
    tslib_1.__extends(InjectModuleValidateToken, _super);
    function InjectModuleValidateToken(decorator) {
        return _super.call(this, decorator, 'ModuleValidate') || this;
    }
    InjectModuleValidateToken.getClassAnnations = function () {
        return { "name": "InjectModuleValidateToken", "params": { "constructor": ["decorator"] } };
    };
    return InjectModuleValidateToken;
}(InjectReference_1.RefRegistration));
exports.InjectModuleValidateToken = InjectModuleValidateToken;
/**
 * Module Validate Token
 */
exports.ModuleValidateToken = new InjectModuleValidateToken('');


});

unwrapExports(IModuleValidate);
var IModuleValidate_1 = IModuleValidate.InjectModuleValidateToken;
var IModuleValidate_2 = IModuleValidate.ModuleValidateToken;

var ModuleValidate = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * base module validate.
 *
 * @export
 * @abstract
 * @class BaseModuelValidate
 * @implements {IModuleValidate}
 */
var ModuelValidate = /** @class */ (function () {
    function ModuelValidate() {
    }
    ModuelValidate.prototype.valid = function (type) {
        if (!utils.isClass(type)) {
            return false;
        }
        var decorator = this.getDecorator();
        if (utils.isString(decorator)) {
            return core.hasOwnClassMetadata(decorator, type);
        }
        else if (utils.isArray(decorator)) {
            return decorator.some(function (d) { return core.hasOwnClassMetadata(d, type); });
        }
        return true;
    };
    ModuelValidate.prototype.getDecorator = function () {
        return null;
    };
    ModuelValidate.getClassAnnations = function () {
        return { "name": "ModuelValidate", "params": { "constructor": [], "valid": ["type"], "getDecorator": [] } };
    };
    return ModuelValidate;
}());
exports.ModuelValidate = ModuelValidate;
/**
 * IocExt module validate token.
 */
exports.IocExtModuleValidateToken = new IModuleValidate.InjectModuleValidateToken(core.IocExt.toString());
/**
 * IocExt module validate.
 *
 * @export
 * @class IocExtModuleValidate
 * @extends {ModuelValidate}
 * @implements {IModuleValidate}
 */
var IocExtModuleValidate = /** @class */ (function (_super) {
    tslib_1.__extends(IocExtModuleValidate, _super);
    function IocExtModuleValidate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IocExtModuleValidate.prototype.getDecorator = function () {
        return core.IocExt.toString();
    };
    IocExtModuleValidate.getClassAnnations = function () {
        return { "name": "IocExtModuleValidate", "params": { "getDecorator": [] } };
    };
    return IocExtModuleValidate;
}(ModuelValidate));
exports.IocExtModuleValidate = IocExtModuleValidate;


});

unwrapExports(ModuleValidate);
var ModuleValidate_1 = ModuleValidate.ModuelValidate;
var ModuleValidate_2 = ModuleValidate.IocExtModuleValidateToken;
var ModuleValidate_3 = ModuleValidate.IocExtModuleValidate;

var IModuleInjector = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


/**
 *  inject module injector token.
 */
var InjectModuleInjectorToken = /** @class */ (function (_super) {
    tslib_1.__extends(InjectModuleInjectorToken, _super);
    function InjectModuleInjectorToken(desc) {
        return _super.call(this, 'DI_ModuleInjector', desc) || this;
    }
    InjectModuleInjectorToken.getClassAnnations = function () {
        return { "name": "InjectModuleInjectorToken", "params": { "constructor": ["desc"] } };
    };
    return InjectModuleInjectorToken;
}(Registration_1.Registration));
exports.InjectModuleInjectorToken = InjectModuleInjectorToken;
/**
 * async module injector token.
 */
exports.ModuleInjectorToken = new InjectModuleInjectorToken('');


});

unwrapExports(IModuleInjector);
var IModuleInjector_1 = IModuleInjector.InjectModuleInjectorToken;
var IModuleInjector_2 = IModuleInjector.ModuleInjectorToken;

var ModuleInjector_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * base module injector. abstract class.
 *
 * @export
 * @abstract
 * @class BaseModuleInjector
 * @implements {IModuleInjector}
 */
var ModuleInjector = /** @class */ (function () {
    /**
     *Creates an instance of BaseModuleInjector.
     * @param {IModuleValidate} [validate]
     * @param {boolean} [skipNext] skip next when has match module to injector.
     * @memberof BaseModuleInjector
     */
    function ModuleInjector(validate, skipNext) {
        this.validate = validate;
        this.skipNext = skipNext;
    }
    ModuleInjector.prototype.inject = function (container, modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var types, next;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        types = (modules || []).filter(function (ty) { return _this.valid(container, ty); });
                        if (!types.length) return [3 /*break*/, 2];
                        return [4 /*yield*/, utils.PromiseUtil.step(types.map(function (ty) { return function () { return _this.setup(container, ty); }; }))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        next = this.getNext(modules, types);
                        return [2 /*return*/, { injected: types, next: next }];
                }
            });
        });
    };
    ModuleInjector.prototype.syncInject = function (container, modules) {
        var _this = this;
        var types = (modules || []).filter(function (ty) { return _this.valid(container, ty); });
        if (types.length) {
            types.forEach(function (ty) {
                _this.syncSetup(container, ty);
            });
        }
        var next = this.getNext(modules, types);
        return { injected: types, next: next };
    };
    ModuleInjector.prototype.valid = function (container, type) {
        if (!this.validate) {
            return true;
        }
        return this.validate.valid(type);
    };
    ModuleInjector.prototype.getNext = function (all, filtered) {
        if (filtered.length === 0) {
            return all;
        }
        if (this.skipNext) {
            return null;
        }
        if (filtered.length === all.length) {
            return null;
        }
        return all.filter(function (it) { return filtered.indexOf(it) < 0; });
    };
    ModuleInjector.prototype.setup = function (container, type) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                container.register(type);
                return [2 /*return*/];
            });
        });
    };
    ModuleInjector.prototype.syncSetup = function (container, type) {
        container.register(type);
    };
    ModuleInjector.getClassAnnations = function () {
        return { "name": "ModuleInjector", "params": { "constructor": ["validate", "skipNext"], "inject": ["container", "modules"], "syncInject": ["container", "modules"], "valid": ["container", "type"], "getNext": ["all", "filtered"], "setup": ["container", "type"], "syncSetup": ["container", "type"] } };
    };
    ModuleInjector = tslib_1.__decorate([
        core.Injectable(IModuleInjector.ModuleInjectorToken),
        tslib_1.__param(0, core.Inject(IModuleValidate.ModuleValidateToken)),
        tslib_1.__metadata("design:paramtypes", [Object, Boolean])
    ], ModuleInjector);
    return ModuleInjector;
}());
exports.ModuleInjector = ModuleInjector;


});

unwrapExports(ModuleInjector_1);
var ModuleInjector_2 = ModuleInjector_1.ModuleInjector;

var IModuleInjectorChain = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * module fileter token. mast use as singlton.
 */
exports.ModuleInjectorChainToken = new InjectToken_1.InjectToken('DI_ModuleInjectorChain');


});

unwrapExports(IModuleInjectorChain);
var IModuleInjectorChain_1 = IModuleInjectorChain.ModuleInjectorChainToken;

var ModuleInjectorChain_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * Module Injector chain, base injector chain.
 *
 * @export
 * @class ModuleInjectorChain
 * @implements {IModuleInjectorChain}
 */
var ModuleInjectorChain = /** @class */ (function () {
    function ModuleInjectorChain() {
        this._injectors = [];
    }
    Object.defineProperty(ModuleInjectorChain.prototype, "injectors", {
        get: function () {
            return this._injectors;
        },
        enumerable: true,
        configurable: true
    });
    ModuleInjectorChain.prototype.first = function (injector) {
        if (this.isInjector(injector)) {
            this._injectors.unshift(injector);
        }
        return this;
    };
    ModuleInjectorChain.prototype.next = function (injector) {
        if (this.isInjector(injector)) {
            this._injectors.push(injector);
        }
        return this;
    };
    ModuleInjectorChain.prototype.isInjector = function (injector) {
        return injector instanceof ModuleInjector_1.ModuleInjector;
    };
    ModuleInjectorChain.prototype.inject = function (container, modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var types;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        types = [];
                        return [4 /*yield*/, utils.PromiseUtil.runInChain(this.injectors.map(function (jtor) {
                                return function (mds, next) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                    var ijRt;
                                    return tslib_1.__generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, jtor.inject(container, mds)];
                                            case 1:
                                                ijRt = _a.sent();
                                                if (ijRt.injected && ijRt.injected.length) {
                                                    types = types.concat(ijRt.injected);
                                                }
                                                if (ijRt.next && ijRt.next.length > 0) {
                                                    return [2 /*return*/, next()];
                                                }
                                                return [2 /*return*/];
                                        }
                                    });
                                }); };
                            }), modules)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, types];
                }
            });
        });
    };
    ModuleInjectorChain.prototype.syncInject = function (container, modules) {
        var types = [];
        var completed = false;
        this.injectors.some(function (jtor) {
            if (jtor instanceof ModuleInjector_1.ModuleInjector) {
                var result = jtor.syncInject(container, modules);
                types = types.concat(result.injected);
                completed = (!result.next || result.next.length < 1);
            }
            return completed;
        });
        return types;
    };
    ModuleInjectorChain.getClassAnnations = function () {
        return { "name": "ModuleInjectorChain", "params": { "constructor": [], "first": ["injector"], "next": ["injector"], "isInjector": ["injector"], "inject": ["container", "modules"], "syncInject": ["container", "modules"] } };
    };
    return ModuleInjectorChain;
}());
exports.ModuleInjectorChain = ModuleInjectorChain;


});

unwrapExports(ModuleInjectorChain_1);
var ModuleInjectorChain_2 = ModuleInjectorChain_1.ModuleInjectorChain;

var injectors = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(IModuleLoader, exports);
tslib_1.__exportStar(DefaultModuleLoader_1, exports);
tslib_1.__exportStar(IModuleValidate, exports);
tslib_1.__exportStar(ModuleValidate, exports);
tslib_1.__exportStar(IModuleInjector, exports);
tslib_1.__exportStar(ModuleInjector_1, exports);
tslib_1.__exportStar(IModuleInjectorChain, exports);
tslib_1.__exportStar(ModuleInjectorChain_1, exports);


});

unwrapExports(injectors);

var ContainerBuilder_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * default container builder.
 *
 * @export
 * @class DefaultContainerBuilder
 * @implements {IContainerBuilder}
 */
var ContainerBuilder = /** @class */ (function () {
    function ContainerBuilder(loader) {
        this._loader = loader;
    }
    Object.defineProperty(ContainerBuilder.prototype, "loader", {
        get: function () {
            if (!this._loader) {
                this._loader = new injectors.DefaultModuleLoader();
            }
            return this._loader;
        },
        enumerable: true,
        configurable: true
    });
    ContainerBuilder.prototype.create = function () {
        var _this = this;
        var container = new Container_1.Container();
        container.bindProvider(IContainerBuilder.ContainerBuilderToken, function () { return _this; });
        container.bindProvider(injectors.ModuleLoaderToken, function () { return _this.loader; });
        return container;
    };
    /**
     * build container.
     *
     * @param {...LoadType[]} [modules]
     * @returns
     * @memberof DefaultContainerBuilder
     */
    ContainerBuilder.prototype.build = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var container;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        container = this.create();
                        if (!modules.length) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadModule.apply(this, [container].concat(modules))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, container];
                }
            });
        });
    };
    /**
     * load modules for container.
     *
     * @param {IContainer} container
     * @param {...LoadType[]} modules
     * @returns {Promise<Type<any>[]>}
     * @memberof DefaultContainerBuilder
     */
    ContainerBuilder.prototype.loadModule = function (container) {
        var modules = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            modules[_i - 1] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var regModules, injTypes, injChain_1;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loader.loadTypes(modules)];
                    case 1:
                        regModules = _a.sent();
                        injTypes = [];
                        if (!(regModules && regModules.length)) return [3 /*break*/, 3];
                        injChain_1 = this.getInjectorChain(container);
                        return [4 /*yield*/, utils.PromiseUtil.step(regModules.map(function (typs) { return function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                var ityps;
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, injChain_1.inject(container, typs)];
                                        case 1:
                                            ityps = _a.sent();
                                            injTypes = injTypes.concat(ityps);
                                            return [2 /*return*/];
                                    }
                                });
                            }); }; }))];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, injTypes];
                }
            });
        });
    };
    ContainerBuilder.prototype.syncBuild = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        var container = this.create();
        if (modules.length) {
            this.syncLoadModule.apply(this, [container].concat(modules));
        }
        return container;
    };
    ContainerBuilder.prototype.syncLoadModule = function (container) {
        var modules = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            modules[_i - 1] = arguments[_i];
        }
        var regModules = this.loader.getTypes(modules);
        var injTypes = [];
        if (regModules && regModules.length) {
            var injChain_2 = this.getInjectorChain(container);
            regModules.forEach(function (typs) {
                var ityps = injChain_2.syncInject(container, typs);
                injTypes = injTypes.concat(ityps);
            });
        }
        return injTypes;
    };
    ContainerBuilder.prototype.getInjectorChain = function (container) {
        if (!container.has(injectors.ModuleInjectorChainToken)) {
            container.register(injectors.ModuleInjector)
                .bindProvider(injectors.ModuleValidateToken, new injectors.ModuelValidate())
                .bindProvider(injectors.IocExtModuleValidateToken, new injectors.IocExtModuleValidate())
                .bindProvider(injectors.ModuleInjectorChainToken, new injectors.ModuleInjectorChain()
                .next(container.resolve(injectors.ModuleInjectorToken, { provide: injectors.ModuleValidateToken, useValue: container.get(injectors.IocExtModuleValidateToken) }, { skipNext: true }))
                .next(container.resolve(injectors.ModuleInjectorToken)));
        }
        return container.get(injectors.ModuleInjectorChainToken);
    };
    ContainerBuilder.getClassAnnations = function () {
        return { "name": "ContainerBuilder", "params": { "constructor": ["loader"], "create": [], "build": ["modules"], "loadModule": ["container", "modules"], "syncBuild": ["modules"], "syncLoadModule": ["container", "modules"], "getInjectorChain": ["container"] } };
    };
    return ContainerBuilder;
}());
exports.ContainerBuilder = ContainerBuilder;


});

unwrapExports(ContainerBuilder_1);
var ContainerBuilder_2 = ContainerBuilder_1.ContainerBuilder;

var D__workspace_github_tsioc_packages_core_lib = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

tslib_1.__exportStar(IContainer, exports);
tslib_1.__exportStar(Container_1, exports);
tslib_1.__exportStar(types, exports);
tslib_1.__exportStar(Registration_1, exports);
tslib_1.__exportStar(InjectReference_1, exports);
tslib_1.__exportStar(InjectToken_1, exports);
tslib_1.__exportStar(IContainerBuilder, exports);
tslib_1.__exportStar(IMethodAccessor, exports);
tslib_1.__exportStar(ICacheManager, exports);
tslib_1.__exportStar(LifeScope, exports);
tslib_1.__exportStar(ContainerBuilder_1, exports);
tslib_1.__exportStar(utils, exports);
tslib_1.__exportStar(components, exports);
tslib_1.__exportStar(core, exports);
tslib_1.__exportStar(injectors, exports);
tslib_1.__exportStar(providers, exports);
tslib_1.__exportStar(resolves, exports);


});

var index$9 = unwrapExports(D__workspace_github_tsioc_packages_core_lib);

module.exports = index$9;

//# sourceMappingURL=sourcemaps/core.js.map
