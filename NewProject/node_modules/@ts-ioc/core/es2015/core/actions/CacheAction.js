"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ActionComposite_1 = require("./ActionComposite");
const utils_1 = require("../../utils");
const CoreActions_1 = require("./CoreActions");
const factories_1 = require("../factories");
const ICacheManager_1 = require("../../ICacheManager");
/**
 * cache action. To cache instance of Token. define cache expires in decorator.
 *
 * @export
 * @class CacheAction
 * @extends {ActionComposite}
 */
class CacheAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.cache);
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return data;
        }
        if (data.singleton || !data.targetType || !utils_1.isClass(data.targetType)) {
            return data;
        }
        let cacheManager = container.get(ICacheManager_1.CacheManagerToken);
        if (data.target) {
            if (!cacheManager.hasCache(data.targetType)) {
                let cacheMetadata = this.getCacheMetadata(container, data);
                if (cacheMetadata) {
                    cacheManager.cache(data.targetType, data.target, cacheMetadata.expires);
                }
            }
        }
        else {
            let target = cacheManager.get(data.targetType);
            if (target) {
                let cacheMetadata = this.getCacheMetadata(container, data);
                if (cacheMetadata) {
                    cacheManager.cache(data.targetType, target, cacheMetadata.expires);
                    data.execResult = target;
                }
            }
        }
        return data;
    }
    getCacheMetadata(container, data) {
        let lifeScope = container.getLifeScope();
        let matchs = lifeScope.getClassDecorators(data.targetType);
        let cacheMetadata;
        for (let i = 0; i < matchs.length; i++) {
            let surm = matchs[i];
            let metadata = factories_1.getOwnTypeMetadata(surm.name, data.targetType);
            if (Array.isArray(metadata) && metadata.length > 0) {
                cacheMetadata = metadata.find(c => c && utils_1.isNumber(c.expires) && c.expires > 0);
                if (cacheMetadata) {
                    break;
                }
            }
        }
        return cacheMetadata;
    }
    static getClassAnnations() {
        return { "name": "CacheAction", "params": { "constructor": [], "working": ["container", "data"], "getCacheMetadata": ["container", "data"] } };
    }
}
exports.CacheAction = CacheAction;

//# sourceMappingURL=../../sourcemaps/core/actions/CacheAction.js.map
