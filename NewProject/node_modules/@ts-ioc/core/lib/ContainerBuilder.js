"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Container_1 = require("./Container");
var IContainerBuilder_1 = require("./IContainerBuilder");
var injectors_1 = require("./injectors");
var utils_1 = require("./utils");
/**
 * default container builder.
 *
 * @export
 * @class DefaultContainerBuilder
 * @implements {IContainerBuilder}
 */
var ContainerBuilder = /** @class */ (function () {
    function ContainerBuilder(loader) {
        this._loader = loader;
    }
    Object.defineProperty(ContainerBuilder.prototype, "loader", {
        get: function () {
            if (!this._loader) {
                this._loader = new injectors_1.DefaultModuleLoader();
            }
            return this._loader;
        },
        enumerable: true,
        configurable: true
    });
    ContainerBuilder.prototype.create = function () {
        var _this = this;
        var container = new Container_1.Container();
        container.bindProvider(IContainerBuilder_1.ContainerBuilderToken, function () { return _this; });
        container.bindProvider(injectors_1.ModuleLoaderToken, function () { return _this.loader; });
        return container;
    };
    /**
     * build container.
     *
     * @param {...LoadType[]} [modules]
     * @returns
     * @memberof DefaultContainerBuilder
     */
    ContainerBuilder.prototype.build = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var container;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        container = this.create();
                        if (!modules.length) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadModule.apply(this, [container].concat(modules))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, container];
                }
            });
        });
    };
    /**
     * load modules for container.
     *
     * @param {IContainer} container
     * @param {...LoadType[]} modules
     * @returns {Promise<Type<any>[]>}
     * @memberof DefaultContainerBuilder
     */
    ContainerBuilder.prototype.loadModule = function (container) {
        var modules = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            modules[_i - 1] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var regModules, injTypes, injChain_1;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loader.loadTypes(modules)];
                    case 1:
                        regModules = _a.sent();
                        injTypes = [];
                        if (!(regModules && regModules.length)) return [3 /*break*/, 3];
                        injChain_1 = this.getInjectorChain(container);
                        return [4 /*yield*/, utils_1.PromiseUtil.step(regModules.map(function (typs) { return function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                var ityps;
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, injChain_1.inject(container, typs)];
                                        case 1:
                                            ityps = _a.sent();
                                            injTypes = injTypes.concat(ityps);
                                            return [2 /*return*/];
                                    }
                                });
                            }); }; }))];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, injTypes];
                }
            });
        });
    };
    ContainerBuilder.prototype.syncBuild = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        var container = this.create();
        if (modules.length) {
            this.syncLoadModule.apply(this, [container].concat(modules));
        }
        return container;
    };
    ContainerBuilder.prototype.syncLoadModule = function (container) {
        var modules = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            modules[_i - 1] = arguments[_i];
        }
        var regModules = this.loader.getTypes(modules);
        var injTypes = [];
        if (regModules && regModules.length) {
            var injChain_2 = this.getInjectorChain(container);
            regModules.forEach(function (typs) {
                var ityps = injChain_2.syncInject(container, typs);
                injTypes = injTypes.concat(ityps);
            });
        }
        return injTypes;
    };
    ContainerBuilder.prototype.getInjectorChain = function (container) {
        if (!container.has(injectors_1.ModuleInjectorChainToken)) {
            container.register(injectors_1.ModuleInjector)
                .bindProvider(injectors_1.ModuleValidateToken, new injectors_1.ModuelValidate())
                .bindProvider(injectors_1.IocExtModuleValidateToken, new injectors_1.IocExtModuleValidate())
                .bindProvider(injectors_1.ModuleInjectorChainToken, new injectors_1.ModuleInjectorChain()
                .next(container.resolve(injectors_1.ModuleInjectorToken, { provide: injectors_1.ModuleValidateToken, useValue: container.get(injectors_1.IocExtModuleValidateToken) }, { skipNext: true }))
                .next(container.resolve(injectors_1.ModuleInjectorToken)));
        }
        return container.get(injectors_1.ModuleInjectorChainToken);
    };
    ContainerBuilder.getClassAnnations = function () {
        return { "name": "ContainerBuilder", "params": { "constructor": ["loader"], "create": [], "build": ["modules"], "loadModule": ["container", "modules"], "syncBuild": ["modules"], "syncLoadModule": ["container", "modules"], "getInjectorChain": ["container"] } };
    };
    return ContainerBuilder;
}());
exports.ContainerBuilder = ContainerBuilder;

//# sourceMappingURL=sourcemaps/ContainerBuilder.js.map
