"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var factories_1 = require("./factories");
/**
 * class metadata accessor.
 *
 * @export
 * @class MetaAccessor
 * @implements {IMetaAccessor<any>}
 */
var MetaAccessor = /** @class */ (function () {
    function MetaAccessor() {
    }
    MetaAccessor.prototype.getDecorators = function (type) {
        return factories_1.getClassDecorators(type);
    };
    /**
     * get metadata config of target type. via decorators in order.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {IAnnotationMetadata<any>} [extConfig]
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>}
     * @memberof MetaAccessor
     */
    MetaAccessor.prototype.getMetadata = function (token, container, extConfig, decorFilter) {
        var type = utils_1.isClass(token) ? token : container.getTokenImpl(token);
        var cfg;
        if (utils_1.isClass(type)) {
            var decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            var classmeta_1 = {};
            decors.forEach(function (decor) {
                var metas = factories_1.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    metas.forEach(function (meta) {
                        if (meta) {
                            classmeta_1 = utils_1.lang.assign({}, classmeta_1, meta);
                        }
                    });
                }
            });
            cfg = classmeta_1;
        }
        if (cfg) {
            return utils_1.lang.assign({}, cfg, extConfig || {});
        }
        else {
            return extConfig || {};
        }
    };
    /**
     * find metadata accessor.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {Express<IAnnotationMetadata<any>, boolean>} filter
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>}
     * @memberof MetaAccessor
     */
    MetaAccessor.prototype.find = function (token, container, filter, decorFilter) {
        var type = utils_1.isClass(token) ? token : container.getTokenImpl(token);
        var metadata = null;
        if (utils_1.isClass(type)) {
            var decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            decors.some(function (decor) {
                var metas = factories_1.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    return metas.some(function (meta) {
                        if (meta && filter(meta)) {
                            metadata = meta;
                        }
                        return !!metadata;
                    });
                }
                return false;
            });
        }
        return metadata;
    };
    /**
     * filter metadata accessor.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {Express<IAnnotationMetadata<any>, boolean>} filter
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>[]}
     * @memberof MetaAccessor
     */
    MetaAccessor.prototype.filter = function (token, container, filter, decorFilter) {
        var type = utils_1.isClass(token) ? token : container.getTokenImpl(token);
        var metadatas = [];
        if (utils_1.isClass(type)) {
            var decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            decors.forEach(function (decor) {
                var metas = factories_1.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    metas.filter(function (meta) { return meta && filter(meta); }).forEach(function (meta) {
                        metadatas.push(meta);
                    });
                }
            });
        }
        return metadatas;
    };
    /**
     * get token of metadata config.
     *
     * @param {IAnnotationMetadata<any>} config
     * @param {IContainer} [container] vaild token in container or not.
     * @returns {Token<any>}
     * @memberof MetadataManager
     */
    MetaAccessor.prototype.getToken = function (config, container) {
        var token = this.getTokenInConfig(config);
        if (this.validateToken(token, container)) {
            return token;
        }
        else {
            return null;
        }
    };
    /**
     * get module boot token from module configure.
     *
     * @param {IAnnotationMetadata<any>} config
     * @param {IContainer} [container]  vaild container.
     * @returns {Token<any>}
     * @memberof ModuelValidate
     */
    MetaAccessor.prototype.getBootToken = function (config, container) {
        var token = this.getBootTokenInConfig(config);
        if (this.validateToken(token, container)) {
            return token;
        }
        else {
            return null;
        }
    };
    MetaAccessor.prototype.validateToken = function (token, container) {
        return utils_1.isToken(token);
    };
    MetaAccessor.prototype.getTokenInConfig = function (config) {
        return config.token || config.type;
    };
    MetaAccessor.prototype.getBootTokenInConfig = function (config) {
        return config.bootstrap;
    };
    MetaAccessor.getClassAnnations = function () {
        return { "name": "MetaAccessor", "params": { "constructor": [], "getDecorators": ["type"], "getMetadata": ["token", "container", "extConfig", "decorFilter"], "find": ["token", "container", "filter", "decorFilter"], "filter": ["token", "container", "filter", "decorFilter"], "getToken": ["config", "container"], "getBootToken": ["config", "container"], "validateToken": ["token", "container"], "getTokenInConfig": ["config"], "getBootTokenInConfig": ["config"] } };
    };
    return MetaAccessor;
}());
exports.MetaAccessor = MetaAccessor;

//# sourceMappingURL=../sourcemaps/core/MetaAccessor.js.map
