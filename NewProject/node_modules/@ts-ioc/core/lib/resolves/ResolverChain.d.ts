import { Type, Token, InstanceFactory } from '../types';
import { IContainer, ResoveWay } from '../IContainer';
import { InjectToken } from '../InjectToken';
import { IResolver, IResolverContainer } from '../IResolver';
import { ParamProviders } from '../providers';
/**
 *  resolver chain token.
 */
export declare const ResolverChainToken: InjectToken<ResolverChain>;
/**
 * resover chain.
 *
 * resove by setp.
 *
 * @export
 * @class ResolverChain
 * @implements {IResolver}
 */
export declare class ResolverChain implements IResolverContainer {
    protected container: IContainer;
    /**
     * resolvers
     *
     * @protected
     * @type {IResolver[]}
     * @memberof ResolverChain
     */
    protected resolvers: IResolver[];
    constructor(container: IContainer);
    readonly size: number;
    /**
     * reigister next resolver.
     *
     * @param {IResolver} resolver
     * @memberof ResolverChain
     */
    next(resolver: IResolver): void;
    /**
     * has resolver or not.
     *
     * @param {IResolver} resolver
     * @returns
     * @memberof ResolverChain
     */
    hasResolver(resolver: IResolver): boolean;
    /**
     * resove token via registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof ResolverChain
     */
    resolve<T>(token: Token<T>, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T;
    /**
     * unregister token in registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @memberof ResolverChain
     */
    unregister<T>(token: Token<T>, resway?: ResoveWay): this;
    /**
     * get token implements class in the registered resolver chain.
     *
     * @template T
     * @param {Token<T>} token
     * @returns {Type<T>}
     * @memberof ResolverChain
     */
    getTokenImpl<T>(token: Token<T>, resway?: ResoveWay): Type<T>;
    /**
     * has token or not in the registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @returns {boolean}
     * @memberof ResolverChain
     */
    has<T>(token: Token<T>, aliasOrway?: string | ResoveWay): boolean;
    /**
     * resolver chain to array.
     *
     * @returns {IResolver[]}
     * @memberof ResolverChain
     */
    toArray(resway?: ResoveWay): IResolver[];
    forEach(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean): void | boolean;
    /**
     * iterator all resolvers.
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void} callbackfn
     * @memberof ResolverChain
     */
    iterator(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void, resway?: ResoveWay): void | boolean;
    static getClassAnnations(): any;
}
