"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var typeCheck_1 = require("./typeCheck");
/**
 * defer
 *
 * @export
 * @class Defer
 * @template T
 */
var Defer = /** @class */ (function () {
    function Defer() {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
    }
    Defer.create = function (then) {
        var defer = new Defer();
        if (then) {
            defer.promise = defer.promise.then(then);
            return defer;
        }
        else {
            return defer;
        }
    };
    Defer.getClassAnnations = function () {
        return { "name": "Defer", "params": { "create": ["then"], "constructor": [] } };
    };
    return Defer;
}());
exports.Defer = Defer;
/**
 * promise util.
 */
var PromiseUtil;
(function (PromiseUtil) {
    /**
     * create defer.
     *
     * @export
     * @template T
     * @param {((val: T) => T | PromiseLike<T>)} [then]
     * @returns {Defer<T>}
     */
    function defer(then) {
        return Defer.create(then);
    }
    PromiseUtil.defer = defer;
    /**
     * foreach opter for promises.
     *
     * @export
     * @template T
     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises
     * @param {Express<T, any>} express
     * @param {T} [defVal]
     * @returns
     */
    function forEach(promises, express, defVal) {
        var defer = new Defer();
        var pf = Promise.resolve(defVal);
        var length = promises ? promises.length : 0;
        if (length) {
            promises.forEach(function (p, idx) {
                pf = pf.then(function (v) { return typeCheck_1.isFunction(p) ? p(v) : p; })
                    .then(function (data) {
                    if (express(data) === false) {
                        defer.resolve('complete');
                        return Promise.reject('complete');
                    }
                    else if (idx === length - 1) {
                        defer.resolve('complete');
                        return Promise.reject('complete');
                    }
                    return data;
                });
            });
            pf.catch(function (err) {
                return err;
            });
        }
        else {
            defer.reject('array empty.');
        }
        return defer.promise;
    }
    PromiseUtil.forEach = forEach;
    /**
     * run promise step by step.
     *
     * @export
     * @template T
     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises
     * @returns
     */
    function step(promises) {
        var result = Promise.resolve(null);
        promises.forEach(function (p) {
            result = result.then(function (v) { return typeCheck_1.isFunction(p) ? p(v) : p; });
        });
        return result;
    }
    PromiseUtil.step = step;
    /**
     * find first validate value from promises.
     *
     * @export
     * @template T
     * @param {(...(T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises
     * @param {Express<T, boolean>} validate
     * @returns
     */
    function find(promises, filter, defVal) {
        var defer = new Defer();
        forEach(promises, function (val) {
            if (filter(val)) {
                defer.resolve(val);
                return false;
            }
            return true;
        }, defVal)
            .then(function () { return defer.resolve(null); })
            .catch(function () {
            defer.resolve(null);
        });
        return defer.promise;
    }
    PromiseUtil.find = find;
    /**
     * run action in chain.
     *
     * @export
     * @template T
     * @param {ActionHandle<T>[]} handles
     * @param {T} ctx
     * @param {() => Promise<void>} [next]
     * @returns {Promise<void>}
     */
    function runInChain(handles, ctx, next) {
        var index = -1;
        return dispatch(0);
        function dispatch(idx) {
            if (idx <= index) {
                return Promise.reject('next called mutiple times');
            }
            index = idx;
            var handle = idx < handles.length ? handles[idx] : null;
            if (idx === handles.length) {
                handle = next;
            }
            if (!handle) {
                return Promise.resolve();
            }
            try {
                return Promise.resolve(handle(ctx, dispatch.bind(null, idx + 1)));
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
    }
    PromiseUtil.runInChain = runInChain;
})(PromiseUtil = exports.PromiseUtil || (exports.PromiseUtil = {}));

//# sourceMappingURL=../sourcemaps/utils/PromiseUtil.js.map
