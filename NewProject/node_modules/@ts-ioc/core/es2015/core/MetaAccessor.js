"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const factories_1 = require("./factories");
/**
 * class metadata accessor.
 *
 * @export
 * @class MetaAccessor
 * @implements {IMetaAccessor<any>}
 */
class MetaAccessor {
    constructor() {
    }
    getDecorators(type) {
        return factories_1.getClassDecorators(type);
    }
    /**
     * get metadata config of target type. via decorators in order.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {IAnnotationMetadata<any>} [extConfig]
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>}
     * @memberof MetaAccessor
     */
    getMetadata(token, container, extConfig, decorFilter) {
        let type = utils_1.isClass(token) ? token : container.getTokenImpl(token);
        let cfg;
        if (utils_1.isClass(type)) {
            let decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            let classmeta = {};
            decors.forEach(decor => {
                let metas = factories_1.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    metas.forEach(meta => {
                        if (meta) {
                            classmeta = utils_1.lang.assign({}, classmeta, meta);
                        }
                    });
                }
            });
            cfg = classmeta;
        }
        if (cfg) {
            return utils_1.lang.assign({}, cfg, extConfig || {});
        }
        else {
            return extConfig || {};
        }
    }
    /**
     * find metadata accessor.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {Express<IAnnotationMetadata<any>, boolean>} filter
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>}
     * @memberof MetaAccessor
     */
    find(token, container, filter, decorFilter) {
        let type = utils_1.isClass(token) ? token : container.getTokenImpl(token);
        let metadata = null;
        if (utils_1.isClass(type)) {
            let decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            decors.some(decor => {
                let metas = factories_1.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    return metas.some(meta => {
                        if (meta && filter(meta)) {
                            metadata = meta;
                        }
                        return !!metadata;
                    });
                }
                return false;
            });
        }
        return metadata;
    }
    /**
     * filter metadata accessor.
     *
     * @param {Token<any>} token
     * @param {IContainer} container
     * @param {Express<IAnnotationMetadata<any>, boolean>} filter
     * @param {Express<string, boolean>} [decorFilter]
     * @returns {IAnnotationMetadata<any>[]}
     * @memberof MetaAccessor
     */
    filter(token, container, filter, decorFilter) {
        let type = utils_1.isClass(token) ? token : container.getTokenImpl(token);
        let metadatas = [];
        if (utils_1.isClass(type)) {
            let decors = this.getDecorators(type);
            if (decorFilter) {
                decors = decors.filter(decorFilter);
            }
            decors.forEach(decor => {
                let metas = factories_1.getTypeMetadata(decor, type);
                if (metas && metas.length) {
                    metas.filter(meta => meta && filter(meta)).forEach(meta => {
                        metadatas.push(meta);
                    });
                }
            });
        }
        return metadatas;
    }
    /**
     * get token of metadata config.
     *
     * @param {IAnnotationMetadata<any>} config
     * @param {IContainer} [container] vaild token in container or not.
     * @returns {Token<any>}
     * @memberof MetadataManager
     */
    getToken(config, container) {
        let token = this.getTokenInConfig(config);
        if (this.validateToken(token, container)) {
            return token;
        }
        else {
            return null;
        }
    }
    /**
     * get module boot token from module configure.
     *
     * @param {IAnnotationMetadata<any>} config
     * @param {IContainer} [container]  vaild container.
     * @returns {Token<any>}
     * @memberof ModuelValidate
     */
    getBootToken(config, container) {
        let token = this.getBootTokenInConfig(config);
        if (this.validateToken(token, container)) {
            return token;
        }
        else {
            return null;
        }
    }
    validateToken(token, container) {
        return utils_1.isToken(token);
    }
    getTokenInConfig(config) {
        return config.token || config.type;
    }
    getBootTokenInConfig(config) {
        return config.bootstrap;
    }
    static getClassAnnations() {
        return { "name": "MetaAccessor", "params": { "constructor": [], "getDecorators": ["type"], "getMetadata": ["token", "container", "extConfig", "decorFilter"], "find": ["token", "container", "filter", "decorFilter"], "filter": ["token", "container", "filter", "decorFilter"], "getToken": ["config", "container"], "getBootToken": ["config", "container"], "validateToken": ["token", "container"], "getTokenInConfig": ["config"], "getBootTokenInConfig": ["config"] } };
    }
}
exports.MetaAccessor = MetaAccessor;

//# sourceMappingURL=../sourcemaps/core/MetaAccessor.js.map
