"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var typeCheck_1 = require("./typeCheck");
// use core-js in browser.
/**
 * map base.
 *
 * @export
 * @class MapBase
 * @template K
 * @template V
 */
var MapBase = /** @class */ (function () {
    function MapBase() {
        this.map = new Map();
    }
    Object.defineProperty(MapBase.prototype, "size", {
        get: function () {
            return this.map.size;
        },
        enumerable: true,
        configurable: true
    });
    MapBase.prototype.clear = function () {
        this.map.clear();
    };
    MapBase.prototype.delete = function (key) {
        return this.map.delete(key);
    };
    MapBase.prototype.get = function (key) {
        return this.map.get(key);
    };
    MapBase.prototype.has = function (key) {
        return this.map.has(key);
    };
    MapBase.prototype.set = function (key, value) {
        this.map.set(key, value);
        return this;
    };
    MapBase.prototype.keys = function () {
        return Array.from(this.map.keys());
    };
    MapBase.prototype.values = function () {
        return Array.from(this.map.values());
    };
    MapBase.getClassAnnations = function () {
        return { "name": "MapBase", "params": { "constructor": [], "clear": [], "delete": ["key"], "get": ["key"], "has": ["key"], "set": ["key", "value"], "keys": [], "values": [] } };
    };
    return MapBase;
}());
exports.MapBase = MapBase;
/**
 * map set  for tsioc old version.
 *
 * @export
 * @class MapSet
 * @template K
 * @template V
 */
var MapSet = /** @class */ (function (_super) {
    tslib_1.__extends(MapSet, _super);
    function MapSet() {
        return _super.call(this) || this;
    }
    MapSet.prototype.forEach = function (callbackfn, thisArg) {
        this.map.forEach(callbackfn, thisArg);
    };
    MapSet.getClassAnnations = function () {
        return { "name": "MapSet", "params": { "constructor": [], "forEach": ["callbackfn", "thisArg"] } };
    };
    return MapSet;
}(MapBase));
exports.MapSet = MapSet;
/**
 * lang utils
 */
var lang;
(function (lang) {
    /**
     * assert param is right or not.
     *
     * @export
     * @param {*} param
     * @param {(string | Function)} msg
     */
    function assert(param, msg) {
        if (typeCheck_1.isNullOrUndefined(param)) {
            throw new Error(typeCheck_1.isFunction(msg) ? msg(param) : msg);
        }
    }
    lang.assert = assert;
    /**
     * check assert param invalid by express
     *
     * @export
     * @param {(boolean | (() => boolean))} express
     * @param {(string | Function)} msg
     */
    function assertExp(express, msg) {
        if (!(typeCheck_1.isFunction(express) ? express() : express)) {
            throw new Error(typeCheck_1.isFunction(msg) ? msg() : msg);
        }
    }
    lang.assertExp = assertExp;
    /**
     * get object keys.
     *
     * @param {*} target
     * @returns {string[]}
     */
    function keys(target) {
        if (typeCheck_1.isObject(target)) {
            if (typeCheck_1.isFunction(Object.keys)) {
                return Object.keys(target);
            }
        }
        return [];
    }
    lang.keys = keys;
    /**
     * values of target object.
     *
     * @export
     * @param {*} target
     * @returns {any[]}
     */
    function values(target) {
        if (typeCheck_1.isObject(target)) {
            if (typeCheck_1.isFunction(Object.values)) {
                return Object.values(target);
            }
            else {
                return keys(target).map(function (n) { return target[n]; });
            }
        }
        return [];
    }
    lang.values = values;
    /**
     * assign
     *
     * @export
     * @template T
     * @param {T} target
     * @param {...any[]} source
     * @returns {T}
     */
    function assign(target, source1, source2, sources) {
        if (sources && sources.length) {
            sources.unshift(source2 || {});
            sources.unshift(source1 || {});
            return Object.assign.apply(Object, [target].concat(sources));
        }
        else if (source2) {
            return Object.assign(target, source1 || {}, source2);
        }
        else {
            return Object.assign(target, source1 || {});
        }
    }
    lang.assign = assign;
    /**
     * create an new object from target object omit some field.
     *
     * @export
     * @param {ObjectMap<any>} target
     * @param {...string[]} fields
     * @returns {*}
     */
    function omit(target) {
        var fields = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            fields[_i - 1] = arguments[_i];
        }
        if (typeCheck_1.isObject(target)) {
            var result_1 = {};
            keys(target).forEach(function (key) {
                if (fields.indexOf(key) < 0) {
                    result_1[key] = target[key];
                }
            });
            return result_1;
        }
        else {
            return target;
        }
    }
    lang.omit = omit;
    /**
     * object has field or not.
     *
     * @export
     * @param {ObjectMap<any>} target
     * @returns
     */
    function hasField(target) {
        return keys(target).length > 0;
    }
    lang.hasField = hasField;
    /**
     * for in opter for object or array.
     *
     * @export
     * @template T
     * @param {(ObjectMap<T> | T[])} target
     * @param {(item: T, idx?: number|string) => void|boolean} iterator
     */
    function forIn(target, iterator) {
        if (typeCheck_1.isArray(target)) {
            target.some(function (it, idx) { return iterator(it, idx) === false; });
        }
        else if (typeCheck_1.isObject(target)) {
            keys(target).some(function (key, idx) { return iterator(target[key], key) === false; });
        }
    }
    lang.forIn = forIn;
    /**
     * find
     *
     * @template T
     * @param {(ObjectMap<T> | T[])} target
     * @param {((item: T, idx?: number | string) => boolean)} express
     */
    function find(target, express) {
        var item;
        forIn(target, function (it, idx) {
            if (!item) {
                if (express(it, idx)) {
                    item = it;
                    return false;
                }
                return true;
            }
            else {
                return true;
            }
        });
    }
    lang.find = find;
    /**
     * first.
     *
     * @export
     * @template T
     * @param {T[]} list
     * @returns {T}
     */
    function first(list) {
        if (typeCheck_1.isArray(list) && list.length) {
            return list[0];
        }
        return null;
    }
    lang.first = first;
    /**
     * last.
     *
     * @export
     * @template T
     * @param {T[]} list
     * @returns {T}
     */
    function last(list) {
        if (typeCheck_1.isArray(list) && list.length) {
            return list[list.length - 1];
        }
        return null;
    }
    lang.last = last;
    /**
     * get class annations.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns
     */
    function getClassAnnations(target) {
        return typeCheck_1.isFunction(target.getClassAnnations) ? target.getClassAnnations() : target.classAnnations;
    }
    lang.getClassAnnations = getClassAnnations;
    /**
     * target has class annations or not.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {boolean}
     */
    function hasClassAnnations(target) {
        if (typeCheck_1.isFunction(target.getClassAnnations)) {
            return true;
        }
        return target.classAnnations && typeCheck_1.isString(target.classAnnations.name) && target.classAnnations.name.length > 0;
    }
    lang.hasClassAnnations = hasClassAnnations;
    /**
     * get calss of object.
     *
     * @export
     * @param {*} target
     * @returns {Type<any>}
     */
    function getClass(target) {
        if (typeCheck_1.isNullOrUndefined(target)) {
            return null;
        }
        if (typeCheck_1.isClass(target)) {
            return target;
        }
        return target.constructor || target.prototype.constructor;
    }
    lang.getClass = getClass;
    /**
     * get class name.
     *
     * @export
     * @param {AbstractType<any>} target
     * @returns {string}
     */
    function getClassName(target) {
        var classType = typeCheck_1.isFunction(target) ? target : getClass(target);
        if (!typeCheck_1.isFunction(classType)) {
            return '';
        }
        if (/^[a-z]$/.test(classType.name)) {
            var classAnnations = getClassAnnations(classType);
            return classAnnations ? classAnnations.name : classType.name;
        }
        return classType.name;
    }
    lang.getClassName = getClassName;
    /**
     * get target type parent class.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {ClassType<any>}
     */
    function getParentClass(target) {
        var p = Reflect.getPrototypeOf(target.prototype);
        return typeCheck_1.isClass(p) ? p : p.constructor;
    }
    lang.getParentClass = getParentClass;
    /**
     * get all parent class in chain.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {ClassType<any>[]}
     */
    function getClassChain(target) {
        var types = [];
        forInClassChain(target, function (type) {
            types.push(type);
        });
        return types;
    }
    lang.getClassChain = getClassChain;
    /**
     * iterate base classes of target in chain. return false will break iterate.
     *
     * @export
     * @param {Type<any>} target
     * @param {(token: Type<any>) => any} express
     */
    function forInClassChain(target, express) {
        while (typeCheck_1.isClassType(target) && target !== Object) {
            if (express(target) === false) {
                break;
            }
            target = getParentClass(target);
        }
    }
    lang.forInClassChain = forInClassChain;
    /**
     * target is extends class of baseClass or not.
     *
     * @export
     * @param {Token<any>} target
     * @param {(ClassType<any> | ((type: ClassType<any>) => boolean))} baseClass
     * @returns {boolean}
     */
    function isExtendsClass(target, baseClass) {
        var isExtnds = false;
        if (typeCheck_1.isClassType(target)) {
            forInClassChain(target, function (t) {
                if (typeCheck_1.isClassType(baseClass)) {
                    isExtnds = t === baseClass;
                }
                else {
                    isExtnds = baseClass(t);
                }
                return !isExtnds;
            });
        }
        return isExtnds;
    }
    lang.isExtendsClass = isExtendsClass;
})(lang = exports.lang || (exports.lang = {}));

//# sourceMappingURL=../sourcemaps/utils/lang.js.map
