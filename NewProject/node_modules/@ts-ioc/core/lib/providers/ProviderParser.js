"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var ProviderMap_1 = require("./ProviderMap");
var Provider_1 = require("./Provider");
/**
 * provider matcher. use to find custome providers in resolve.
 *
 * note: object map provider can not resolve token.
 *
 * @export
 * @class ProviderMatcher
 * @implements {IProviderMatcher}
 */
var ProviderParser = /** @class */ (function () {
    function ProviderParser(container) {
        this.container = container;
    }
    ProviderParser.prototype.parse = function () {
        var _this = this;
        var providers = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            providers[_i] = arguments[_i];
        }
        if (providers.length === 1 && ProviderMap_1.isProviderMap(providers[0])) {
            return providers[0];
        }
        var map = this.container.resolve(ProviderMap_1.ProviderMapToken);
        providers.forEach(function (p, index) {
            if (utils_1.isUndefined(p) || utils_1.isNull(p)) {
                return;
            }
            if (ProviderMap_1.isProviderMap(p)) {
                map.copy(p);
            }
            else if (p instanceof Provider_1.Provider) {
                if (p instanceof Provider_1.ParamProvider) {
                    if (!p.type && utils_1.isNumber(p.index)) {
                        map.add(p.index, function () {
                            var providers = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                providers[_i] = arguments[_i];
                            }
                            return p.resolve.apply(p, [_this.container].concat(providers));
                        });
                    }
                    else {
                        map.add(p.type, function () {
                            var providers = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                providers[_i] = arguments[_i];
                            }
                            return p.resolve.apply(p, [_this.container].concat(providers));
                        });
                    }
                }
                else {
                    map.add(p.type, function () {
                        var providers = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            providers[_i] = arguments[_i];
                        }
                        return p.resolve.apply(p, [_this.container].concat(providers));
                    });
                }
            }
            else if (utils_1.isClass(p)) {
                if (!_this.container.has(p)) {
                    _this.container.register(p);
                }
                map.add(p, p);
            }
            else if (utils_1.isBaseObject(p)) {
                var pr_1 = p;
                var isobjMap = false;
                if (utils_1.isToken(pr_1.provide)) {
                    if (utils_1.isArray(pr_1.deps) && pr_1.deps.length) {
                        pr_1.deps.forEach(function (d) {
                            if (utils_1.isClass(d) && !_this.container.has(d)) {
                                _this.container.register(d);
                            }
                        });
                    }
                    if (!utils_1.isUndefined(pr_1.useValue)) {
                        map.add(pr_1.provide, function () { return pr_1.useValue; });
                    }
                    else if (utils_1.isClass(pr_1.useClass)) {
                        if (!_this.container.has(pr_1.useClass)) {
                            _this.container.register(pr_1.useClass);
                        }
                        map.add(pr_1.provide, pr_1.useClass);
                    }
                    else if (utils_1.isFunction(pr_1.useFactory)) {
                        map.add(pr_1.provide, function () {
                            var providers = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                providers[_i] = arguments[_i];
                            }
                            var args = [];
                            if (utils_1.isArray(pr_1.deps) && pr_1.deps.length) {
                                args = pr_1.deps.map(function (d) {
                                    var _a;
                                    if (utils_1.isToken(d)) {
                                        return (_a = _this.container).resolve.apply(_a, [d].concat(providers));
                                    }
                                    else {
                                        return d;
                                    }
                                });
                            }
                            return pr_1.useFactory.apply(pr_1, args);
                        });
                    }
                    else if (utils_1.isToken(pr_1.useExisting)) {
                        map.add(pr_1.provide, function () {
                            var providers = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                providers[_i] = arguments[_i];
                            }
                            var _a;
                            return (_a = _this.container).resolve.apply(_a, [pr_1.useExisting].concat(providers));
                        });
                    }
                    else {
                        isobjMap = true;
                    }
                }
                else {
                    isobjMap = true;
                }
                if (isobjMap) {
                    utils_1.lang.forIn(p, function (val, name) {
                        if (name && utils_1.isString(name)) {
                            // object map can not resolve token. set all fileld as value factory.
                            map.add(name, function () { return val; });
                        }
                    });
                }
            }
            else if (utils_1.isFunction(p)) {
                map.add(name, function () { return p; });
            }
        });
        return map;
    };
    ProviderParser.getClassAnnations = function () {
        return { "name": "ProviderParser", "params": { "constructor": ["container"], "parse": ["providers"] } };
    };
    return ProviderParser;
}());
exports.ProviderParser = ProviderParser;
function isProvider(target) {
    return ProviderMap_1.isProviderMap(target) || utils_1.isBaseObject(target) || target instanceof Provider_1.Provider;
}
exports.isProvider = isProvider;

//# sourceMappingURL=../sourcemaps/providers/ProviderParser.js.map
