{"version":3,"sources":["core/factories/ParamPropDecoratorFactory.ts"],"names":[],"mappings":";;AAAA,4BAA0B;AAE1B,yDAAuF;AACvF,mDAAgD;AAChD,uCAAyD;AAkCzD;;;;;;;;;GASG;AACH,SAAgB,wBAAwB,CACpC,IAAY,EACZ,OAAyB,EACzB,eAAoC;IACpC,IAAI,gBAAgB,GAAG,CAAC,CAAC,IAAkB,EAAE,EAAE;QAC3C,IAAI,OAAO,EAAE;YACT,OAAO,CAAC,IAAI,CAAC,CAAC;SACjB;QACD,IAAI,CAAC,IAAI,CAAI;YACT,UAAU,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,yBAAiB,CAAC,GAAG,EAAE,OAAO,CAAC;YACpD,KAAK,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,eAAO,CAAC,GAAG,CAAC;YAC5B,WAAW,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE,EAAE;gBAC3B,QAAQ,CAAC,QAAQ,GAAG,GAAG,CAAC;YAC5B,CAAC;SACJ,CAAC,CAAC;QACH,iBAAiB;QACjB,qCAAqC;QACrC,wCAAwC;QACxC,gCAAgC;QAChC,QAAQ;QACR,MAAM;IACV,CAAC,CAAC,CAAC;IACH,IAAI,SAAS,GAAG,kCAAe,CAAI,IAAI,EAAE,gBAAgB,EAAE,eAAe,CAAC,CAAC;IAC5E,SAAS,CAAC,aAAa,GAAG,6BAAa,CAAC,QAAQ,GAAG,6BAAa,CAAC,SAAS,CAAC;IAC3E,OAAO,SAAS,CAAC;AACrB,CAAC;AAzBD,4DAyBC","file":"../../../core/factories/ParamPropDecoratorFactory.js","sourcesContent":["import 'reflect-metadata';\r\nimport { ParamPropMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { isToken, isProvideMetadata } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { Token } from '../../types';\r\n\r\n\r\n/**\r\n * property parameter decorator.\r\n */\r\nexport type PropParamDecorator = (target: Object, propertyKey: string | symbol, parameterIndex?: number) => void;\r\n\r\n/**\r\n * Parameter and Property decorator.\r\n *\r\n * @export\r\n * @interface IParamPropDecorator\r\n */\r\nexport interface IParamPropDecorator<T extends ParamPropMetadata> {\r\n    /**\r\n     * define parameter or property decorator with param.\r\n     *\r\n     * @param {Token<T>} provider define provider to resolve value to the parameter or property.\r\n     */\r\n    (provider: Token<any>): PropParamDecorator;\r\n    /**\r\n     * define parameter or property decorator with metadata map.\r\n     * @param {T} [metadata] define matadata map to resolve value to the parameter or property.\r\n     */\r\n    (metadata?: T): PropParamDecorator;\r\n    /**\r\n     * define parameter or property decorator.\r\n     */\r\n    (target: object, propertyKey: string | symbol, parameterIndex?: number): void;\r\n}\r\n\r\n/**\r\n * create parameter or property decorator\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {IParamPropDecorator<T>}\r\n */\r\nexport function createParamPropDecorator<T extends ParamPropMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IParamPropDecorator<T> {\r\n    let paramPropAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            isMetadata: (arg) => isProvideMetadata(arg, 'index'),\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provider = arg;\r\n            }\r\n        });\r\n        // args.next<T>({\r\n        //     match: (arg) => isString(arg),\r\n        //     setMetadata: (metadata, arg) => {\r\n        //         metadata.alias = arg;\r\n        //     }\r\n        // });\r\n    });\r\n    let decorator = createDecorator<T>(name, paramPropAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Property | DecoratorType.Parameter;\r\n    return decorator;\r\n}\r\n\r\n"]}