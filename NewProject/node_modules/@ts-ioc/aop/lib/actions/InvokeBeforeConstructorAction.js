"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@ts-ioc/core");
var IAdvisor_1 = require("../IAdvisor");
var AopActions_1 = require("./AopActions");
var joinpoints_1 = require("../joinpoints");
var isValideAspectTarget_1 = require("../isValideAspectTarget");
/**
 * actions invoke before constructor.
 *
 * @export
 * @class InvokeBeforeConstructorAction
 * @extends {ActionComposite}
 */
var InvokeBeforeConstructorAction = /** @class */ (function (_super) {
    tslib_1.__extends(InvokeBeforeConstructorAction, _super);
    function InvokeBeforeConstructorAction() {
        return _super.call(this, AopActions_1.AopActions.registAspect) || this;
    }
    InvokeBeforeConstructorAction.prototype.working = function (container, data) {
        // aspect class do nothing.
        if (!isValideAspectTarget_1.isValideAspectTarget(data.targetType)) {
            return;
        }
        var advisor = container.get(IAdvisor_1.AdvisorToken);
        var className = core_1.lang.getClassName(data.targetType);
        var advices = advisor.getAdvices(className + '.constructor');
        if (!advices) {
            return;
        }
        var targetType = data.targetType;
        var target = data.target;
        var joinPoint = container.resolve(joinpoints_1.Joinpoint, core_1.Provider.create('options', {
            name: 'constructor',
            state: joinpoints_1.JoinpointState.Before,
            fullName: className + '.constructor',
            target: target,
            args: data.args,
            params: data.params,
            targetType: targetType
        }));
        var providers = [core_1.Provider.create(joinpoints_1.Joinpoint, joinPoint)];
        if (data.providerMap) {
            providers.push(data.providerMap);
        }
        advices.Before.forEach(function (advicer) {
            var _a;
            (_a = advisor.getContainer(advicer.aspectType, container)).syncInvoke.apply(_a, [advicer.aspectType, advicer.advice.propertyKey, null].concat(providers)); // new Joinpoint(joinPoint) // container.resolve(Joinpoint, { json: joinPoint })
        });
        advices.Around.forEach(function (advicer) {
            var _a;
            (_a = advisor.getContainer(advicer.aspectType, container)).syncInvoke.apply(_a, [advicer.aspectType, advicer.advice.propertyKey, null].concat(providers));
        });
    };
    InvokeBeforeConstructorAction.getClassAnnations = function () {
        return { "name": "InvokeBeforeConstructorAction", "params": { "constructor": [], "working": ["container", "data"] } };
    };
    return InvokeBeforeConstructorAction;
}(core_1.ActionComposite));
exports.InvokeBeforeConstructorAction = InvokeBeforeConstructorAction;

//# sourceMappingURL=../sourcemaps/actions/InvokeBeforeConstructorAction.js.map
