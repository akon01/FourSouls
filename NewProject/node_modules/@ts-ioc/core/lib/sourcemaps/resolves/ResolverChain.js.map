{"version":3,"sources":["resolves/ResolverChain.ts"],"names":[],"mappings":"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","file":"../../resolves/ResolverChain.js","sourcesContent":["import { Type, Token, InstanceFactory } from '../types';\r\nimport { IContainer, ResoveWay } from '../IContainer';\r\nimport { InjectToken } from '../InjectToken';\r\nimport { IResolver, IResolverContainer } from '../IResolver';\r\nimport { ParamProviders, ProviderMap, isProviderMap } from '../providers';\r\nimport { isString, isNumber, isFunction, isClass } from '../utils';\r\n\r\n/**\r\n *  resolver chain token.\r\n */\r\nexport const ResolverChainToken = new InjectToken<ResolverChain>('di_ResolverChain');\r\n\r\n/**\r\n * resover chain.\r\n *\r\n * resove by setp.\r\n *\r\n * @export\r\n * @class ResolverChain\r\n * @implements {IResolver}\r\n */\r\nexport class ResolverChain implements IResolverContainer {\r\n\r\n    /**\r\n     * resolvers\r\n     *\r\n     * @protected\r\n     * @type {IResolver[]}\r\n     * @memberof ResolverChain\r\n     */\r\n    protected resolvers: IResolver[];\r\n\r\n    constructor(protected container: IContainer) {\r\n        this.resolvers = [];\r\n    }\r\n\r\n    get size(): number {\r\n        return this.resolvers.length + 1;\r\n    }\r\n\r\n    /**\r\n     * reigister next resolver.\r\n     *\r\n     * @param {IResolver} resolver\r\n     * @memberof ResolverChain\r\n     */\r\n    next(resolver: IResolver) {\r\n        if (!this.hasResolver(resolver)) {\r\n            this.resolvers.push(resolver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * has resolver or not.\r\n     *\r\n     * @param {IResolver} resolver\r\n     * @returns\r\n     * @memberof ResolverChain\r\n     */\r\n    hasResolver(resolver: IResolver) {\r\n        if (resolver === this.container) {\r\n            return true;\r\n        }\r\n        return this.resolvers.indexOf(resolver) >= 0;\r\n    }\r\n\r\n    /**\r\n     * resove token via registered resolver chain.\r\n     *\r\n     * @template T\r\n     * @param {SymbolType<T>} token\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof ResolverChain\r\n     */\r\n    resolve<T>(token: Token<T>, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T {\r\n        let key = this.container.getTokenKey(token, isString(resway) ? resway : null);\r\n        let way: ResoveWay;\r\n        if (isNumber(resway)) {\r\n            way = resway;\r\n        } else {\r\n            if (resway) {\r\n                providers.unshift(resway);\r\n            }\r\n            way = ResoveWay.all;\r\n        }\r\n        let providerMap: ProviderMap;\r\n        if (providers.length) {\r\n            if (providers.length === 1 && isProviderMap(providers[0])) {\r\n                providerMap = providers[0] as ProviderMap;\r\n            } else {\r\n                providerMap = this.container.getProviderParser().parse(...providers);\r\n            }\r\n        }\r\n        if (providerMap && providerMap.has(token)) {\r\n            return providerMap.resolve(token, providerMap);\r\n        }\r\n\r\n        if ((way & ResoveWay.current) && this.container.hasRegister(key)) {\r\n            return this.container.resolveValue(key, providerMap);\r\n        }\r\n        if ((way & ResoveWay.traverse)) {\r\n            let resolver = this.resolvers.find(r => r.has(key, ResoveWay.nodes));\r\n            if (resolver) {\r\n                return resolver.resolve(key, ResoveWay.nodes, providerMap);\r\n            }\r\n        }\r\n        if (this.container.parent && (way & ResoveWay.bubble)) {\r\n            return this.container.parent.resolve(key, resway, providerMap);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * unregister token in registered resolver chain.\r\n     *\r\n     * @template T\r\n     * @param {SymbolType<T>} token\r\n     * @memberof ResolverChain\r\n     */\r\n    unregister<T>(token: Token<T>, resway?: ResoveWay) {\r\n        resway = resway || ResoveWay.all;\r\n        let tokenKey = this.container.getTokenKey(token);\r\n        if (resway & ResoveWay.current) {\r\n            this.container.unregisterValue(tokenKey);\r\n        }\r\n        if (resway & ResoveWay.traverse) {\r\n            this.resolvers.forEach((r: IResolverContainer) => {\r\n                if (isFunction(r.unregister)) {\r\n                    r.unregister(tokenKey, ResoveWay.nodes);\r\n                }\r\n            });\r\n        }\r\n        if ((resway & ResoveWay.bubble) && this.container.parent) {\r\n            this.container.parent.unregister(token, resway);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * get token implements class in the registered resolver chain.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @returns {Type<T>}\r\n     * @memberof ResolverChain\r\n     */\r\n    getTokenImpl<T>(token: Token<T>, resway?: ResoveWay): Type<T> {\r\n        if (isClass(token)) {\r\n            return token;\r\n        }\r\n        resway = resway || ResoveWay.nodes;\r\n        let tokenKey = this.container.getTokenKey(token);\r\n        let provider: Type<T>;\r\n        if (resway & ResoveWay.current) {\r\n            provider = this.container.getTokenProvider(tokenKey);\r\n        }\r\n        if (!provider && (resway & ResoveWay.traverse)) {\r\n            this.resolvers.some((r: IResolverContainer) => {\r\n                if (!isFunction(r.getTokenImpl)) {\r\n                    return false;\r\n                }\r\n                provider = r.getTokenImpl(tokenKey, ResoveWay.nodes);\r\n                return !!provider;\r\n            });\r\n        }\r\n        if (!provider && (resway & ResoveWay.bubble) && this.container.parent) {\r\n            provider = this.container.parent.getTokenImpl(token, resway);\r\n        }\r\n\r\n        return provider || null;\r\n    }\r\n\r\n    /**\r\n     * has token or not in the registered resolver chain.\r\n     *\r\n     * @template T\r\n     * @param {SymbolType<T>} token\r\n     * @returns {boolean}\r\n     * @memberof ResolverChain\r\n     */\r\n    has<T>(token: Token<T>, aliasOrway?: string | ResoveWay): boolean {\r\n        let key = this.container.getTokenKey(token, isString(aliasOrway) ? aliasOrway : null);\r\n        let resway = isNumber(aliasOrway) ? aliasOrway : ResoveWay.all;\r\n        if ((resway & ResoveWay.current) && this.container.hasRegister(key)) {\r\n            return true;\r\n        }\r\n        if ((resway & ResoveWay.traverse) && this.resolvers.some(r => r.has(key, ResoveWay.nodes))) {\r\n            return true;\r\n        }\r\n        if ((resway & ResoveWay.bubble) && this.container.parent) {\r\n            return this.container.parent.has(token, resway);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * resolver chain to array.\r\n     *\r\n     * @returns {IResolver[]}\r\n     * @memberof ResolverChain\r\n     */\r\n    toArray(resway = ResoveWay.all): IResolver[] {\r\n        if (resway & ResoveWay.nodes) {\r\n            return [<IResolver>this.container].concat(this.resolvers);\r\n        } else if (resway & ResoveWay.current) {\r\n            return [this.container];\r\n        } else if (resway & ResoveWay.traverse) {\r\n            return this.resolvers;\r\n        }\r\n        return [];\r\n    }\r\n\r\n    forEach(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean): void | boolean {\r\n        if (this.container.forEach(callbackfn) === false) {\r\n            return false;\r\n        }\r\n        return !this.resolvers.some((r: IResolverContainer) => {\r\n            if (isFunction(r.forEach)) {\r\n                return r.forEach(callbackfn) === false;\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * iterator all resolvers.\r\n     *\r\n     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void} callbackfn\r\n     * @memberof ResolverChain\r\n     */\r\n    iterator(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void, resway = ResoveWay.all): void | boolean {\r\n        if (resway & ResoveWay.current) {\r\n            if (this.container.forEach(callbackfn) === false) {\r\n                return false;\r\n            }\r\n        }\r\n        if (resway & ResoveWay.traverse) {\r\n            if (this.resolvers.some((r: IResolverContainer) => {\r\n                if (isFunction(r.forEach)) {\r\n                    return r.forEach(callbackfn) === false;\r\n                }\r\n                return false;\r\n            })) {\r\n                return false;\r\n            }\r\n        }\r\n        if (this.container.parent && (resway & ResoveWay.bubble)) {\r\n            return this.container.parent.iterator(callbackfn, resway);\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ResolverChain\",\"params\":{\"constructor\":[\"container\"],\"next\":[\"resolver\"],\"hasResolver\":[\"resolver\"],\"resolve\":[\"token\",\"resway\",\"providers\"],\"unregister\":[\"token\",\"resway\"],\"getTokenImpl\":[\"token\",\"resway\"],\"has\":[\"token\",\"aliasOrway\"],\"toArray\":[\"resway\"],\"forEach\":[\"callbackfn\"],\"iterator\":[\"callbackfn\",\"resway\"]}};\n                        }\n                   }\r\n"]}