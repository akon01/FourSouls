"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@ts-ioc/core");
const Advice_1 = require("./decorators/Advice");
const NonePointcut_1 = require("./decorators/NonePointcut");
const IAdvisor_1 = require("./IAdvisor");
/**
 * for global aop advisor.
 *
 * @export
 * @class Advisor
 */
let Advisor = class Advisor {
    constructor() {
        this.aspects = new Map();
        this.aspectIocs = new Map();
        this.advices = new Map();
    }
    /**
     * set advices.
     *
     * @param {string} key
     * @param {Advices} advices
     * @memberof Advisor
     */
    setAdvices(key, advices) {
        if (!this.advices.has(key)) {
            this.advices.set(key, advices);
        }
    }
    /**
     * get advices.
     *
     * @param {string} key
     * @returns
     * @memberof Advisor
     */
    getAdvices(key) {
        if (!this.advices.has(key)) {
            return null;
        }
        return this.advices.get(key);
    }
    /**
     * has register advices or not.
     *
     * @param {Type<any>} targetType
     * @returns {boolean}
     * @memberof Advisor
     */
    hasRegisterAdvices(targetType) {
        let methods = core_1.lang.keys(Object.getOwnPropertyDescriptors(targetType.prototype));
        let className = core_1.lang.getClassName(targetType);
        return methods.some(m => this.advices.has(`${className}.${m}`));
    }
    /**
     * add aspect.
     *
     * @param {Type<any>} aspect
     * @param {IContainer} raiseContainer
     * @memberof Advisor
     */
    add(aspect, raiseContainer) {
        if (!this.aspects.has(aspect)) {
            let metas = core_1.getOwnMethodMetadata(Advice_1.Advice, aspect);
            this.aspects.set(aspect, metas);
            this.aspectIocs.set(aspect, raiseContainer);
        }
    }
    getContainer(aspect, defaultContainer) {
        if (this.aspectIocs.has(aspect)) {
            return this.aspectIocs.get(aspect) || defaultContainer;
        }
        return defaultContainer;
    }
    /**
     * resolve aspect.
     *
     * @template T
     * @param {Type<T>} aspect
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Advisor
     */
    resolve(aspect, ...providers) {
        if (this.aspectIocs.has(aspect)) {
            return this.aspectIocs.get(aspect).resolve(aspect, ...providers);
        }
        return null;
    }
    static getClassAnnations() {
        return { "name": "Advisor", "params": { "constructor": [], "setAdvices": ["key", "advices"], "getAdvices": ["key"], "hasRegisterAdvices": ["targetType"], "add": ["aspect", "raiseContainer"], "getContainer": ["aspect", "defaultContainer"], "resolve": ["aspect", "providers"] } };
    }
};
Advisor = tslib_1.__decorate([
    NonePointcut_1.NonePointcut(),
    core_1.Singleton(IAdvisor_1.AdvisorToken),
    tslib_1.__metadata("design:paramtypes", [])
], Advisor);
exports.Advisor = Advisor;

//# sourceMappingURL=sourcemaps/Advisor.js.map
