"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
/**
 * default module loader.
 *
 * @export
 * @class DefaultModuleLoader
 * @implements {IModuleLoader}
 */
class DefaultModuleLoader {
    constructor() {
    }
    getLoader() {
        if (!this._loader) {
            this._loader = this.createLoader();
        }
        return this._loader;
    }
    /**
     * load module.
     *
     * @param {...LoadType[]} modules
     * @returns {Promise<Modules[]>}
     * @memberof DefaultModuleLoader
     */
    load(modules) {
        if (modules.length) {
            return Promise.all(modules.map(mdty => {
                if (utils_1.isString(mdty)) {
                    return this.isFile(mdty) ? this.loadFile(mdty) : this.loadModule(mdty);
                }
                else if (utils_1.isObject(mdty) && (mdty['modules'] || mdty['files'])) {
                    return this.loadPathModule(mdty);
                }
                else {
                    return mdty ? [mdty] : [];
                }
            }))
                .then(allms => {
                let rmodules = [];
                allms.forEach(ms => {
                    rmodules = rmodules.concat(ms);
                });
                return rmodules;
            });
        }
        else {
            return Promise.resolve([]);
        }
    }
    /**
     * load types from module.
     *
     * @param {...LoadType[]} modules
     * @returns {Promise<Type<any>[]>}
     * @memberof IContainerBuilder
     */
    loadTypes(modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let mdls = yield this.load(modules);
            return this.getTypes(mdls);
        });
    }
    /**
     * get all class type in modules.
     *
     * @param {Modules[]} modules
     * @param {...Express<Type<any>, boolean>[]} filters
     * @returns {Type<any>[]}
     * @memberof DefaultModuleLoader
     */
    getTypes(modules) {
        let regModules = [];
        modules.forEach(m => {
            let types = this.getContentTypes(m);
            regModules.push(types);
        });
        return regModules;
    }
    loadFile(files, basePath) {
        let loader = this.getLoader();
        let fRes;
        if (utils_1.isArray(files)) {
            fRes = Promise.all(files.map(f => loader(f)))
                .then(allms => {
                let rms = [];
                allms.forEach(ms => {
                    rms = rms.concat(ms);
                });
                return rms;
            });
        }
        else {
            fRes = loader(files);
        }
        return fRes.then(ms => ms.filter(it => !!it));
    }
    isFile(str) {
        return str && /\/((\w|%|\.))+\.\w+$/.test(str.replace(/\\\\/gi, '/'));
    }
    loadModule(moduleName) {
        let loader = this.getLoader();
        return loader(moduleName).then(ms => ms.filter(it => !!it));
    }
    loadPathModule(pmd) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let modules = [];
            if (pmd.files) {
                yield this.loadFile(pmd.files, pmd.basePath)
                    .then(allmoduls => {
                    allmoduls.forEach(ms => {
                        modules = modules.concat(ms);
                    });
                    return modules;
                });
            }
            if (pmd.modules) {
                yield Promise.all(pmd.modules.map(nmd => {
                    return utils_1.isString(nmd) ? this.loadModule(nmd) : nmd;
                })).then(ms => {
                    modules = modules.concat(ms);
                    return modules;
                });
            }
            return modules;
        });
    }
    createLoader() {
        if (typeof require !== 'undefined') {
            return (modulepath) => {
                return new Promise((resolve, reject) => {
                    require(modulepath, (mud) => {
                        resolve(mud);
                    }, err => {
                        reject(err);
                    });
                });
            };
        }
        else {
            throw new Error('has not module loader');
        }
    }
    getContentTypes(regModule) {
        let regModules = [];
        if (utils_1.isClass(regModule)) {
            regModules.push(regModule);
        }
        else if (regModule) {
            let rmodules = regModule['exports'] ? regModule['exports'] : regModule;
            for (let p in rmodules) {
                let type = rmodules[p];
                if (utils_1.isClass(type)) {
                    regModules.push(type);
                }
            }
        }
        return regModules;
    }
    static getClassAnnations() {
        return { "name": "DefaultModuleLoader", "params": { "constructor": [], "getLoader": [], "load": ["modules"], "loadTypes": ["modules"], "getTypes": ["modules"], "loadFile": ["files", "basePath"], "isFile": ["str"], "loadModule": ["moduleName"], "loadPathModule": ["pmd"], "createLoader": [], "getContentTypes": ["regModule"] } };
    }
}
exports.DefaultModuleLoader = DefaultModuleLoader;

//# sourceMappingURL=../sourcemaps/injectors/DefaultModuleLoader.js.map
