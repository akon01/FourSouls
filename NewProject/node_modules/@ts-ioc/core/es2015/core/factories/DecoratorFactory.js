"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const DecoratorType_1 = require("./DecoratorType");
const ArgsIterator_1 = require("./ArgsIterator");
const utils_1 = require("../../utils");
exports.ParamerterName = 'paramerter_names';
/**
 * create dectorator for class params props methods.
 *
 * @export
 * @template T
 * @param {string} name
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {*}
 */
function createDecorator(name, adapter, metadataExtends) {
    let metaName = `@${name}`;
    let factory = (...args) => {
        let metadata = null;
        if (args.length < 1) {
            return (...args) => {
                return storeMetadata(name, metaName, args, metadata, metadataExtends);
            };
        }
        metadata = argsToMetadata(args, adapter);
        if (metadata) {
            return (...args) => {
                return storeMetadata(name, metaName, args, metadata, metadataExtends);
            };
        }
        else {
            if (args.length === 1) {
                if (!utils_1.isClass(args[0])) {
                    return (...args) => {
                        return storeMetadata(name, metaName, args, metadata, metadataExtends);
                    };
                }
            }
        }
        return storeMetadata(name, metaName, args, metadata, metadataExtends);
    };
    factory.toString = () => metaName;
    factory.decoratorType = DecoratorType_1.DecoratorType.All;
    return factory;
}
exports.createDecorator = createDecorator;
function argsToMetadata(args, adapter) {
    let metadata = null;
    if (args.length) {
        if (adapter) {
            let iterator = new ArgsIterator_1.ArgsIterator(args);
            adapter(iterator);
            metadata = iterator.getMetadata();
        }
        else if (args.length === 1 && utils_1.isMetadataObject(args[0])) {
            metadata = args[0];
        }
    }
    return metadata;
}
function storeMetadata(name, metaName, args, metadata, metadataExtends) {
    let target;
    switch (args.length) {
        case 1:
            target = args[0];
            if (utils_1.isClass(target) || utils_1.isAbstractClass(target)) {
                setTypeMetadata(name, metaName, target, metadata, metadataExtends);
                return target;
            }
            break;
        case 2:
            target = args[0];
            let propertyKey = args[1];
            setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);
            break;
        case 3:
            if (utils_1.isNumber(args[2])) {
                target = args[0];
                let propertyKey = args[1];
                let parameterIndex = args[2];
                setParamMetadata(name, metaName, target, propertyKey, parameterIndex, metadata, metadataExtends);
            }
            else if (utils_1.isUndefined(args[2])) {
                target = args[0];
                let propertyKey = args[1];
                setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);
            }
            else {
                target = args[0];
                let propertyKey = args[1];
                let descriptor = args[2];
                setMethodMetadata(name, metaName, target, propertyKey, descriptor, metadata, metadataExtends);
                return descriptor;
            }
            break;
        default:
            throw new Error(`Invalid @${name} Decorator declaration.`);
    }
}
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getClassDecorators(target) {
    return Reflect.getOwnMetadataKeys(target)
        .filter(d => {
        if (!(d && utils_1.isString(d))) {
            return false;
        }
        if (!/^@/.test(d)) {
            return false;
        }
        return !/__\w+$/.test(d);
    });
}
exports.getClassDecorators = getClassDecorators;
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getMethodDecorators(target) {
    return Reflect.getMetadataKeys(target)
        .filter(d => d && utils_1.isString(d) && /^@\S+__method$/.test(d))
        .map(d => d.replace(/__method$/ig, ''));
}
exports.getMethodDecorators = getMethodDecorators;
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getPropDecorators(target) {
    return Reflect.getMetadataKeys(target)
        .filter(d => d && utils_1.isString(d) && /^@\S+__props$/.test(d))
        .map(d => d.replace(/__props$/ig, ''));
}
exports.getPropDecorators = getPropDecorators;
/**
 * get type decorators of class.
 *
 * @export
 * @param {(Type<any> | AbstractType<any>)} target
 * @returns {string[]}
 */
function getParamDecorators(target, propertyKey) {
    return ((propertyKey && propertyKey !== 'constructor') ? Reflect.getMetadataKeys(target, propertyKey) : Reflect.getOwnMetadataKeys(utils_1.lang.getClass(target)) || [])
        .filter(d => d && utils_1.isString(d) && /^@\S+__params$/.test(d))
        .map((d) => d.replace(/__params$/ig, ''));
}
exports.getParamDecorators = getParamDecorators;
/**
 * get all class metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns
 */
function getTypeMetadata(decorator, target) {
    let annotations = Reflect.getOwnMetadata(utils_1.isFunction(decorator) ? decorator.toString() : decorator, target);
    annotations = utils_1.isArray(annotations) ? annotations : [];
    return annotations;
}
exports.getTypeMetadata = getTypeMetadata;
/**
 * get own class metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns
 */
function getOwnTypeMetadata(decorator, target) {
    let annotations = Reflect.getOwnMetadata(utils_1.isFunction(decorator) ? decorator.toString() : decorator, target);
    annotations = utils_1.isArray(annotations) ? annotations : [];
    return annotations;
}
exports.getOwnTypeMetadata = getOwnTypeMetadata;
/**
 * has class decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @returns {boolean}
 */
function hasClassMetadata(decorator, target) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasMetadata(name, target);
}
exports.hasClassMetadata = hasClassMetadata;
/**
 * has own class decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @returns {boolean}
 */
function hasOwnClassMetadata(decorator, target) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasOwnMetadata(name, target);
}
exports.hasOwnClassMetadata = hasOwnClassMetadata;
function setTypeMetadata(name, metaName, target, metadata, metadataExtends) {
    let annotations = getOwnTypeMetadata(metaName, target).slice(0);
    let typeMetadata = (metadata || {});
    if (!typeMetadata.type) {
        typeMetadata.type = target;
    }
    typeMetadata.decorator = name;
    if (metadataExtends) {
        metadataExtends(typeMetadata);
    }
    annotations.unshift(typeMetadata);
    setParamerterNames(target);
    Reflect.defineMetadata(metaName, annotations, target);
}
let methodMetadataExt = '__method';
/**
 * get all method metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getMethodMetadata(decorator, target) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    let meta = Reflect.getMetadata(name + methodMetadataExt, target);
    if (!meta || utils_1.isArray(meta) || !utils_1.lang.hasField(meta)) {
        meta = Reflect.getMetadata(name + methodMetadataExt, target.constructor);
    }
    return utils_1.isArray(meta) ? {} : (meta || {});
}
exports.getMethodMetadata = getMethodMetadata;
/**
 * get own method metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getOwnMethodMetadata(decorator, target) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    let meta = Reflect.getOwnMetadata(name + methodMetadataExt, target);
    if (!meta || utils_1.isArray(meta) || !utils_1.lang.hasField(meta)) {
        meta = Reflect.getOwnMetadata(name + methodMetadataExt, target.constructor);
    }
    return utils_1.isArray(meta) ? {} : (meta || {});
}
exports.getOwnMethodMetadata = getOwnMethodMetadata;
/**
 * has own method decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
function hasOwnMethodMetadata(decorator, target, propertyKey) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    if (propertyKey) {
        let meta = getOwnMethodMetadata(name, target);
        return meta && meta.hasOwnProperty(propertyKey);
    }
    else {
        return Reflect.hasOwnMetadata(name + methodMetadataExt, target);
    }
}
exports.hasOwnMethodMetadata = hasOwnMethodMetadata;
/**
 * has method decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
function hasMethodMetadata(decorator, target, propertyKey) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    if (propertyKey) {
        let meta = getMethodMetadata(name, target);
        return meta && meta.hasOwnProperty(propertyKey);
    }
    else {
        return Reflect.hasMetadata(name + methodMetadataExt, target);
    }
}
exports.hasMethodMetadata = hasMethodMetadata;
function setMethodMetadata(name, metaName, target, propertyKey, descriptor, metadata, metadataExtends) {
    let meta = utils_1.lang.assign({}, getOwnMethodMetadata(metaName, target));
    meta[propertyKey] = meta[propertyKey] || [];
    let methodMeadata = (metadata || {});
    methodMeadata.decorator = name;
    methodMeadata.propertyKey = propertyKey;
    // methodMeadata.descriptor = descriptor;
    if (metadataExtends) {
        metadataExtends(methodMeadata);
    }
    meta[propertyKey].unshift(methodMeadata);
    Reflect.defineMetadata(metaName + methodMetadataExt, meta, target.constructor);
}
let propertyMetadataExt = '__props';
/**
 * get all property metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getPropertyMetadata(decorator, target) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    let meta = Reflect.getMetadata(name + propertyMetadataExt, target);
    if (!meta || utils_1.isArray(meta) || !utils_1.lang.hasField(meta)) {
        meta = Reflect.getMetadata(name + propertyMetadataExt, target.constructor);
    }
    return utils_1.isArray(meta) ? {} : (meta || {});
}
exports.getPropertyMetadata = getPropertyMetadata;
/**
 * get own property metadata of one specail decorator in target type.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @returns {ObjectMap<T[]>}
 */
function getOwnPropertyMetadata(decorator, target) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    let meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target);
    if (!meta || utils_1.isArray(meta) || !utils_1.lang.hasField(meta)) {
        meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target.constructor);
    }
    return utils_1.isArray(meta) ? {} : (meta || {});
}
exports.getOwnPropertyMetadata = getOwnPropertyMetadata;
/**
 * has property decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {Type<any>} target
 * @param {(string | symbol)} [propertyKey]
 * @returns {boolean}
 */
function hasPropertyMetadata(decorator, target, propertyKey) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    if (propertyKey) {
        let meta = getPropertyMetadata(name, target);
        return meta && meta.hasOwnProperty(propertyKey);
    }
    else {
        return Reflect.hasMetadata(name + propertyMetadataExt, target);
    }
}
exports.hasPropertyMetadata = hasPropertyMetadata;
function setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends) {
    let meta = utils_1.lang.assign({}, getOwnPropertyMetadata(metaName, target));
    let propmetadata = (metadata || {});
    propmetadata.propertyKey = propertyKey;
    propmetadata.decorator = name;
    if (!propmetadata.type) {
        let t = Reflect.getMetadata('design:type', target, propertyKey);
        if (!t) {
            // Needed to support react native inheritance
            t = Reflect.getMetadata('design:type', target.constructor, propertyKey);
        }
        propmetadata.type = t;
    }
    if (metadataExtends) {
        metadataExtends(propmetadata);
    }
    if (!meta[propertyKey] || !utils_1.isArray(meta[propertyKey])) {
        meta[propertyKey] = [];
    }
    meta[propertyKey].unshift(propmetadata);
    Reflect.defineMetadata(metaName + propertyMetadataExt, meta, target.constructor);
}
let paramsMetadataExt = '__params';
/**
 * get paramerter metadata of one specail decorator in target method.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {T[][]}
 */
function getParamMetadata(decorator, target, propertyKey) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    let parameters = Reflect.getMetadata(name + paramsMetadataExt, target, propertyKey);
    parameters = utils_1.isArray(parameters) ? parameters : [];
    return parameters;
}
exports.getParamMetadata = getParamMetadata;
/**
 * get own paramerter metadata of one specail decorator in target method.
 *
 * @export
 * @template T
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {T[][]}
 */
function getOwnParamMetadata(decorator, target, propertyKey) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    let parameters = Reflect.getOwnMetadata(name + paramsMetadataExt, target, propertyKey);
    parameters = utils_1.isArray(parameters) ? parameters : [];
    return parameters;
}
exports.getOwnParamMetadata = getOwnParamMetadata;
/**
 * has param decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {boolean}
 */
function hasParamMetadata(decorator, target, propertyKey) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasMetadata(name + paramsMetadataExt, target, propertyKey);
}
exports.hasParamMetadata = hasParamMetadata;
/**
 * has param decorator metadata.
 *
 * @export
 * @param {(string | Function)} decorator
 * @param {(Type<any> | object)} target
 * @param {(string | symbol)} propertyKey
 * @returns {boolean}
 */
function hasOwnParamMetadata(decorator, target, propertyKey) {
    let name = utils_1.isFunction(decorator) ? decorator.toString() : decorator;
    return Reflect.hasOwnMetadata(name + paramsMetadataExt, target, propertyKey);
}
exports.hasOwnParamMetadata = hasOwnParamMetadata;
function setParamMetadata(name, metaName, target, propertyKey, parameterIndex, metadata, metadataExtends) {
    let parameters = getOwnParamMetadata(metaName, target, propertyKey).slice(0);
    // there might be gaps if some in between parameters do not have annotations.
    // we pad with nulls.
    while (parameters.length <= parameterIndex) {
        parameters.push(null);
    }
    parameters[parameterIndex] = parameters[parameterIndex] || [];
    let paramMeadata = (metadata || {});
    if (!paramMeadata.type) {
        let t = Reflect.getOwnMetadata('design:type', target, propertyKey);
        if (!t) {
            // Needed to support react native inheritance
            t = Reflect.getOwnMetadata('design:type', target.constructor, propertyKey);
        }
        paramMeadata.type = t;
    }
    paramMeadata.propertyKey = propertyKey;
    paramMeadata.decorator = name;
    paramMeadata.index = parameterIndex;
    if (metadataExtends) {
        metadataExtends(paramMeadata);
    }
    parameters[parameterIndex].unshift(paramMeadata);
    Reflect.defineMetadata(metaName + paramsMetadataExt, parameters, target, propertyKey);
}
function getParamerterNames(target) {
    let meta = Reflect.getMetadata(exports.ParamerterName, target);
    if (!meta || utils_1.isArray(meta) || !utils_1.lang.hasField(meta)) {
        meta = Reflect.getMetadata(exports.ParamerterName, target.constructor);
    }
    return utils_1.isArray(meta) ? {} : (meta || {});
}
exports.getParamerterNames = getParamerterNames;
function getOwnParamerterNames(target) {
    let meta = Reflect.getOwnMetadata(exports.ParamerterName, target);
    if (!meta || utils_1.isArray(meta) || !utils_1.lang.hasField(meta)) {
        meta = Reflect.getOwnMetadata(exports.ParamerterName, target.constructor);
    }
    return utils_1.isArray(meta) ? {} : (meta || {});
}
exports.getOwnParamerterNames = getOwnParamerterNames;
function setParamerterNames(target) {
    let meta = utils_1.lang.assign({}, getParamerterNames(target));
    let descriptors = Object.getOwnPropertyDescriptors(target.prototype);
    let isUglify = /^[a-z]/.test(target.name);
    let anName = '';
    let classAnnations = utils_1.lang.getClassAnnations(target);
    if (classAnnations && classAnnations.params) {
        anName = classAnnations.name;
        meta = utils_1.lang.assign(meta, classAnnations.params);
    }
    if (!isUglify && target.name !== anName) {
        utils_1.lang.forIn(descriptors, (item, name) => {
            if (name !== 'constructor') {
                if (item.value) {
                    meta[name] = getParamNames(item.value);
                }
                if (item.set) {
                    meta[name] = getParamNames(item.set);
                }
            }
        });
        meta['constructor'] = getParamNames(target.prototype.constructor);
    }
    Reflect.defineMetadata(exports.ParamerterName, meta, target);
}
exports.setParamerterNames = setParamerterNames;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;
function getParamNames(func) {
    if (!utils_1.isFunction(func)) {
        return [];
    }
    let fnStr = func.toString().replace(STRIP_COMMENTS, '');
    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
    if (result === null) {
        result = [];
    }
    return result;
}

//# sourceMappingURL=../../sourcemaps/core/factories/DecoratorFactory.js.map
