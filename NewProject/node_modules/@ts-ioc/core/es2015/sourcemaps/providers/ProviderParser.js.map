{"version":3,"sources":["providers/ProviderParser.ts"],"names":[],"mappings":"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","file":"../../providers/ProviderParser.js","sourcesContent":["import { ParamProviders } from './types';\r\nimport {\r\n    isClass, isArray, isFunction, isNumber, isString,\r\n    isUndefined, isNull, isToken, isBaseObject, lang\r\n} from '../utils';\r\nimport { IProviderParser } from './IProviderParser';\r\nimport { IContainer } from '../IContainer';\r\nimport { ProviderMap, isProviderMap, ProviderMapToken } from './ProviderMap';\r\nimport { Provider, ParamProvider } from './Provider';\r\n\r\n/**\r\n * provider matcher. use to find custome providers in resolve.\r\n *\r\n * note: object map provider can not resolve token.\r\n *\r\n * @export\r\n * @class ProviderMatcher\r\n * @implements {IProviderMatcher}\r\n */\r\nexport class ProviderParser implements IProviderParser {\r\n\r\n    constructor(private container: IContainer) {\r\n\r\n    }\r\n\r\n    parse(...providers: ParamProviders[]): ProviderMap {\r\n        if (providers.length === 1 && isProviderMap(providers[0])) {\r\n            return providers[0] as ProviderMap;\r\n        }\r\n        let map = this.container.resolve(ProviderMapToken);\r\n        providers.forEach((p, index) => {\r\n            if (isUndefined(p) || isNull(p)) {\r\n                return;\r\n            }\r\n            if (isProviderMap(p)) {\r\n                map.copy(p);\r\n            } else if (p instanceof Provider) {\r\n                if (p instanceof ParamProvider) {\r\n                    if (!p.type && isNumber(p.index)) {\r\n                        map.add(p.index, (...providers: ParamProviders[]) => p.resolve(this.container, ...providers));\r\n                    } else {\r\n                        map.add(p.type, (...providers: ParamProviders[]) => p.resolve(this.container, ...providers));\r\n                    }\r\n\r\n                } else {\r\n                    map.add(p.type, (...providers: ParamProviders[]) => p.resolve(this.container, ...providers));\r\n                }\r\n            } else if (isClass(p)) {\r\n                if (!this.container.has(p)) {\r\n                    this.container.register(p);\r\n                }\r\n                map.add(p, p);\r\n            } else if (isBaseObject(p)) {\r\n                let pr: any = p;\r\n                let isobjMap = false;\r\n                if (isToken(pr.provide)) {\r\n                    if (isArray(pr.deps) && pr.deps.length) {\r\n                        pr.deps.forEach(d => {\r\n                            if (isClass(d) && !this.container.has(d)) {\r\n                                this.container.register(d);\r\n                            }\r\n                        });\r\n                    }\r\n                    if (!isUndefined(pr.useValue)) {\r\n                        map.add(pr.provide, () => pr.useValue);\r\n                    } else if (isClass(pr.useClass)) {\r\n                        if (!this.container.has(pr.useClass)) {\r\n                            this.container.register(pr.useClass);\r\n                        }\r\n                        map.add(pr.provide, pr.useClass);\r\n                    } else if (isFunction(pr.useFactory)) {\r\n                        map.add(pr.provide, (...providers) => {\r\n                            let args = [];\r\n                            if (isArray(pr.deps) && pr.deps.length) {\r\n                                args = pr.deps.map(d => {\r\n                                    if (isToken(d)) {\r\n                                        return this.container.resolve(d, ...providers);\r\n                                    } else {\r\n                                        return d;\r\n                                    }\r\n                                });\r\n                            }\r\n                            return pr.useFactory.apply(pr, args);\r\n                        });\r\n                    } else if (isToken(pr.useExisting)) {\r\n                        map.add(pr.provide, (...providers) => this.container.resolve(pr.useExisting, ...providers));\r\n                    } else {\r\n                        isobjMap = true;\r\n                    }\r\n                } else {\r\n                    isobjMap = true;\r\n                }\r\n\r\n                if (isobjMap) {\r\n                    lang.forIn<any>(p, (val, name) => {\r\n                        if (name && isString(name)) {\r\n                            // object map can not resolve token. set all fileld as value factory.\r\n                            map.add(name, () => val);\r\n                        }\r\n                    });\r\n                }\r\n\r\n            } else if (isFunction(p)) {\r\n                map.add(name, () => p);\r\n            }\r\n        });\r\n\r\n        return map;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ProviderParser\",\"params\":{\"constructor\":[\"container\"],\"parse\":[\"providers\"]}};\n                        }\n                   }\r\n\r\nexport function isProvider(target: any): boolean {\r\n    return isProviderMap(target) || isBaseObject(target) || target instanceof Provider;\r\n}\r\n"]}