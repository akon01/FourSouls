"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ModuleInjector_1 = require("./ModuleInjector");
var utils_1 = require("../utils");
/**
 * Module Injector chain, base injector chain.
 *
 * @export
 * @class ModuleInjectorChain
 * @implements {IModuleInjectorChain}
 */
var ModuleInjectorChain = /** @class */ (function () {
    function ModuleInjectorChain() {
        this._injectors = [];
    }
    Object.defineProperty(ModuleInjectorChain.prototype, "injectors", {
        get: function () {
            return this._injectors;
        },
        enumerable: true,
        configurable: true
    });
    ModuleInjectorChain.prototype.first = function (injector) {
        if (this.isInjector(injector)) {
            this._injectors.unshift(injector);
        }
        return this;
    };
    ModuleInjectorChain.prototype.next = function (injector) {
        if (this.isInjector(injector)) {
            this._injectors.push(injector);
        }
        return this;
    };
    ModuleInjectorChain.prototype.isInjector = function (injector) {
        return injector instanceof ModuleInjector_1.ModuleInjector;
    };
    ModuleInjectorChain.prototype.inject = function (container, modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var types;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        types = [];
                        return [4 /*yield*/, utils_1.PromiseUtil.runInChain(this.injectors.map(function (jtor) {
                                return function (mds, next) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                    var ijRt;
                                    return tslib_1.__generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, jtor.inject(container, mds)];
                                            case 1:
                                                ijRt = _a.sent();
                                                if (ijRt.injected && ijRt.injected.length) {
                                                    types = types.concat(ijRt.injected);
                                                }
                                                if (ijRt.next && ijRt.next.length > 0) {
                                                    return [2 /*return*/, next()];
                                                }
                                                return [2 /*return*/];
                                        }
                                    });
                                }); };
                            }), modules)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, types];
                }
            });
        });
    };
    ModuleInjectorChain.prototype.syncInject = function (container, modules) {
        var types = [];
        var completed = false;
        this.injectors.some(function (jtor) {
            if (jtor instanceof ModuleInjector_1.ModuleInjector) {
                var result = jtor.syncInject(container, modules);
                types = types.concat(result.injected);
                completed = (!result.next || result.next.length < 1);
            }
            return completed;
        });
        return types;
    };
    ModuleInjectorChain.getClassAnnations = function () {
        return { "name": "ModuleInjectorChain", "params": { "constructor": [], "first": ["injector"], "next": ["injector"], "isInjector": ["injector"], "inject": ["container", "modules"], "syncInject": ["container", "modules"] } };
    };
    return ModuleInjectorChain;
}());
exports.ModuleInjectorChain = ModuleInjectorChain;

//# sourceMappingURL=../sourcemaps/injectors/ModuleInjectorChain.js.map
