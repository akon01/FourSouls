{"version":3,"sources":["core/factories/ClassDecoratorFactory.ts"],"names":[],"mappings":";;AAAA,4BAA0B;AAG1B,uDAAuF;AACvF,iDAAgD;AAChD,mDAAkD;AAClD,qCAAyF;AA0EzF;;;;;;;;;GASG;AACH,SAAgB,oBAAoB,CAA0B,IAAY,EAAE,OAAyB,EAAE,eAAoC;IAEvI,IAAI,YAAY,GAAG,CAAC,UAAC,IAAkB;QACnC,IAAI,OAAO,EAAE;YACT,OAAO,CAAC,IAAI,CAAC,CAAC;SACjB;QACD,IAAI,CAAC,IAAI,CAAI;YACT,KAAK,EAAE,UAAC,GAAG,IAAK,OAAA,GAAG,IAAI,CAAC,gBAAQ,CAAC,GAAG,CAAC,IAAI,gBAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAQ,CAAC,GAAG,CAAC,IAAI,GAAG,YAAY,2BAAY,CAAC,CAAC,EAAzF,CAAyF;YACzG,WAAW,EAAE,UAAC,QAAQ,EAAE,GAAG;gBACvB,QAAQ,CAAC,OAAO,GAAG,GAAG,CAAC;YAC3B,CAAC;SACJ,CAAC,CAAC;QAEH,IAAI,CAAC,IAAI,CAAI;YACT,KAAK,EAAE,UAAC,GAAG,IAAK,OAAA,gBAAQ,CAAC,GAAG,CAAC,EAAb,CAAa;YAC7B,WAAW,EAAE,UAAC,QAAQ,EAAE,GAAG;gBACvB,QAAQ,CAAC,KAAK,GAAG,GAAG,CAAC;YACzB,CAAC;SACJ,CAAC,CAAC;QAEH,IAAI,CAAC,IAAI,CAAI;YACT,KAAK,EAAE,UAAC,GAAG,IAAK,OAAA,iBAAS,CAAC,GAAG,CAAC,IAAI,gBAAQ,CAAC,GAAG,CAAC,IAAI,eAAO,CAAC,GAAG,CAAC,EAA/C,CAA+C;YAC/D,WAAW,EAAE,UAAC,QAAQ,EAAE,GAAG;gBACvB,IAAI,iBAAS,CAAC,GAAG,CAAC,EAAE;oBAChB,QAAQ,CAAC,SAAS,GAAG,GAAG,CAAC;iBAC5B;qBAAM,IAAI,gBAAQ,CAAC,GAAG,CAAC,EAAE;oBACtB,QAAQ,CAAC,OAAO,GAAG,GAAG,CAAC;iBAC1B;qBAAM,IAAI,eAAO,CAAC,GAAG,CAAC,EAAE;oBACrB,QAAQ,CAAC,IAAI,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC,OAAO,IAAI,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC,KAAK,EAAG,CAAC;iBACvG;YACL,CAAC;SACJ,CAAC,CAAC;QAEH,IAAI,CAAC,IAAI,CAAI;YACT,KAAK,EAAE,UAAC,GAAG,IAAK,OAAA,eAAO,CAAC,GAAG,CAAC,EAAZ,CAAY;YAC5B,WAAW,EAAE,UAAC,QAAQ,EAAE,GAAG;gBACvB,QAAQ,CAAC,OAAO,GAAG,GAAG,CAAC;YAC3B,CAAC;SACJ,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;IACH,IAAI,SAAS,GAAG,kCAAe,CAAI,IAAI,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;IACxE,SAAS,CAAC,aAAa,GAAG,6BAAa,CAAC,KAAK,CAAC;IAC9C,OAAO,SAAS,CAAC;AACrB,CAAC;AA3CD,oDA2CC","file":"../../../core/factories/ClassDecoratorFactory.js","sourcesContent":["import 'reflect-metadata';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { Type, Token } from '../../types';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { Registration } from '../../Registration';\r\nimport { isString, isSymbol, isObject, isNumber, isBoolean, isToken } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\n\r\n/**\r\n * Type decorator.\r\n *\r\n * @export\r\n * @interface ITypeDecorator\r\n * @template T\r\n */\r\nexport interface ITypeDecorator<T extends ClassMetadata> {\r\n    /**\r\n     * define class decorator setting with metadata map.\r\n     *\r\n     * @param {T} [metadata] metadata map.\r\n     */\r\n    (metadata?: T): ClassDecorator;\r\n    /**\r\n     * not allow abstract to decorator with out metadata.\r\n     */\r\n    (target: Type<any>): void;\r\n}\r\n\r\n/**\r\n * class decorator.\r\n *\r\n * @export\r\n * @interface IClassDecorator\r\n */\r\nexport interface IClassDecorator<T extends ClassMetadata> extends ITypeDecorator<T> {\r\n\r\n    /**\r\n     * define class decorator setting with params.\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias?: string): ClassDecorator;\r\n\r\n    /**\r\n     * define class decorator setting with params.\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     * @param {Token<any>} [refTarget]  define the class as service of target.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias: string, refTarget: Token<any>): ClassDecorator;\r\n\r\n    /**\r\n     * define class decorator setting with params.\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     * @param {boolean} [singlton] define this class as singlton.\r\n     * @param {Token<any>} [refTarget]  define the class as service of target.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias: string, singlton: boolean, refTarget: Token<any>): ClassDecorator;\r\n\r\n    /**\r\n     * define class decorator setting with params.\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     * @param {boolean} [singlton] define this class as singlton.\r\n     * @param {number} [cache]  define class cahce expris when is not singlton.\r\n     * @param {Token<any>} [refTarget]  define the class as service of target.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias: string, cache: number, refTarget: Token<any>): ClassDecorator;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * create class decorator\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {*}\r\n */\r\nexport function createClassDecorator<T extends ClassMetadata>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): IClassDecorator<T> {\r\n\r\n    let classAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            match: (arg) => arg && (isSymbol(arg) || isString(arg) || (isObject(arg) && arg instanceof Registration)),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provide = arg;\r\n            }\r\n        });\r\n\r\n        args.next<T>({\r\n            match: (arg) => isString(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.alias = arg;\r\n            }\r\n        });\r\n\r\n        args.next<T>({\r\n            match: (arg) => isBoolean(arg) || isNumber(arg) || isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                if (isBoolean(arg)) {\r\n                    metadata.singleton = arg;\r\n                } else if (isNumber(arg)) {\r\n                    metadata.expires = arg;\r\n                } else if (isToken(arg)) {\r\n                    metadata.refs = { target: arg, provide: metadata.provide || metadata.type, alias: metadata.alias  };\r\n                }\r\n            }\r\n        });\r\n\r\n        args.next<T>({\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.expires = arg;\r\n            }\r\n        });\r\n    });\r\n    let decorator = createDecorator<T>(name, classAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Class;\r\n    return decorator;\r\n}\r\n\r\n"]}