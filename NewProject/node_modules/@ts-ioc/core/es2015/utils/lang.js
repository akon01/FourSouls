"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typeCheck_1 = require("./typeCheck");
// use core-js in browser.
/**
 * map base.
 *
 * @export
 * @class MapBase
 * @template K
 * @template V
 */
class MapBase {
    constructor() {
        this.map = new Map();
    }
    get size() {
        return this.map.size;
    }
    clear() {
        this.map.clear();
    }
    delete(key) {
        return this.map.delete(key);
    }
    get(key) {
        return this.map.get(key);
    }
    has(key) {
        return this.map.has(key);
    }
    set(key, value) {
        this.map.set(key, value);
        return this;
    }
    keys() {
        return Array.from(this.map.keys());
    }
    values() {
        return Array.from(this.map.values());
    }
    static getClassAnnations() {
        return { "name": "MapBase", "params": { "constructor": [], "clear": [], "delete": ["key"], "get": ["key"], "has": ["key"], "set": ["key", "value"], "keys": [], "values": [] } };
    }
}
exports.MapBase = MapBase;
/**
 * map set  for tsioc old version.
 *
 * @export
 * @class MapSet
 * @template K
 * @template V
 */
class MapSet extends MapBase {
    constructor() {
        super();
    }
    forEach(callbackfn, thisArg) {
        this.map.forEach(callbackfn, thisArg);
    }
    static getClassAnnations() {
        return { "name": "MapSet", "params": { "constructor": [], "forEach": ["callbackfn", "thisArg"] } };
    }
}
exports.MapSet = MapSet;
/**
 * lang utils
 */
var lang;
(function (lang) {
    /**
     * assert param is right or not.
     *
     * @export
     * @param {*} param
     * @param {(string | Function)} msg
     */
    function assert(param, msg) {
        if (typeCheck_1.isNullOrUndefined(param)) {
            throw new Error(typeCheck_1.isFunction(msg) ? msg(param) : msg);
        }
    }
    lang.assert = assert;
    /**
     * check assert param invalid by express
     *
     * @export
     * @param {(boolean | (() => boolean))} express
     * @param {(string | Function)} msg
     */
    function assertExp(express, msg) {
        if (!(typeCheck_1.isFunction(express) ? express() : express)) {
            throw new Error(typeCheck_1.isFunction(msg) ? msg() : msg);
        }
    }
    lang.assertExp = assertExp;
    /**
     * get object keys.
     *
     * @param {*} target
     * @returns {string[]}
     */
    function keys(target) {
        if (typeCheck_1.isObject(target)) {
            if (typeCheck_1.isFunction(Object.keys)) {
                return Object.keys(target);
            }
        }
        return [];
    }
    lang.keys = keys;
    /**
     * values of target object.
     *
     * @export
     * @param {*} target
     * @returns {any[]}
     */
    function values(target) {
        if (typeCheck_1.isObject(target)) {
            if (typeCheck_1.isFunction(Object.values)) {
                return Object.values(target);
            }
            else {
                return keys(target).map(n => target[n]);
            }
        }
        return [];
    }
    lang.values = values;
    /**
     * assign
     *
     * @export
     * @template T
     * @param {T} target
     * @param {...any[]} source
     * @returns {T}
     */
    function assign(target, source1, source2, sources) {
        if (sources && sources.length) {
            sources.unshift(source2 || {});
            sources.unshift(source1 || {});
            return Object.assign(target, ...sources);
        }
        else if (source2) {
            return Object.assign(target, source1 || {}, source2);
        }
        else {
            return Object.assign(target, source1 || {});
        }
    }
    lang.assign = assign;
    /**
     * create an new object from target object omit some field.
     *
     * @export
     * @param {ObjectMap<any>} target
     * @param {...string[]} fields
     * @returns {*}
     */
    function omit(target, ...fields) {
        if (typeCheck_1.isObject(target)) {
            let result = {};
            keys(target).forEach(key => {
                if (fields.indexOf(key) < 0) {
                    result[key] = target[key];
                }
            });
            return result;
        }
        else {
            return target;
        }
    }
    lang.omit = omit;
    /**
     * object has field or not.
     *
     * @export
     * @param {ObjectMap<any>} target
     * @returns
     */
    function hasField(target) {
        return keys(target).length > 0;
    }
    lang.hasField = hasField;
    /**
     * for in opter for object or array.
     *
     * @export
     * @template T
     * @param {(ObjectMap<T> | T[])} target
     * @param {(item: T, idx?: number|string) => void|boolean} iterator
     */
    function forIn(target, iterator) {
        if (typeCheck_1.isArray(target)) {
            target.some((it, idx) => iterator(it, idx) === false);
        }
        else if (typeCheck_1.isObject(target)) {
            keys(target).some((key, idx) => iterator(target[key], key) === false);
        }
    }
    lang.forIn = forIn;
    /**
     * find
     *
     * @template T
     * @param {(ObjectMap<T> | T[])} target
     * @param {((item: T, idx?: number | string) => boolean)} express
     */
    function find(target, express) {
        let item;
        forIn(target, (it, idx) => {
            if (!item) {
                if (express(it, idx)) {
                    item = it;
                    return false;
                }
                return true;
            }
            else {
                return true;
            }
        });
    }
    lang.find = find;
    /**
     * first.
     *
     * @export
     * @template T
     * @param {T[]} list
     * @returns {T}
     */
    function first(list) {
        if (typeCheck_1.isArray(list) && list.length) {
            return list[0];
        }
        return null;
    }
    lang.first = first;
    /**
     * last.
     *
     * @export
     * @template T
     * @param {T[]} list
     * @returns {T}
     */
    function last(list) {
        if (typeCheck_1.isArray(list) && list.length) {
            return list[list.length - 1];
        }
        return null;
    }
    lang.last = last;
    /**
     * get class annations.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns
     */
    function getClassAnnations(target) {
        return typeCheck_1.isFunction(target.getClassAnnations) ? target.getClassAnnations() : target.classAnnations;
    }
    lang.getClassAnnations = getClassAnnations;
    /**
     * target has class annations or not.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {boolean}
     */
    function hasClassAnnations(target) {
        if (typeCheck_1.isFunction(target.getClassAnnations)) {
            return true;
        }
        return target.classAnnations && typeCheck_1.isString(target.classAnnations.name) && target.classAnnations.name.length > 0;
    }
    lang.hasClassAnnations = hasClassAnnations;
    /**
     * get calss of object.
     *
     * @export
     * @param {*} target
     * @returns {Type<any>}
     */
    function getClass(target) {
        if (typeCheck_1.isNullOrUndefined(target)) {
            return null;
        }
        if (typeCheck_1.isClass(target)) {
            return target;
        }
        return target.constructor || target.prototype.constructor;
    }
    lang.getClass = getClass;
    /**
     * get class name.
     *
     * @export
     * @param {AbstractType<any>} target
     * @returns {string}
     */
    function getClassName(target) {
        let classType = typeCheck_1.isFunction(target) ? target : getClass(target);
        if (!typeCheck_1.isFunction(classType)) {
            return '';
        }
        if (/^[a-z]$/.test(classType.name)) {
            let classAnnations = getClassAnnations(classType);
            return classAnnations ? classAnnations.name : classType.name;
        }
        return classType.name;
    }
    lang.getClassName = getClassName;
    /**
     * get target type parent class.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {ClassType<any>}
     */
    function getParentClass(target) {
        let p = Reflect.getPrototypeOf(target.prototype);
        return typeCheck_1.isClass(p) ? p : p.constructor;
    }
    lang.getParentClass = getParentClass;
    /**
     * get all parent class in chain.
     *
     * @export
     * @param {ClassType<any>} target
     * @returns {ClassType<any>[]}
     */
    function getClassChain(target) {
        let types = [];
        forInClassChain(target, type => {
            types.push(type);
        });
        return types;
    }
    lang.getClassChain = getClassChain;
    /**
     * iterate base classes of target in chain. return false will break iterate.
     *
     * @export
     * @param {Type<any>} target
     * @param {(token: Type<any>) => any} express
     */
    function forInClassChain(target, express) {
        while (typeCheck_1.isClassType(target) && target !== Object) {
            if (express(target) === false) {
                break;
            }
            target = getParentClass(target);
        }
    }
    lang.forInClassChain = forInClassChain;
    /**
     * target is extends class of baseClass or not.
     *
     * @export
     * @param {Token<any>} target
     * @param {(ClassType<any> | ((type: ClassType<any>) => boolean))} baseClass
     * @returns {boolean}
     */
    function isExtendsClass(target, baseClass) {
        let isExtnds = false;
        if (typeCheck_1.isClassType(target)) {
            forInClassChain(target, t => {
                if (typeCheck_1.isClassType(baseClass)) {
                    isExtnds = t === baseClass;
                }
                else {
                    isExtnds = baseClass(t);
                }
                return !isExtnds;
            });
        }
        return isExtnds;
    }
    lang.isExtendsClass = isExtendsClass;
})(lang = exports.lang || (exports.lang = {}));

//# sourceMappingURL=../sourcemaps/utils/lang.js.map
