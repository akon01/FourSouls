"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const NullComponent_1 = require("./NullComponent");
const utils_1 = require("../utils");
/**
 * generics composite
 *
 * @export
 * @class GComposite
 * @implements {GComponent<T>}
 * @template T
 */
class GComposite {
    constructor(name) {
        this.name = name;
        this.children = [];
    }
    add(node) {
        node.parent = this;
        this.children.push(node);
        return this;
    }
    remove(node) {
        let component;
        if (utils_1.isString(node)) {
            component = this.find(cmp => utils_1.isString(node) ? cmp.name === node : cmp.equals(node));
        }
        else if (node) {
            component = node;
        }
        else {
            component = this;
        }
        if (!component.parent) {
            return this;
        }
        else if (this.equals(component.parent)) {
            this.children.splice(this.children.indexOf(component), 1);
            component.parent = null;
            return this;
        }
        else {
            component.parent.remove(component);
            return null;
        }
    }
    find(express, mode) {
        let component;
        this.each(item => {
            if (component) {
                return false;
            }
            let isFinded = utils_1.isFunction(express) ? express(item) : express === (item);
            if (isFinded) {
                component = item;
                return false;
            }
            return true;
        }, mode);
        return (component || this.empty());
    }
    filter(express, mode) {
        let nodes = [];
        this.each(item => {
            if (express(item)) {
                nodes.push(item);
            }
        }, mode);
        return nodes;
    }
    each(iterate, mode) {
        mode = mode || types_1.Mode.traverse;
        let r;
        switch (mode) {
            case types_1.Mode.route:
                r = this.routeUp(iterate);
                break;
            case types_1.Mode.children:
                r = this.eachChildren(iterate);
                break;
            case types_1.Mode.traverse:
                r = this.trans(iterate);
                break;
            case types_1.Mode.traverseLast:
                r = this.transAfter(iterate);
                break;
            default:
                r = this.trans(iterate);
                break;
        }
        return r;
    }
    eachChildren(iterate) {
        (this.children || []).forEach(item => {
            return iterate(item);
        });
    }
    /**
     *do express work in routing.
     *
     *@param {Express<T, void | boolean>} express
     *
     *@memberOf IComponent
     */
    routeUp(iterate) {
        let curr = this;
        if (iterate(curr) === false) {
            return false;
        }
        ;
        if (this.parent && this.parent.routeUp) {
            return this.parent.routeUp(iterate);
        }
    }
    /**
     *translate all sub context to do express work.
     *
     *@param {Express<T, void | boolean>} express
     *
     *@memberOf IComponent
     */
    trans(express) {
        let curr = this;
        if (express(curr) === false) {
            return false;
        }
        let children = this.children || [];
        for (let i = 0; i < children.length; i++) {
            let result = children[i].trans(express);
            if (result === false) {
                return result;
            }
        }
        return true;
    }
    transAfter(express) {
        let children = this.children || [];
        for (let i = 0; i < children.length; i++) {
            let result = children[i].transAfter(express);
            if (result === false) {
                return false;
            }
        }
        let curr = this;
        if (express(curr) === false) {
            return false;
        }
        return true;
    }
    equals(node) {
        return this === node;
    }
    empty() {
        return NullComponent_1.NullNode;
    }
    isEmpty() {
        return this.equals(this.empty());
    }
    static getClassAnnations() {
        return { "name": "GComposite", "params": { "constructor": ["name"], "add": ["node"], "remove": ["node"], "find": ["express", "mode"], "filter": ["express", "mode"], "each": ["iterate", "mode"], "eachChildren": ["iterate"], "routeUp": ["iterate"], "trans": ["express"], "transAfter": ["express"], "equals": ["node"], "empty": [], "isEmpty": [] } };
    }
}
exports.GComposite = GComposite;

//# sourceMappingURL=../sourcemaps/components/GComposite.js.map
