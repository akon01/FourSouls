"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var IContainer_1 = require("../IContainer");
var InjectToken_1 = require("../InjectToken");
var providers_1 = require("../providers");
var utils_1 = require("../utils");
/**
 *  resolver chain token.
 */
exports.ResolverChainToken = new InjectToken_1.InjectToken('di_ResolverChain');
/**
 * resover chain.
 *
 * resove by setp.
 *
 * @export
 * @class ResolverChain
 * @implements {IResolver}
 */
var ResolverChain = /** @class */ (function () {
    function ResolverChain(container) {
        this.container = container;
        this.resolvers = [];
    }
    Object.defineProperty(ResolverChain.prototype, "size", {
        get: function () {
            return this.resolvers.length + 1;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * reigister next resolver.
     *
     * @param {IResolver} resolver
     * @memberof ResolverChain
     */
    ResolverChain.prototype.next = function (resolver) {
        if (!this.hasResolver(resolver)) {
            this.resolvers.push(resolver);
        }
    };
    /**
     * has resolver or not.
     *
     * @param {IResolver} resolver
     * @returns
     * @memberof ResolverChain
     */
    ResolverChain.prototype.hasResolver = function (resolver) {
        if (resolver === this.container) {
            return true;
        }
        return this.resolvers.indexOf(resolver) >= 0;
    };
    /**
     * resove token via registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof ResolverChain
     */
    ResolverChain.prototype.resolve = function (token, resway) {
        var providers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers[_i - 2] = arguments[_i];
        }
        var _a;
        var key = this.container.getTokenKey(token, utils_1.isString(resway) ? resway : null);
        var way;
        if (utils_1.isNumber(resway)) {
            way = resway;
        }
        else {
            if (resway) {
                providers.unshift(resway);
            }
            way = IContainer_1.ResoveWay.all;
        }
        var providerMap;
        if (providers.length) {
            if (providers.length === 1 && providers_1.isProviderMap(providers[0])) {
                providerMap = providers[0];
            }
            else {
                providerMap = (_a = this.container.getProviderParser()).parse.apply(_a, providers);
            }
        }
        if (providerMap && providerMap.has(token)) {
            return providerMap.resolve(token, providerMap);
        }
        if ((way & IContainer_1.ResoveWay.current) && this.container.hasRegister(key)) {
            return this.container.resolveValue(key, providerMap);
        }
        if ((way & IContainer_1.ResoveWay.traverse)) {
            var resolver = this.resolvers.find(function (r) { return r.has(key, IContainer_1.ResoveWay.nodes); });
            if (resolver) {
                return resolver.resolve(key, IContainer_1.ResoveWay.nodes, providerMap);
            }
        }
        if (this.container.parent && (way & IContainer_1.ResoveWay.bubble)) {
            return this.container.parent.resolve(key, resway, providerMap);
        }
        return null;
    };
    /**
     * unregister token in registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @memberof ResolverChain
     */
    ResolverChain.prototype.unregister = function (token, resway) {
        resway = resway || IContainer_1.ResoveWay.all;
        var tokenKey = this.container.getTokenKey(token);
        if (resway & IContainer_1.ResoveWay.current) {
            this.container.unregisterValue(tokenKey);
        }
        if (resway & IContainer_1.ResoveWay.traverse) {
            this.resolvers.forEach(function (r) {
                if (utils_1.isFunction(r.unregister)) {
                    r.unregister(tokenKey, IContainer_1.ResoveWay.nodes);
                }
            });
        }
        if ((resway & IContainer_1.ResoveWay.bubble) && this.container.parent) {
            this.container.parent.unregister(token, resway);
        }
        return this;
    };
    /**
     * get token implements class in the registered resolver chain.
     *
     * @template T
     * @param {Token<T>} token
     * @returns {Type<T>}
     * @memberof ResolverChain
     */
    ResolverChain.prototype.getTokenImpl = function (token, resway) {
        if (utils_1.isClass(token)) {
            return token;
        }
        resway = resway || IContainer_1.ResoveWay.nodes;
        var tokenKey = this.container.getTokenKey(token);
        var provider;
        if (resway & IContainer_1.ResoveWay.current) {
            provider = this.container.getTokenProvider(tokenKey);
        }
        if (!provider && (resway & IContainer_1.ResoveWay.traverse)) {
            this.resolvers.some(function (r) {
                if (!utils_1.isFunction(r.getTokenImpl)) {
                    return false;
                }
                provider = r.getTokenImpl(tokenKey, IContainer_1.ResoveWay.nodes);
                return !!provider;
            });
        }
        if (!provider && (resway & IContainer_1.ResoveWay.bubble) && this.container.parent) {
            provider = this.container.parent.getTokenImpl(token, resway);
        }
        return provider || null;
    };
    /**
     * has token or not in the registered resolver chain.
     *
     * @template T
     * @param {SymbolType<T>} token
     * @returns {boolean}
     * @memberof ResolverChain
     */
    ResolverChain.prototype.has = function (token, aliasOrway) {
        var key = this.container.getTokenKey(token, utils_1.isString(aliasOrway) ? aliasOrway : null);
        var resway = utils_1.isNumber(aliasOrway) ? aliasOrway : IContainer_1.ResoveWay.all;
        if ((resway & IContainer_1.ResoveWay.current) && this.container.hasRegister(key)) {
            return true;
        }
        if ((resway & IContainer_1.ResoveWay.traverse) && this.resolvers.some(function (r) { return r.has(key, IContainer_1.ResoveWay.nodes); })) {
            return true;
        }
        if ((resway & IContainer_1.ResoveWay.bubble) && this.container.parent) {
            return this.container.parent.has(token, resway);
        }
        return false;
    };
    /**
     * resolver chain to array.
     *
     * @returns {IResolver[]}
     * @memberof ResolverChain
     */
    ResolverChain.prototype.toArray = function (resway) {
        if (resway === void 0) { resway = IContainer_1.ResoveWay.all; }
        if (resway & IContainer_1.ResoveWay.nodes) {
            return [this.container].concat(this.resolvers);
        }
        else if (resway & IContainer_1.ResoveWay.current) {
            return [this.container];
        }
        else if (resway & IContainer_1.ResoveWay.traverse) {
            return this.resolvers;
        }
        return [];
    };
    ResolverChain.prototype.forEach = function (callbackfn) {
        if (this.container.forEach(callbackfn) === false) {
            return false;
        }
        return !this.resolvers.some(function (r) {
            if (utils_1.isFunction(r.forEach)) {
                return r.forEach(callbackfn) === false;
            }
            return false;
        });
    };
    /**
     * iterator all resolvers.
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void} callbackfn
     * @memberof ResolverChain
     */
    ResolverChain.prototype.iterator = function (callbackfn, resway) {
        if (resway === void 0) { resway = IContainer_1.ResoveWay.all; }
        if (resway & IContainer_1.ResoveWay.current) {
            if (this.container.forEach(callbackfn) === false) {
                return false;
            }
        }
        if (resway & IContainer_1.ResoveWay.traverse) {
            if (this.resolvers.some(function (r) {
                if (utils_1.isFunction(r.forEach)) {
                    return r.forEach(callbackfn) === false;
                }
                return false;
            })) {
                return false;
            }
        }
        if (this.container.parent && (resway & IContainer_1.ResoveWay.bubble)) {
            return this.container.parent.iterator(callbackfn, resway);
        }
    };
    ResolverChain.getClassAnnations = function () {
        return { "name": "ResolverChain", "params": { "constructor": ["container"], "next": ["resolver"], "hasResolver": ["resolver"], "resolve": ["token", "resway", "providers"], "unregister": ["token", "resway"], "getTokenImpl": ["token", "resway"], "has": ["token", "aliasOrway"], "toArray": ["resway"], "forEach": ["callbackfn"], "iterator": ["callbackfn", "resway"] } };
    };
    return ResolverChain;
}());
exports.ResolverChain = ResolverChain;

//# sourceMappingURL=../sourcemaps/resolves/ResolverChain.js.map
