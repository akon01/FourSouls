"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const IModuleInjector_1 = require("./IModuleInjector");
const utils_1 = require("../utils");
const IModuleValidate_1 = require("./IModuleValidate");
const core_1 = require("../core");
/**
 * base module injector. abstract class.
 *
 * @export
 * @abstract
 * @class BaseModuleInjector
 * @implements {IModuleInjector}
 */
let ModuleInjector = class ModuleInjector {
    /**
     *Creates an instance of BaseModuleInjector.
     * @param {IModuleValidate} [validate]
     * @param {boolean} [skipNext] skip next when has match module to injector.
     * @memberof BaseModuleInjector
     */
    constructor(validate, skipNext) {
        this.validate = validate;
        this.skipNext = skipNext;
    }
    inject(container, modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let types = (modules || []).filter(ty => this.valid(container, ty));
            if (types.length) {
                yield utils_1.PromiseUtil.step(types.map(ty => () => this.setup(container, ty)));
            }
            let next = this.getNext(modules, types);
            return { injected: types, next: next };
        });
    }
    syncInject(container, modules) {
        let types = (modules || []).filter(ty => this.valid(container, ty));
        if (types.length) {
            types.forEach(ty => {
                this.syncSetup(container, ty);
            });
        }
        let next = this.getNext(modules, types);
        return { injected: types, next: next };
    }
    valid(container, type) {
        if (!this.validate) {
            return true;
        }
        return this.validate.valid(type);
    }
    getNext(all, filtered) {
        if (filtered.length === 0) {
            return all;
        }
        if (this.skipNext) {
            return null;
        }
        if (filtered.length === all.length) {
            return null;
        }
        return all.filter(it => filtered.indexOf(it) < 0);
    }
    setup(container, type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            container.register(type);
        });
    }
    syncSetup(container, type) {
        container.register(type);
    }
    static getClassAnnations() {
        return { "name": "ModuleInjector", "params": { "constructor": ["validate", "skipNext"], "inject": ["container", "modules"], "syncInject": ["container", "modules"], "valid": ["container", "type"], "getNext": ["all", "filtered"], "setup": ["container", "type"], "syncSetup": ["container", "type"] } };
    }
};
ModuleInjector = tslib_1.__decorate([
    core_1.Injectable(IModuleInjector_1.ModuleInjectorToken),
    tslib_1.__param(0, core_1.Inject(IModuleValidate_1.ModuleValidateToken)),
    tslib_1.__metadata("design:paramtypes", [Object, Boolean])
], ModuleInjector);
exports.ModuleInjector = ModuleInjector;

//# sourceMappingURL=../sourcemaps/injectors/ModuleInjector.js.map
