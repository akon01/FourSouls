"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@ts-ioc/core");
const joinpoints_1 = require("../joinpoints");
const IAdvisorChain_1 = require("./IAdvisorChain");
const IAdvisorProceeding_1 = require("./IAdvisorProceeding");
const NonePointcut_1 = require("../decorators/NonePointcut");
/**
 * advisor chain.
 *
 * @export
 * @class AdvisorChain
 * @implements {IAdvisorChain}
 */
let AdvisorChain = class AdvisorChain {
    constructor(joinPoint) {
        this.joinPoint = joinPoint;
        this.actions = [];
    }
    /**
     * register next action.
     *
     * @param {Express<Joinpoint, any>} action
     * @memberof AdvisorChain
     */
    next(action) {
        this.actions.push(action);
    }
    /**
     * get recognizer of this advisor.
     *
     * @returns {IRecognizer}
     * @memberof AdvisorChain
     */
    getRecognizer() {
        return this.container.get(core_1.RecognizerToken, this.joinPoint.state);
    }
    /**
     * process the advices.
     *
     * @memberof AdvisorChain
     */
    process() {
        let alias = this.getRecognizer().recognize(this.joinPoint.returning);
        this.container.get(IAdvisorProceeding_1.AdvisorProceedingToken, alias)
            .proceeding(this.joinPoint, ...this.actions);
    }
    static getClassAnnations() {
        return { "name": "AdvisorChain", "params": { "constructor": ["joinPoint"], "next": ["action"], "getRecognizer": [], "process": [] } };
    }
};
tslib_1.__decorate([
    core_1.Inject(core_1.ContainerToken),
    tslib_1.__metadata("design:type", Object)
], AdvisorChain.prototype, "container", void 0);
AdvisorChain = tslib_1.__decorate([
    NonePointcut_1.NonePointcut(),
    core_1.Injectable(IAdvisorChain_1.AdvisorChainToken),
    tslib_1.__metadata("design:paramtypes", [joinpoints_1.Joinpoint])
], AdvisorChain);
exports.AdvisorChain = AdvisorChain;

//# sourceMappingURL=../sourcemaps/access/AdvisorChain.js.map
