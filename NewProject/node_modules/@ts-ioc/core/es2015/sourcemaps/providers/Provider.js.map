{"version":3,"sources":["providers/Provider.ts"],"names":[],"mappings":"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","file":"../../providers/Provider.js","sourcesContent":["import { Token, Express2, Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { isFunction, isObject, isUndefined } from '../utils';\r\nimport { ProviderTypes } from './types';\r\n\r\n/**\r\n * type provider.\r\n *\r\n * @export\r\n * @interface TypeProvider\r\n * @extends {Type<any>}\r\n */\r\nexport interface TypeProvider extends Type<any> {\r\n\r\n}\r\n\r\n/**\r\n * Provider interface.\r\n *\r\n * @export\r\n * @interface IProvider\r\n */\r\nexport interface IProvider {\r\n    /**\r\n     * this type provider to.\r\n     *\r\n     * @type {SymbolType<any>}\r\n     * @memberof Provider\r\n     */\r\n    provide: Token<any>;\r\n}\r\n\r\n\r\n/**\r\n * @usageNotes\r\n * ```\r\n * @Injectable()\r\n * class MyService {}\r\n *\r\n * const provider: ClassProvider = {provide: 'someToken', useClass: MyService};\r\n * ```\r\n *\r\n * @description\r\n * Configures the `Injector` to return an instance of `useClass` for a token.\r\n *\r\n */\r\nexport interface ClassProvider extends IProvider {\r\n    /**\r\n     * use class for provide.\r\n     *\r\n     * @type {Type<any>}\r\n     * @memberof ClassProvider\r\n     */\r\n    useClass: Type<any>;\r\n    /**\r\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\r\n     * used as arguments to the `useFactory` function.\r\n     */\r\n    deps?: any[];\r\n}\r\n\r\n/**\r\n * value provider.\r\n *\r\n * @usageNotes\r\n * ```\r\n * const provider: ClassProvider = {provide: 'someToken', useClass: MyService};\r\n * ```\r\n * @description\r\n * Configures the `Injector` to return an instance of `useValue` for a token.\r\n *\r\n * @export\r\n * @interface ValueProvider\r\n * @extends {IProvider}\r\n */\r\nexport interface ValueProvider extends IProvider {\r\n    /**\r\n     * use value for provide.\r\n     *\r\n     * @type {*}\r\n     * @memberof ValueProvider\r\n     */\r\n    useValue: any;\r\n}\r\n\r\n/**\r\n * @usageNotes\r\n * ```\r\n * function serviceFactory() { ... }\r\n *\r\n * const provider: FactoryProvider = {provide: 'someToken', useFactory: serviceFactory, deps: []};\r\n * ```\r\n *\r\n * @description\r\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\r\n *\r\n *\r\n */\r\nexport interface FactoryProvider extends IProvider {\r\n    /**\r\n    * A function to invoke to create a value for this `token`. The function is invoked with\r\n    * resolved values of `token`s in the `deps` field.\r\n    */\r\n    useFactory: Function;\r\n\r\n    /**\r\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\r\n     * used as arguments to the `useFactory` function.\r\n     */\r\n    deps?: any[];\r\n}\r\n\r\n/**\r\n * existing provider.\r\n *\r\n * @usageNotes\r\n * ```\r\n * const provider: ClassProvider = {provide: 'someToken', useExisting: 'registeredToken'};\r\n * ```\r\n * @export\r\n * @interface ExistingProvider\r\n * @extends {IProvider}\r\n */\r\nexport interface ExistingProvider extends IProvider {\r\n    /**\r\n     * use existing registered token for provide.\r\n     *\r\n     * @type {Token<any>}\r\n     * @memberof ExistingProvider\r\n     */\r\n    useExisting: Token<any>\r\n}\r\n\r\n/**\r\n * provider type.\r\n */\r\nexport type ProviderType =\r\n    TypeProvider | ValueProvider | ClassProvider | ExistingProvider | FactoryProvider | Provider;\r\n\r\n\r\n/**\r\n *  provider, to dynamic resovle instance of params in run time.\r\n *\r\n * @export\r\n * @class Provider\r\n */\r\nexport class Provider {\r\n    /**\r\n     * service provider is value or value factory.\r\n     *\r\n     * @memberof Provider\r\n     */\r\n    protected value?: any\r\n    /**\r\n     * service is instance of type.\r\n     *\r\n     * @type {Token<any>}\r\n     * @memberof Provider\r\n     */\r\n    type?: Token<any>;\r\n\r\n    constructor(type?: Token<any>, value?: any) {\r\n        this.type = type;\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * resolve provider value.\r\n     *\r\n     * @template T\r\n     * @param {IContainer} container\r\n     * @param {ProviderTypes[]} providers\r\n     * @returns {T}\r\n     * @memberof Provider\r\n     */\r\n    resolve<T>(container: IContainer, ...providers: ProviderTypes[]): T {\r\n        if (isUndefined(this.value)) {\r\n            return container.has(this.type) ? container.resolve(this.type, ...providers) : null;\r\n        } else {\r\n            return this.value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * create provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} type\r\n     * @param {(any)} value\r\n     * @returns Provider\r\n     * @memberof Provider\r\n     */\r\n    static create(type: Token<any>, value: any): Provider {\r\n        return new Provider(type, value);\r\n    }\r\n\r\n    /**\r\n     * create extends provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} token\r\n     * @param {(any)} value\r\n     * @param {Express2<any, ExtendsProvider, void>} [extendsTarget]\r\n     * @returns {ExtendsProvider}\r\n     * @memberof Provider\r\n     */\r\n    static createExtends(token: Token<any>, value: any, extendsTarget?: Express2<any, ExtendsProvider, void>): ExtendsProvider {\r\n        return new ExtendsProvider(token, value, extendsTarget);\r\n    }\r\n\r\n    /**\r\n     * create invoked provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} token\r\n     * @param {string} method\r\n     * @param {(any)} [value]\r\n     * @returns {InvokeProvider}\r\n     * @memberof Provider\r\n     */\r\n    static createInvoke(token: Token<any>, method: string, value?: any): InvokeProvider {\r\n        return new InvokeProvider(token, method, value);\r\n    }\r\n\r\n    /**\r\n     * create param provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} token\r\n     * @param {(any)} value\r\n     * @param {number} [index]\r\n     * @param {string} [method]\r\n     * @returns {ParamProvider}\r\n     * @memberof Provider\r\n     */\r\n    static createParam(token: Token<any>, value: any, index?: number, method?: string): ParamProvider {\r\n        return new ParamProvider(token, value, index, method);\r\n    }\r\n\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"Provider\",\"params\":{\"constructor\":[\"type\",\"value\"],\"resolve\":[\"container\",\"providers\"],\"create\":[\"type\",\"value\"],\"createExtends\":[\"token\",\"value\",\"extendsTarget\"],\"createInvoke\":[\"token\",\"method\",\"value\"],\"createParam\":[\"token\",\"value\",\"index\",\"method\"]}};\n                        }\n                   }\r\n\r\n/**\r\n * InvokeProvider\r\n *\r\n * @export\r\n * @class InvokeProvider\r\n * @extends {Provider}\r\n */\r\nexport class InvokeProvider extends Provider {\r\n    /**\r\n     * service value is the result of type instance invoke the method return value.\r\n     *\r\n     * @type {string}\r\n     * @memberof Provider\r\n     */\r\n    protected method?: string;\r\n\r\n    constructor(type?: Token<any>, method?: string, value?: any) {\r\n        super(type, value);\r\n        this.method = method;\r\n    }\r\n\r\n    resolve<T>(container: IContainer, ...providers: ProviderTypes[]): T {\r\n        if (this.method) {\r\n            return container.syncInvoke<T>(this.type, this.method, ...providers);\r\n        }\r\n        return super.resolve(container, ...providers);\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"InvokeProvider\",\"params\":{\"constructor\":[\"type\",\"method\",\"value\"],\"resolve\":[\"container\",\"providers\"]}};\n                        }\n                   }\r\n\r\n\r\n/**\r\n * param provider.\r\n *\r\n * @export\r\n * @interface ParamProvider\r\n */\r\nexport class ParamProvider extends InvokeProvider {\r\n    /**\r\n     * param index, param name.\r\n     *\r\n     * @type {number}\r\n     * @memberof ParamProvider\r\n     */\r\n    index?: number;\r\n\r\n    constructor(token?: Token<any>, value?: any, index?: number, method?: string) {\r\n        super(token, method, value);\r\n        this.index = index;\r\n    }\r\n\r\n    /**\r\n     * resolve param\r\n     *\r\n     * @template T\r\n     * @param {IContainer} container\r\n     * @param {...ProviderTypes[]} providers\r\n     * @returns {T}\r\n     * @memberof ParamProvider\r\n     */\r\n    resolve<T>(container: IContainer, ...providers: ProviderTypes[]): T {\r\n        return super.resolve(container, ...providers);\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ParamProvider\",\"params\":{\"constructor\":[\"token\",\"value\",\"index\",\"method\"],\"resolve\":[\"container\",\"providers\"]}};\n                        }\n                   }\r\n\r\n/**\r\n * Provider enable exntends target with provider in dynamic.\r\n *\r\n * @export\r\n * @class ExtendsProvider\r\n * @extends {Provider}\r\n */\r\nexport class ExtendsProvider extends Provider {\r\n\r\n\r\n    constructor(token: Token<any>, value?: any, private extendsTarget?: Express2<any, ExtendsProvider, void>) {\r\n        super(token, value);\r\n    }\r\n\r\n    resolve<T>(container: IContainer, ...providers: ProviderTypes[]): T {\r\n        return super.resolve(container, ...providers);\r\n    }\r\n\r\n    extends(target: any) {\r\n        if (isObject(target) && isFunction(this.extendsTarget)) {\r\n            this.extendsTarget(target, this);\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ExtendsProvider\",\"params\":{\"constructor\":[\"token\",\"value\",\"extendsTarget\"],\"resolve\":[\"container\",\"providers\"],\"extends\":[\"target\"]}};\n                        }\n                   }\r\n"]}