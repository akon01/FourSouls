"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ActionComposite_1 = require("./ActionComposite");
const CoreActions_1 = require("./CoreActions");
const factories_1 = require("../factories");
const InjectReference_1 = require("../../InjectReference");
/**
 * bind provider action. for binding a factory to an token.
 *
 * @export
 * @class BindProviderAction
 * @extends {ActionComposite}
 */
class BindProviderAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.bindProvider);
    }
    working(container, data) {
        let type = data.targetType;
        let raiseContainer = data.raiseContainer;
        let lifeScope = container.getLifeScope();
        let matchs = lifeScope.getClassDecorators(type, surm => surm.actions.includes(CoreActions_1.CoreActions.bindProvider));
        let clpds = new InjectReference_1.InjectClassProvidesToken(type);
        // has binding.
        let classPds = raiseContainer.resolveValue(clpds) || { provides: [clpds.toString()], decors: [] };
        if (classPds.decors.length) {
            matchs = matchs.filter(d => classPds.decors.indexOf(d.name) < 0);
        }
        if (matchs.length < 1) {
            data.execResult = classPds.provides;
            return;
        }
        matchs.forEach(surm => {
            let metadata = factories_1.getOwnTypeMetadata(surm.name, type);
            classPds.decors.push(surm.name);
            if (Array.isArray(metadata) && metadata.length > 0) {
                // bind all provider.
                metadata.forEach(c => {
                    if (!c) {
                        return;
                    }
                    if (c.provide) {
                        let provide = raiseContainer.getToken(c.provide, c.alias);
                        classPds.provides.push(provide);
                        raiseContainer.bindProvider(provide, c.type);
                    }
                    if (c.refs && c.refs.target) {
                        raiseContainer.bindRefProvider(c.refs.target, c.refs.provide ? c.refs.provide : c.type, c.type, c.refs.provide ? c.refs.alias : '', tk => classPds.provides.push(tk));
                    }
                    // class private provider.
                    if (c.providers && c.providers.length) {
                        raiseContainer.bindProviders(c.type, refKey => classPds.provides.push(refKey), ...c.providers);
                    }
                });
            }
        });
        raiseContainer.bindProvider(clpds, classPds);
        data.execResult = classPds.provides;
    }
    static getClassAnnations() {
        return { "name": "BindProviderAction", "params": { "constructor": [], "working": ["container", "data"] } };
    }
}
exports.BindProviderAction = BindProviderAction;

//# sourceMappingURL=../../sourcemaps/core/actions/BindProviderAction.js.map
