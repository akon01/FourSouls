"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ModuleInjector_1 = require("./ModuleInjector");
const utils_1 = require("../utils");
/**
 * Module Injector chain, base injector chain.
 *
 * @export
 * @class ModuleInjectorChain
 * @implements {IModuleInjectorChain}
 */
class ModuleInjectorChain {
    get injectors() {
        return this._injectors;
    }
    constructor() {
        this._injectors = [];
    }
    first(injector) {
        if (this.isInjector(injector)) {
            this._injectors.unshift(injector);
        }
        return this;
    }
    next(injector) {
        if (this.isInjector(injector)) {
            this._injectors.push(injector);
        }
        return this;
    }
    isInjector(injector) {
        return injector instanceof ModuleInjector_1.ModuleInjector;
    }
    inject(container, modules) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let types = [];
            yield utils_1.PromiseUtil.runInChain(this.injectors.map(jtor => {
                return (mds, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    let ijRt = yield jtor.inject(container, mds);
                    if (ijRt.injected && ijRt.injected.length) {
                        types = types.concat(ijRt.injected);
                    }
                    if (ijRt.next && ijRt.next.length > 0) {
                        return next();
                    }
                });
            }), modules);
            return types;
        });
    }
    syncInject(container, modules) {
        let types = [];
        let completed = false;
        this.injectors.some(jtor => {
            if (jtor instanceof ModuleInjector_1.ModuleInjector) {
                let result = jtor.syncInject(container, modules);
                types = types.concat(result.injected);
                completed = (!result.next || result.next.length < 1);
            }
            return completed;
        });
        return types;
    }
    static getClassAnnations() {
        return { "name": "ModuleInjectorChain", "params": { "constructor": [], "first": ["injector"], "next": ["injector"], "isInjector": ["injector"], "inject": ["container", "modules"], "syncInject": ["container", "modules"] } };
    }
}
exports.ModuleInjectorChain = ModuleInjectorChain;

//# sourceMappingURL=../sourcemaps/injectors/ModuleInjectorChain.js.map
