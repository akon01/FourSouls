import 'reflect-metadata';
import { ClassMetadata } from '../metadatas';
import { Type, Token } from '../../types';
import { MetadataAdapter, MetadataExtends } from './DecoratorFactory';
import { Registration } from '../../Registration';
/**
 * Type decorator.
 *
 * @export
 * @interface ITypeDecorator
 * @template T
 */
export interface ITypeDecorator<T extends ClassMetadata> {
    /**
     * define class decorator setting with metadata map.
     *
     * @param {T} [metadata] metadata map.
     */
    (metadata?: T): ClassDecorator;
    /**
     * not allow abstract to decorator with out metadata.
     */
    (target: Type<any>): void;
}
/**
 * class decorator.
 *
 * @export
 * @interface IClassDecorator
 */
export interface IClassDecorator<T extends ClassMetadata> extends ITypeDecorator<T> {
    /**
     * define class decorator setting with params.
     *
     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.
     * @param {string} [alias] define this class provider with alias for provide.
     */
    (provide: Registration<any> | symbol | string, alias?: string): ClassDecorator;
    /**
     * define class decorator setting with params.
     *
     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.
     * @param {string} [alias] define this class provider with alias for provide.
     * @param {Token<any>} [refTarget]  define the class as service of target.
     */
    (provide: Registration<any> | symbol | string, alias: string, refTarget: Token<any>): ClassDecorator;
    /**
     * define class decorator setting with params.
     *
     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.
     * @param {string} [alias] define this class provider with alias for provide.
     * @param {boolean} [singlton] define this class as singlton.
     * @param {Token<any>} [refTarget]  define the class as service of target.
     */
    (provide: Registration<any> | symbol | string, alias: string, singlton: boolean, refTarget: Token<any>): ClassDecorator;
    /**
     * define class decorator setting with params.
     *
     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.
     * @param {string} [alias] define this class provider with alias for provide.
     * @param {boolean} [singlton] define this class as singlton.
     * @param {number} [cache]  define class cahce expris when is not singlton.
     * @param {Token<any>} [refTarget]  define the class as service of target.
     */
    (provide: Registration<any> | symbol | string, alias: string, cache: number, refTarget: Token<any>): ClassDecorator;
}
/**
 * create class decorator
 *
 * @export
 * @template T metadata type.
 * @param {string} name decorator name.
 * @param {MetadataAdapter} [adapter]  metadata adapter
 * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.
 * @returns {*}
 */
export declare function createClassDecorator<T extends ClassMetadata>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): IClassDecorator<T>;
