"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("../utils");
/**
 *  provider, to dynamic resovle instance of params in run time.
 *
 * @export
 * @class Provider
 */
var Provider = /** @class */ (function () {
    function Provider(type, value) {
        this.type = type;
        this.value = value;
    }
    /**
     * resolve provider value.
     *
     * @template T
     * @param {IContainer} container
     * @param {ProviderTypes[]} providers
     * @returns {T}
     * @memberof Provider
     */
    Provider.prototype.resolve = function (container) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        if (utils_1.isUndefined(this.value)) {
            return container.has(this.type) ? container.resolve.apply(container, [this.type].concat(providers)) : null;
        }
        else {
            return this.value;
        }
    };
    /**
     * create provider.
     *
     * @static
     * @param {Token<any>} type
     * @param {(any)} value
     * @returns Provider
     * @memberof Provider
     */
    Provider.create = function (type, value) {
        return new Provider(type, value);
    };
    /**
     * create extends provider.
     *
     * @static
     * @param {Token<any>} token
     * @param {(any)} value
     * @param {Express2<any, ExtendsProvider, void>} [extendsTarget]
     * @returns {ExtendsProvider}
     * @memberof Provider
     */
    Provider.createExtends = function (token, value, extendsTarget) {
        return new ExtendsProvider(token, value, extendsTarget);
    };
    /**
     * create invoked provider.
     *
     * @static
     * @param {Token<any>} token
     * @param {string} method
     * @param {(any)} [value]
     * @returns {InvokeProvider}
     * @memberof Provider
     */
    Provider.createInvoke = function (token, method, value) {
        return new InvokeProvider(token, method, value);
    };
    /**
     * create param provider.
     *
     * @static
     * @param {Token<any>} token
     * @param {(any)} value
     * @param {number} [index]
     * @param {string} [method]
     * @returns {ParamProvider}
     * @memberof Provider
     */
    Provider.createParam = function (token, value, index, method) {
        return new ParamProvider(token, value, index, method);
    };
    Provider.getClassAnnations = function () {
        return { "name": "Provider", "params": { "constructor": ["type", "value"], "resolve": ["container", "providers"], "create": ["type", "value"], "createExtends": ["token", "value", "extendsTarget"], "createInvoke": ["token", "method", "value"], "createParam": ["token", "value", "index", "method"] } };
    };
    return Provider;
}());
exports.Provider = Provider;
/**
 * InvokeProvider
 *
 * @export
 * @class InvokeProvider
 * @extends {Provider}
 */
var InvokeProvider = /** @class */ (function (_super) {
    tslib_1.__extends(InvokeProvider, _super);
    function InvokeProvider(type, method, value) {
        var _this = _super.call(this, type, value) || this;
        _this.method = method;
        return _this;
    }
    InvokeProvider.prototype.resolve = function (container) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        if (this.method) {
            return container.syncInvoke.apply(container, [this.type, this.method].concat(providers));
        }
        return _super.prototype.resolve.apply(this, [container].concat(providers));
    };
    InvokeProvider.getClassAnnations = function () {
        return { "name": "InvokeProvider", "params": { "constructor": ["type", "method", "value"], "resolve": ["container", "providers"] } };
    };
    return InvokeProvider;
}(Provider));
exports.InvokeProvider = InvokeProvider;
/**
 * param provider.
 *
 * @export
 * @interface ParamProvider
 */
var ParamProvider = /** @class */ (function (_super) {
    tslib_1.__extends(ParamProvider, _super);
    function ParamProvider(token, value, index, method) {
        var _this = _super.call(this, token, method, value) || this;
        _this.index = index;
        return _this;
    }
    /**
     * resolve param
     *
     * @template T
     * @param {IContainer} container
     * @param {...ProviderTypes[]} providers
     * @returns {T}
     * @memberof ParamProvider
     */
    ParamProvider.prototype.resolve = function (container) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        return _super.prototype.resolve.apply(this, [container].concat(providers));
    };
    ParamProvider.getClassAnnations = function () {
        return { "name": "ParamProvider", "params": { "constructor": ["token", "value", "index", "method"], "resolve": ["container", "providers"] } };
    };
    return ParamProvider;
}(InvokeProvider));
exports.ParamProvider = ParamProvider;
/**
 * Provider enable exntends target with provider in dynamic.
 *
 * @export
 * @class ExtendsProvider
 * @extends {Provider}
 */
var ExtendsProvider = /** @class */ (function (_super) {
    tslib_1.__extends(ExtendsProvider, _super);
    function ExtendsProvider(token, value, extendsTarget) {
        var _this = _super.call(this, token, value) || this;
        _this.extendsTarget = extendsTarget;
        return _this;
    }
    ExtendsProvider.prototype.resolve = function (container) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        return _super.prototype.resolve.apply(this, [container].concat(providers));
    };
    ExtendsProvider.prototype.extends = function (target) {
        if (utils_1.isObject(target) && utils_1.isFunction(this.extendsTarget)) {
            this.extendsTarget(target, this);
        }
    };
    ExtendsProvider.getClassAnnations = function () {
        return { "name": "ExtendsProvider", "params": { "constructor": ["token", "value", "extendsTarget"], "resolve": ["container", "providers"], "extends": ["target"] } };
    };
    return ExtendsProvider;
}(Provider));
exports.ExtendsProvider = ExtendsProvider;

//# sourceMappingURL=../sourcemaps/providers/Provider.js.map
