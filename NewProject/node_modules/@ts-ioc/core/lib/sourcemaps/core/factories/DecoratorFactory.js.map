{"version":3,"sources":["core/factories/DecoratorFactory.ts"],"names":[],"mappings":"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","file":"../../../core/factories/DecoratorFactory.js","sourcesContent":["import 'reflect-metadata';\r\nimport { PropertyMetadata, MethodMetadata, ParameterMetadata, Metadate, ClassMetadata } from '../metadatas';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport {\r\n    isClass, isAbstractClass, isMetadataObject, isUndefined, isFunction,\r\n    isNumber, isArray, lang, isString\r\n} from '../../utils';\r\nimport { Type, AbstractType, ObjectMap, ClassType } from '../../types';\r\n\r\n\r\nexport const ParamerterName = 'paramerter_names';\r\n\r\nexport interface MetadataAdapter {\r\n    (args: ArgsIterator);\r\n}\r\n\r\n/**\r\n * extend metadata.\r\n *\r\n * @export\r\n * @interface MetadataExtends\r\n * @template T\r\n */\r\nexport interface MetadataExtends<T> {\r\n    (metadata: T): void;\r\n}\r\n\r\nexport interface MetadataTarget<T> {\r\n    (target: Type<any> | object): Type<any> | object\r\n}\r\n\r\n/**\r\n * decorator for all.\r\n *\r\n * @export\r\n * @interface IDecorator\r\n * @template T\r\n */\r\nexport interface IDecorator<T extends Metadate> {\r\n    /**\r\n     * define decorator setting with params.\r\n     *\r\n     * @param {(Type<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     */\r\n    (provider: string | symbol | Type<any>, alias?: string): any;\r\n    /**\r\n     * define decorator setting with metadata map.\r\n     *\r\n     * @param {T} [metadata] metadata map.\r\n     */\r\n    (metadata?: T): any;\r\n    (target: Type<any>): void;\r\n    (target: object, propertyKey: string | symbol): void;\r\n    (target: object, propertyKey: string | symbol, parameterIndex: number): void;\r\n    (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n/**\r\n * create dectorator for class params props methods.\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {*}\r\n */\r\nexport function createDecorator<T>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): any {\r\n    let metaName = `@${name}`;\r\n\r\n    let factory = (...args: any[]) => {\r\n        let metadata: T = null;\r\n        if (args.length < 1) {\r\n            return (...args: any[]) => {\r\n                return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n            }\r\n        }\r\n        metadata = argsToMetadata(args, adapter);\r\n        if (metadata) {\r\n            return (...args: any[]) => {\r\n                return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n            }\r\n        } else {\r\n            if (args.length === 1) {\r\n                if (!isClass(args[0])) {\r\n                    return (...args: any[]) => {\r\n                        return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n    }\r\n\r\n    factory.toString = () => metaName;\r\n    (<any>factory).decoratorType = DecoratorType.All;\r\n    return factory;\r\n}\r\n\r\nfunction argsToMetadata<T>(args: any[], adapter?: MetadataAdapter): T {\r\n    let metadata: T = null;\r\n    if (args.length) {\r\n        if (adapter) {\r\n            let iterator = new ArgsIterator(args);\r\n            adapter(iterator);\r\n            metadata = iterator.getMetadata() as T;\r\n        } else if (args.length === 1 && isMetadataObject(args[0])) {\r\n            metadata = args[0];\r\n        }\r\n    }\r\n    return metadata;\r\n}\r\n\r\n\r\nfunction storeMetadata<T>(name: string, metaName: string, args: any[], metadata?: any, metadataExtends?: MetadataExtends<T>) {\r\n    let target;\r\n    switch (args.length) {\r\n        case 1:\r\n            target = args[0];\r\n            if (isClass(target) || isAbstractClass(target)) {\r\n                setTypeMetadata(name, metaName, target, metadata, metadataExtends);\r\n                return target;\r\n            }\r\n            break;\r\n        case 2:\r\n            target = args[0];\r\n            let propertyKey = args[1];\r\n            setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);\r\n            break;\r\n        case 3:\r\n            if (isNumber(args[2])) {\r\n                target = args[0];\r\n                let propertyKey = args[1];\r\n                let parameterIndex = args[2];\r\n                setParamMetadata(name, metaName, target, propertyKey, parameterIndex, metadata, metadataExtends);\r\n            } else if (isUndefined(args[2])) {\r\n                target = args[0];\r\n                let propertyKey = args[1];\r\n                setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);\r\n            } else {\r\n                target = args[0];\r\n                let propertyKey = args[1];\r\n                let descriptor = args[2];\r\n                setMethodMetadata(name, metaName, target, propertyKey, descriptor, metadata, metadataExtends);\r\n                return descriptor;\r\n            }\r\n            break;\r\n        default:\r\n            throw new Error(`Invalid @${name} Decorator declaration.`);\r\n    }\r\n}\r\n\r\n/**\r\n * get type decorators of class.\r\n *\r\n * @export\r\n * @param {(Type<any> | AbstractType<any>)} target\r\n * @returns {string[]}\r\n */\r\nexport function getClassDecorators(target: Type<any> | AbstractType<any>): string[] {\r\n    return Reflect.getOwnMetadataKeys(target)\r\n        .filter(d => {\r\n            if (!(d && isString(d))) {\r\n                return false;\r\n            }\r\n            if (!/^@/.test(d)) {\r\n                return false;\r\n            }\r\n            return !/__\\w+$/.test(d);\r\n        });\r\n}\r\n\r\n/**\r\n * get type decorators of class.\r\n *\r\n * @export\r\n * @param {(Type<any> | AbstractType<any>)} target\r\n * @returns {string[]}\r\n */\r\nexport function getMethodDecorators(target: Type<any> | AbstractType<any>): string[] {\r\n    return Reflect.getMetadataKeys(target)\r\n        .filter(d => d && isString(d) && /^@\\S+__method$/.test(d))\r\n        .map(d => d.replace(/__method$/ig, ''));\r\n}\r\n\r\n\r\n/**\r\n * get type decorators of class.\r\n *\r\n * @export\r\n * @param {(Type<any> | AbstractType<any>)} target\r\n * @returns {string[]}\r\n */\r\nexport function getPropDecorators(target: Type<any> | AbstractType<any>): string[] {\r\n    return Reflect.getMetadataKeys(target)\r\n        .filter(d => d && isString(d) && /^@\\S+__props$/.test(d))\r\n        .map(d => d.replace(/__props$/ig, ''));\r\n}\r\n\r\n/**\r\n * get type decorators of class.\r\n *\r\n * @export\r\n * @param {(Type<any> | AbstractType<any>)} target\r\n * @returns {string[]}\r\n */\r\nexport function getParamDecorators(target: any, propertyKey?: string): string[] {\r\n    return ((propertyKey && propertyKey !== 'constructor') ? Reflect.getMetadataKeys(target, propertyKey) : Reflect.getOwnMetadataKeys(lang.getClass(target)) || [])\r\n        .filter(d => d && isString(d) && /^@\\S+__params$/.test(d))\r\n        .map((d: string) => d.replace(/__params$/ig, ''));\r\n}\r\n\r\n/**\r\n * get all class metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns\r\n */\r\nexport function getTypeMetadata<T>(decorator: string | Function, target: Type<any> | AbstractType<T>): T[] {\r\n    let annotations = Reflect.getOwnMetadata(isFunction(decorator) ? decorator.toString() : decorator, target);\r\n    annotations = isArray(annotations) ? annotations : [];\r\n    return annotations;\r\n}\r\n\r\n/**\r\n * get own class metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns\r\n */\r\nexport function getOwnTypeMetadata<T>(decorator: string | Function, target: Type<any> | AbstractType<T>): T[] {\r\n    let annotations = Reflect.getOwnMetadata(isFunction(decorator) ? decorator.toString() : decorator, target);\r\n    annotations = isArray(annotations) ? annotations : [];\r\n    return annotations;\r\n}\r\n\r\n/**\r\n * has class decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @returns {boolean}\r\n */\r\nexport function hasClassMetadata(decorator: string | Function, target: Type<any> | object): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasMetadata(name, target);\r\n}\r\n\r\n/**\r\n * has own class decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @returns {boolean}\r\n */\r\nexport function hasOwnClassMetadata(decorator: string | Function, target: Type<any> | object): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasOwnMetadata(name, target);\r\n}\r\n\r\n\r\nfunction setTypeMetadata<T extends ClassMetadata>(name: string, metaName: string, target: Type<T> | AbstractType<T>, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n    let annotations = getOwnTypeMetadata(metaName, target).slice(0);\r\n    let typeMetadata = (metadata || {}) as T;\r\n    if (!typeMetadata.type) {\r\n        typeMetadata.type = target;\r\n    }\r\n    typeMetadata.decorator = name;\r\n\r\n    if (metadataExtends) {\r\n        metadataExtends(typeMetadata);\r\n    }\r\n    annotations.unshift(typeMetadata);\r\n\r\n    setParamerterNames(target);\r\n    Reflect.defineMetadata(metaName, annotations, target);\r\n}\r\n\r\nlet methodMetadataExt = '__method';\r\n/**\r\n * get all method metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getMethodMetadata<T extends MethodMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getMetadata(name + methodMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getMetadata(name + methodMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n/**\r\n * get own method metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getOwnMethodMetadata<T extends MethodMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getOwnMetadata(name + methodMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getOwnMetadata(name + methodMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n/**\r\n * has own method decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @param {(string | symbol)} [propertyKey]\r\n * @returns {boolean}\r\n */\r\nexport function hasOwnMethodMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    if (propertyKey) {\r\n        let meta = getOwnMethodMetadata<any>(name, target);\r\n        return meta && meta.hasOwnProperty(propertyKey);\r\n    } else {\r\n        return Reflect.hasOwnMetadata(name + methodMetadataExt, target);\r\n    }\r\n}\r\n\r\n/**\r\n * has method decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @param {(string | symbol)} [propertyKey]\r\n * @returns {boolean}\r\n */\r\nexport function hasMethodMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    if (propertyKey) {\r\n        let meta = getMethodMetadata<any>(name, target);\r\n        return meta && meta.hasOwnProperty(propertyKey);\r\n    } else {\r\n        return Reflect.hasMetadata(name + methodMetadataExt, target);\r\n    }\r\n}\r\n\r\nfunction setMethodMetadata<T extends MethodMetadata>(name: string, metaName: string, target: Type<T>, propertyKey: string, descriptor: TypedPropertyDescriptor<T>, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n    let meta = lang.assign({}, getOwnMethodMetadata(metaName, target));\r\n    meta[propertyKey] = meta[propertyKey] || [];\r\n\r\n    let methodMeadata = (metadata || {}) as T;\r\n    methodMeadata.decorator = name;\r\n    methodMeadata.propertyKey = propertyKey;\r\n    // methodMeadata.descriptor = descriptor;\r\n\r\n    if (metadataExtends) {\r\n        metadataExtends(methodMeadata);\r\n    }\r\n    meta[propertyKey].unshift(methodMeadata);\r\n    Reflect.defineMetadata(metaName + methodMetadataExt, meta, target.constructor);\r\n}\r\n\r\nlet propertyMetadataExt = '__props';\r\n/**\r\n * get all property metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getPropertyMetadata<T extends PropertyMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getMetadata(name + propertyMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getMetadata(name + propertyMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n/**\r\n * get own property metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getOwnPropertyMetadata<T extends PropertyMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n\r\n/**\r\n * has property decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @param {(string | symbol)} [propertyKey]\r\n * @returns {boolean}\r\n */\r\nexport function hasPropertyMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    if (propertyKey) {\r\n        let meta = getPropertyMetadata<any>(name, target);\r\n        return meta && meta.hasOwnProperty(propertyKey);\r\n    } else {\r\n        return Reflect.hasMetadata(name + propertyMetadataExt, target);\r\n    }\r\n}\r\n\r\nfunction setPropertyMetadata<T extends PropertyMetadata>(name: string, metaName: string, target: Type<T>, propertyKey: string, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n    let meta = lang.assign({}, getOwnPropertyMetadata(metaName, target));\r\n    let propmetadata = (metadata || {}) as T;\r\n\r\n    propmetadata.propertyKey = propertyKey;\r\n    propmetadata.decorator = name;\r\n    if (!propmetadata.type) {\r\n        let t = Reflect.getMetadata('design:type', target, propertyKey);\r\n        if (!t) {\r\n            // Needed to support react native inheritance\r\n            t = Reflect.getMetadata('design:type', target.constructor, propertyKey);\r\n        }\r\n        propmetadata.type = t;\r\n    }\r\n\r\n    if (metadataExtends) {\r\n        metadataExtends(propmetadata);\r\n    }\r\n\r\n    if (!meta[propertyKey] || !isArray(meta[propertyKey])) {\r\n        meta[propertyKey] = [];\r\n    }\r\n\r\n    meta[propertyKey].unshift(propmetadata);\r\n    Reflect.defineMetadata(metaName + propertyMetadataExt, meta, target.constructor);\r\n}\r\n\r\n\r\nlet paramsMetadataExt = '__params';\r\n/**\r\n * get paramerter metadata of one specail decorator in target method.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {T[][]}\r\n */\r\nexport function getParamMetadata<T extends ParameterMetadata>(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): T[][] {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let parameters = Reflect.getMetadata(name + paramsMetadataExt, target, propertyKey);\r\n    parameters = isArray(parameters) ? parameters : [];\r\n    return parameters;\r\n}\r\n\r\n/**\r\n * get own paramerter metadata of one specail decorator in target method.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {T[][]}\r\n */\r\nexport function getOwnParamMetadata<T extends ParameterMetadata>(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): T[][] {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let parameters = Reflect.getOwnMetadata(name + paramsMetadataExt, target, propertyKey);\r\n    parameters = isArray(parameters) ? parameters : [];\r\n    return parameters;\r\n}\r\n\r\n/**\r\n * has param decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {boolean}\r\n */\r\nexport function hasParamMetadata(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasMetadata(name + paramsMetadataExt, target, propertyKey);\r\n}\r\n\r\n/**\r\n * has param decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {boolean}\r\n */\r\nexport function hasOwnParamMetadata(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasOwnMetadata(name + paramsMetadataExt, target, propertyKey);\r\n}\r\n\r\n\r\nfunction setParamMetadata<T extends ParameterMetadata>(name: string, metaName: string, target: Type<T>, propertyKey: string, parameterIndex: number, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n\r\n    let parameters: any[][] = getOwnParamMetadata(metaName, target, propertyKey).slice(0);\r\n    // there might be gaps if some in between parameters do not have annotations.\r\n    // we pad with nulls.\r\n    while (parameters.length <= parameterIndex) {\r\n        parameters.push(null);\r\n    }\r\n\r\n    parameters[parameterIndex] = parameters[parameterIndex] || [];\r\n\r\n    let paramMeadata = (metadata || {}) as ParameterMetadata;\r\n\r\n    if (!paramMeadata.type) {\r\n        let t = Reflect.getOwnMetadata('design:type', target, propertyKey);\r\n        if (!t) {\r\n            // Needed to support react native inheritance\r\n            t = Reflect.getOwnMetadata('design:type', target.constructor, propertyKey);\r\n        }\r\n        paramMeadata.type = t;\r\n    }\r\n    paramMeadata.propertyKey = propertyKey;\r\n    paramMeadata.decorator = name;\r\n    paramMeadata.index = parameterIndex;\r\n    if (metadataExtends) {\r\n        metadataExtends(paramMeadata);\r\n    }\r\n    parameters[parameterIndex].unshift(paramMeadata);\r\n    Reflect.defineMetadata(metaName + paramsMetadataExt, parameters, target, propertyKey);\r\n}\r\n\r\n\r\n\r\nexport function getParamerterNames(target: Type<any> | AbstractType<any>): ObjectMap<string[]> {\r\n    let meta = Reflect.getMetadata(ParamerterName, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getMetadata(ParamerterName, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\nexport function getOwnParamerterNames(target: Type<any> | AbstractType<any>): ObjectMap<string[]> {\r\n    let meta = Reflect.getOwnMetadata(ParamerterName, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getOwnMetadata(ParamerterName, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\nexport function setParamerterNames(target: ClassType<any>) {\r\n    let meta = lang.assign({}, getParamerterNames(target));\r\n    let descriptors = Object.getOwnPropertyDescriptors(target.prototype);\r\n    let isUglify = /^[a-z]/.test(target.name);\r\n    let anName = '';\r\n    let classAnnations = lang.getClassAnnations(target);\r\n\r\n    if (classAnnations && classAnnations.params) {\r\n        anName = classAnnations.name;\r\n        meta = lang.assign(meta, classAnnations.params);\r\n    }\r\n    if (!isUglify && target.name !== anName) {\r\n        lang.forIn(descriptors, (item, name) => {\r\n            if (name !== 'constructor') {\r\n                if (item.value) {\r\n                    meta[name] = getParamNames(item.value)\r\n                }\r\n                if (item.set) {\r\n                    meta[name] = getParamNames(item.set);\r\n                }\r\n            }\r\n        });\r\n        meta['constructor'] = getParamNames(target.prototype.constructor);\r\n    }\r\n\r\n    Reflect.defineMetadata(ParamerterName, meta, target);\r\n}\r\n\r\nconst STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\r\nconst ARGUMENT_NAMES = /([^\\s,]+)/g;\r\nfunction getParamNames(func) {\r\n    if (!isFunction(func)) {\r\n        return [];\r\n    }\r\n    let fnStr = func.toString().replace(STRIP_COMMENTS, '');\r\n    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\r\n    if (result === null) {\r\n        result = [];\r\n    }\r\n    return result;\r\n}\r\n\r\n"]}