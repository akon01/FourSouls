{"version":3,"file":"../core.js","sources":["utils/utils/lang.ts","utils/utils/typeCheck.ts","utils/utils/PromiseUtil.ts","utils/utils/index.ts","Registration.ts","InjectToken.ts","IContainer.ts","types.ts","IMethodAccessor.ts","components/components/NullComponent.ts","components/components/GComposite.ts","components/components/Composite.ts","components/components/index.ts","core/actions/core/actions/NullAction.ts","core/actions/core/actions/ActionComposite.ts","core/actions/core/actions/LifeState.ts","core/actions/core/actions/CoreActions.ts","core/factories/core/factories/ArgsIterator.ts","core/factories/core/factories/DecoratorType.ts","core/factories/core/factories/DecoratorFactory.ts","core/factories/core/factories/ClassDecoratorFactory.ts","core/factories/core/factories/MethodDecoratorFactory.ts","core/factories/core/factories/ParamDecoratorFactory.ts","core/factories/core/factories/PropertyDecoratorFactory.ts","core/factories/core/factories/ParamPropDecoratorFactory.ts","core/factories/core/factories/ClassMethodDecoratorFactory.ts","core/factories/core/factories/MethodPropDecoratorFactory.ts","core/factories/core/factories/MethodPropParamDecoratorFactory.ts","core/factories/core/factories/index.ts","InjectReference.ts","core/actions/core/actions/BindProviderAction.ts","core/actions/core/actions/BindParameterTypeAction.ts","core/actions/core/actions/BindPropertyTypeAction.ts","providers/providers/Provider.ts","providers/providers/ProviderMap.ts","providers/providers/IProviderParser.ts","providers/providers/ProviderParser.ts","providers/providers/index.ts","core/actions/core/actions/InjectPropertyAction.ts","core/actions/core/actions/BindParameterProviderAction.ts","core/actions/core/actions/ComponentBeforeInitAction.ts","core/actions/core/actions/ComponentInitAction.ts","core/actions/core/actions/ComponentAfterInitAction.ts","ICacheManager.ts","core/actions/core/actions/CacheAction.ts","core/actions/core/actions/SingletonAction.ts","core/decorators/core/decorators/AutoRun.ts","core/decorators/core/decorators/IocExt.ts","core/actions/core/actions/AutorunAction.ts","core/actions/core/actions/index.ts","core/decorators/core/decorators/basic.ts","core/decorators/core/decorators/Component.ts","core/decorators/core/decorators/Injectable.ts","core/decorators/core/decorators/Refs.ts","core/decorators/core/decorators/Providers.ts","core/decorators/core/decorators/Inject.ts","core/decorators/core/decorators/AutoWried.ts","core/decorators/core/decorators/Param.ts","core/decorators/core/decorators/Method.ts","core/decorators/core/decorators/Singleton.ts","core/decorators/core/decorators/Abstract.ts","core/decorators/core/decorators/index.ts","core/core/IRecognizer.ts","core/actions/core/actions/MethodAutorun.ts","core/core/ActionFactory.ts","core/core/IMetaAccessor.ts","core/core/DefaultLifeScope.ts","core/core/MetaAccessor.ts","core/core/MethodAccessor.ts","core/core/CacheManager.ts","core/core/index.ts","IContainerBuilder.ts","LifeScope.ts","resolves/resolves/ResolverChain.ts","resolves/resolves/index.ts","registerCores.ts","Container.ts","injectors/injectors/IModuleLoader.ts","injectors/injectors/DefaultModuleLoader.ts","injectors/injectors/IModuleValidate.ts","injectors/injectors/ModuleValidate.ts","injectors/injectors/IModuleInjector.ts","injectors/injectors/ModuleInjector.ts","injectors/injectors/IModuleInjectorChain.ts","injectors/injectors/ModuleInjectorChain.ts","injectors/injectors/index.ts","ContainerBuilder.ts","index.ts"],"sourcesContent":["import { ObjectMap, Type, Token, ClassType } from '../types';\r\nimport { isNullOrUndefined, isArray, isObject, isFunction, isClass, isClassType, isString } from './typeCheck';\r\n// use core-js in browser.\r\n\r\n\r\n/**\r\n * map base.\r\n *\r\n * @export\r\n * @class MapBase\r\n * @template K\r\n * @template V\r\n */\r\nexport class MapBase <K, V> {\r\n    protected map: Map<K, V>;\r\n\r\n    get size(): number {\r\n        return this.map.size;\r\n    }\r\n\r\n    constructor() {\r\n        this.map = new Map();\r\n    }\r\n\r\n    clear(): void {\r\n        this.map.clear();\r\n    }\r\n    delete(key: K): boolean {\r\n        return this.map.delete(key);\r\n    }\r\n    get(key: K): V | undefined {\r\n        return this.map.get(key);\r\n    }\r\n    has(key: K): boolean {\r\n        return this.map.has(key);\r\n    }\r\n    set(key: K, value: V): this {\r\n        this.map.set(key, value);\r\n        return this;\r\n    }\r\n\r\n    keys(): K[] {\r\n        return Array.from(this.map.keys());\r\n    }\r\n\r\n    values(): V[] {\r\n        return Array.from(this.map.values());\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"MapBase\",\"params\":{\"constructor\":[],\"clear\":[],\"delete\":[\"key\"],\"get\":[\"key\"],\"has\":[\"key\"],\"set\":[\"key\",\"value\"],\"keys\":[],\"values\":[]}};\n                        }\n                   }\r\n\r\n/**\r\n * map set  for tsioc old version.\r\n *\r\n * @export\r\n * @class MapSet\r\n * @template K\r\n * @template V\r\n */\r\nexport class MapSet<K, V> extends MapBase<K, V> {\r\n    constructor() {\r\n        super()\r\n    }\r\n\r\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void {\r\n        this.map.forEach(callbackfn, thisArg);\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"MapSet\",\"params\":{\"constructor\":[],\"forEach\":[\"callbackfn\",\"thisArg\"]}};\n                        }\n                   }\r\n\r\n/**\r\n * lang utils\r\n */\r\nexport namespace lang {\r\n    /**\r\n     * assert param is right or not.\r\n     *\r\n     * @export\r\n     * @param {*} param\r\n     * @param {(string | Function)} msg\r\n     */\r\n    export function assert(param: any, msg: string | Function) {\r\n        if (isNullOrUndefined(param)) {\r\n            throw new Error(isFunction(msg) ? msg(param) : msg);\r\n        }\r\n    }\r\n    /**\r\n     * check assert param invalid by express\r\n     *\r\n     * @export\r\n     * @param {(boolean | (() => boolean))} express\r\n     * @param {(string | Function)} msg\r\n     */\r\n    export function assertExp(express: boolean | (() => boolean), msg: string | Function) {\r\n        if (!(isFunction(express) ? express() : express)) {\r\n            throw new Error(isFunction(msg) ? msg() : msg);\r\n        }\r\n    }\r\n    /**\r\n     * get object keys.\r\n     *\r\n     * @param {*} target\r\n     * @returns {string[]}\r\n     */\r\n    export function keys(target: any): string[] {\r\n        if (isObject(target)) {\r\n            if (isFunction(Object.keys)) {\r\n                return Object.keys(target);\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * values of target object.\r\n     *\r\n     * @export\r\n     * @param {*} target\r\n     * @returns {any[]}\r\n     */\r\n    export function values(target: any): any[] {\r\n        if (isObject(target)) {\r\n            if (isFunction(Object.values)) {\r\n                return Object.values(target);\r\n            } else {\r\n                return keys(target).map(n => target[n]);\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n\r\n    /**\r\n     * assign\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {T} target\r\n     * @param {...any[]} source\r\n     * @returns {T}\r\n     */\r\n    export function assign<T, U, V>(target: T, source1: U, source2?: V, sources?: any[]): (T & U & V) | (T & U) {\r\n        if (sources && sources.length) {\r\n            sources.unshift(source2 || {});\r\n            sources.unshift(source1 || {});\r\n            return Object.assign(target as any, ...sources);\r\n        } else if (source2) {\r\n            return Object.assign(target, source1 || {} as U, source2);\r\n        } else {\r\n            return Object.assign(target, source1 || {} as U);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * create an new object from target object omit some field.\r\n     *\r\n     * @export\r\n     * @param {ObjectMap<any>} target\r\n     * @param {...string[]} fields\r\n     * @returns {*}\r\n     */\r\n    export function omit(target: ObjectMap<any>, ...fields: string[]): any {\r\n        if (isObject(target)) {\r\n            let result: any = {};\r\n            keys(target).forEach(key => {\r\n                if (fields.indexOf(key) < 0) {\r\n                    result[key] = target[key];\r\n                }\r\n            });\r\n            return result;\r\n        } else {\r\n            return target;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * object has field or not.\r\n     *\r\n     * @export\r\n     * @param {ObjectMap<any>} target\r\n     * @returns\r\n     */\r\n    export function hasField(target: ObjectMap<any>) {\r\n        return keys(target).length > 0;\r\n    }\r\n\r\n    /**\r\n     * for in opter for object or array.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {(ObjectMap<T> | T[])} target\r\n     * @param {(item: T, idx?: number|string) => void|boolean} iterator\r\n     */\r\n    export function forIn<T>(target: ObjectMap<T> | T[], iterator: (item: T, idx?: number | string) => void | boolean) {\r\n        if (isArray(target)) {\r\n            target.some((it, idx) => iterator(it, idx) === false);\r\n        } else if (isObject(target)) {\r\n            keys(target).some((key, idx) => iterator(target[key], key) === false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find\r\n     *\r\n     * @template T\r\n     * @param {(ObjectMap<T> | T[])} target\r\n     * @param {((item: T, idx?: number | string) => boolean)} express\r\n     */\r\n    export function find<T>(target: ObjectMap<T> | T[], express: (item: T, idx?: number | string) => boolean) {\r\n        let item: T;\r\n        forIn(target, (it, idx) => {\r\n            if (!item) {\r\n                if (express(it, idx)) {\r\n                    item = it;\r\n                    return false;\r\n                }\r\n                return true;\r\n            } else {\r\n                return true;\r\n            }\r\n        })\r\n    }\r\n\r\n\r\n    /**\r\n     * first.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {T[]} list\r\n     * @returns {T}\r\n     */\r\n    export function first<T>(list: T[]): T {\r\n        if (isArray(list) && list.length) {\r\n            return list[0];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * last.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {T[]} list\r\n     * @returns {T}\r\n     */\r\n    export function last<T>(list: T[]): T {\r\n        if (isArray(list) && list.length) {\r\n            return list[list.length - 1];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * get class annations.\r\n     *\r\n     * @export\r\n     * @param {ClassType<any>} target\r\n     * @returns\r\n     */\r\n    export function getClassAnnations(target: ClassType<any>) {\r\n        return isFunction(target.getClassAnnations) ? target.getClassAnnations() : target.classAnnations;\r\n    }\r\n\r\n    /**\r\n     * target has class annations or not.\r\n     *\r\n     * @export\r\n     * @param {ClassType<any>} target\r\n     * @returns {boolean}\r\n     */\r\n    export function hasClassAnnations(target: ClassType<any>): boolean {\r\n        if (isFunction(target.getClassAnnations)) {\r\n            return true;\r\n        }\r\n        return target.classAnnations && isString(target.classAnnations.name) && target.classAnnations.name.length > 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * get calss of object.\r\n     *\r\n     * @export\r\n     * @param {*} target\r\n     * @returns {Type<any>}\r\n     */\r\n    export function getClass(target: any): Type<any> {\r\n        if (isNullOrUndefined(target)) {\r\n            return null;\r\n        }\r\n        if (isClass(target)) {\r\n            return target;\r\n        }\r\n        return target.constructor || target.prototype.constructor;\r\n    }\r\n\r\n    /**\r\n     * get class name.\r\n     *\r\n     * @export\r\n     * @param {AbstractType<any>} target\r\n     * @returns {string}\r\n     */\r\n    export function getClassName(target: any): string {\r\n        let classType = isFunction(target) ? target : getClass(target);\r\n        if (!isFunction(classType)) {\r\n            return '';\r\n        }\r\n        if (/^[a-z]$/.test(classType.name)) {\r\n            let classAnnations = getClassAnnations(classType);\r\n            return classAnnations ? classAnnations.name : classType.name;\r\n        }\r\n        return classType.name;\r\n    }\r\n\r\n    /**\r\n     * get target type parent class.\r\n     *\r\n     * @export\r\n     * @param {ClassType<any>} target\r\n     * @returns {ClassType<any>}\r\n     */\r\n    export function getParentClass(target: ClassType<any>): ClassType<any> {\r\n        let p = Reflect.getPrototypeOf(target.prototype);\r\n        return isClass(p) ? p : p.constructor as ClassType<any>;\r\n    }\r\n\r\n    /**\r\n     * get all parent class in chain.\r\n     *\r\n     * @export\r\n     * @param {ClassType<any>} target\r\n     * @returns {ClassType<any>[]}\r\n     */\r\n    export function getClassChain(target: ClassType<any>): ClassType<any>[] {\r\n        let types: ClassType<any>[] = [];\r\n        forInClassChain(target, type => {\r\n            types.push(type);\r\n        });\r\n        return types;\r\n    }\r\n\r\n    /**\r\n     * iterate base classes of target in chain. return false will break iterate.\r\n     *\r\n     * @export\r\n     * @param {Type<any>} target\r\n     * @param {(token: Type<any>) => any} express\r\n     */\r\n    export function forInClassChain(target: ClassType<any>, express: (token: ClassType<any>) => any): void {\r\n        while (isClassType(target) && target !== Object) {\r\n            if (express(target) === false) {\r\n                break;\r\n            }\r\n            target = getParentClass(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * target is extends class of baseClass or not.\r\n     *\r\n     * @export\r\n     * @param {Token<any>} target\r\n     * @param {(ClassType<any> | ((type: ClassType<any>) => boolean))} baseClass\r\n     * @returns {boolean}\r\n     */\r\n    export function isExtendsClass(target: Token<any>, baseClass: ClassType<any> | ((type: ClassType<any>) => boolean)): boolean {\r\n        let isExtnds = false;\r\n        if (isClassType(target)) {\r\n            forInClassChain(target, t => {\r\n                if (isClassType(baseClass)) {\r\n                    isExtnds = t === baseClass;\r\n                } else {\r\n                    isExtnds = baseClass(t);\r\n                }\r\n                return !isExtnds;\r\n            });\r\n        }\r\n        return isExtnds;\r\n    }\r\n}\r\n","import { Type, AbstractType, Token, IRefTarget, ClassType } from '../types';\r\nimport { Registration } from '../Registration';\r\nimport { lang } from './lang';\r\n\r\ndeclare let process: any;\r\n\r\n/**\r\n * check target is function or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns\r\n */\r\nexport function isFunction(target: any): target is Function {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    return typeof target === 'function';\r\n}\r\n\r\n/**\r\n * check Abstract class with @Abstract or not\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is AbstractType<any>}\r\n */\r\nexport function isAbstractClass(target: any): target is AbstractType<any> {\r\n    return classCheck(target) && Reflect.hasOwnMetadata('@Abstract', target);\r\n}\r\n\r\n\r\n/**\r\n * check target is class or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Type<any>}\r\n */\r\nexport function isClass(target: any): target is Type<any> {\r\n    return classCheck(target) && (!Reflect.hasOwnMetadata('@Abstract', target))\r\n}\r\n\r\nexport function isClassType(target: any): target is ClassType<any> {\r\n    return classCheck(target);\r\n}\r\n\r\nfunction classCheck(target: any): boolean {\r\n    if (!isFunction(target)) {\r\n        return false;\r\n    }\r\n\r\n    if (target.prototype) {\r\n        if (!target.name || target.name === 'Object') {\r\n            return false;\r\n        }\r\n\r\n        let type = target as Type<any>;\r\n\r\n        // for uglify\r\n        if (/^[a-z]$/.test(type.name)) {\r\n            if (lang.hasClassAnnations(type)) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (lang.hasClassAnnations(type)) {\r\n                return true;\r\n            }\r\n            if (!/^[A-Z@]/.test(target.name)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // for IE 8, 9\r\n        if (!isNodejsEnv() && /MSIE [6-9]/.test(navigator.userAgent)) {\r\n            return true;\r\n        }\r\n        try {\r\n            target.arguments && target.caller;\r\n            return false;\r\n        } catch (e) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * is run in nodejs or not.\r\n *\r\n * @export\r\n * @returns {boolean}\r\n */\r\nexport function isNodejsEnv(): boolean {\r\n    return (typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined')\r\n}\r\n\r\n/**\r\n * check target is token or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Token<any>}\r\n */\r\nexport function isToken(target: any): target is Token<any> {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    if (isString(target) || isSymbol(target) || classCheck(target) || (target instanceof Registration)) {\r\n        return true\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * is target promise or not. now check is es6 Promise only.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Promise<any>}\r\n */\r\nexport function isPromise(target: any): target is Promise<any> {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    let type = target.constructor || target.prototype.constructor;\r\n    if (type && type.name === 'Promise') {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * is target rxjs observable or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {boolean}\r\n */\r\nexport function isObservable(target: any): boolean {\r\n    if (!target && !isObject(target)) {\r\n        return false;\r\n    }\r\n    let type = target.constructor || target.prototype.constructor;\r\n    if (type && type.name === 'Observable') {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * is target base object or not.\r\n * eg. {}, have not self constructor;\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Promise<any>}\r\n */\r\nexport function isBaseObject(target: any): target is object {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    if (target.constructor && target.constructor.name === 'Object') {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * is metadata object or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @param {...(string|string[])[]} props\r\n * @returns {boolean}\r\n */\r\nexport function isMetadataObject(target: any, ...props: (string | string[])[]): boolean {\r\n    if (!isBaseObject(target)) {\r\n        return false;\r\n    }\r\n    if (props.length) {\r\n        return lang.keys(target).some(n => props.some(ps => isString(ps) ? ps === n : ps.indexOf(n) > 0));\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * is reftarget options or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is IRefTarget}\r\n */\r\nexport function isRefTarget(target: any): target is IRefTarget {\r\n    if (isBaseObject(target) !== true) {\r\n        return false\r\n    }\r\n    return isToken(target.target);\r\n}\r\n\r\n\r\n/**\r\n * check object is class metadata or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @param {...(string | string[])[]} extendsProps\r\n * @returns {boolean}\r\n */\r\nexport function isClassMetadata(target, ...extendsProps: (string | string[])[]): boolean {\r\n    return isMetadataObject(target, ...extendsProps.concat(['singleton', 'provide', 'alias', 'type']));\r\n}\r\n\r\n/**\r\n * check object is property metadata or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @param {...(string | string[])[]} extendsProps\r\n * @returns {boolean}\r\n */\r\nexport function isProvideMetadata(target, ...extendsProps: (string | string[])[]): boolean {\r\n    return isMetadataObject(target, ...extendsProps.concat(['type', 'provider']));\r\n}\r\n\r\n/**\r\n * check target is string or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is string}\r\n */\r\nexport function isString(target: any): target is string {\r\n    return typeof target === 'string';\r\n}\r\n\r\n/**\r\n * check target is boolean or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is boolean}\r\n */\r\nexport function isBoolean(target: any): target is boolean {\r\n    return typeof target === 'boolean' || (target === true || target === false);\r\n}\r\n\r\n/**\r\n * check target is number or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is number}\r\n */\r\nexport function isNumber(target: any): target is number {\r\n    return typeof target === 'number';\r\n}\r\n\r\n/**\r\n * check target is undefined or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is undefined}\r\n */\r\nexport function isUndefined(target: any): target is undefined {\r\n    return typeof target === 'undefined' || target === undefined;\r\n}\r\n\r\n/**\r\n * check target is unll or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is null}\r\n */\r\nexport function isNull(target: any): target is null {\r\n    return target === null;\r\n}\r\n\r\n/**\r\n * is target null or undefined.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {boolean}\r\n */\r\nexport function isNullOrUndefined(target): boolean {\r\n    return isNull(target) || isUndefined(target);\r\n}\r\n\r\n/**\r\n * check target is array or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Array<any>}\r\n */\r\nexport function isArray(target: any): target is Array<any> {\r\n    return Array.isArray(target);\r\n}\r\n\r\n/**\r\n * check target is object or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is object}\r\n */\r\nexport function isObject(target: any): target is object {\r\n    if (isNullOrUndefined(target)) {\r\n        return false;\r\n    }\r\n    let type = typeof target;\r\n    return type === 'object' || type === 'function';\r\n}\r\n\r\n/**\r\n * is custom class type instance or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {boolean}\r\n */\r\nexport function isTypeObject(target: any): boolean {\r\n    if (isNullOrUndefined(target)) {\r\n        return false;\r\n    }\r\n    if (typeof target !== 'object') {\r\n        return false;\r\n    }\r\n    let type = lang.getClass(target);\r\n    if (isBaseType(type)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * check target is date or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Date}\r\n */\r\nexport function isDate(target: any): target is Date {\r\n    return isObject(target) && target instanceof Date;\r\n}\r\n\r\n/**\r\n * check target is symbol or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Symbol}\r\n */\r\nexport function isSymbol(target: any): target is Symbol {\r\n    return typeof target === 'symbol' || (isObject(target) && /^Symbol\\(/.test(target.toString()));\r\n}\r\n\r\n/**\r\n * check target is regexp or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is RegExp}\r\n */\r\nexport function isRegExp(target: any): target is RegExp {\r\n    return target && target instanceof RegExp;\r\n}\r\n\r\n/**\r\n * is base type or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {boolean}\r\n */\r\nexport function isBaseType(target: any): boolean {\r\n    if (!isFunction(target)) {\r\n        return false;\r\n    }\r\n    return target === Object\r\n        || target === Boolean\r\n        || target === String\r\n        || target === Number\r\n        || target === Date;\r\n}\r\n","import { isFunction } from './typeCheck';\r\nimport { Express } from '../types';\r\n\r\n\r\n/**\r\n * defer\r\n *\r\n * @export\r\n * @class Defer\r\n * @template T\r\n */\r\nexport class Defer<T> {\r\n    static create<T>(then?: (val: T) => T | PromiseLike<T>): Defer<T> {\r\n        let defer = new Defer<T>();\r\n        if (then) {\r\n            defer.promise = defer.promise.then(then);\r\n            return defer;\r\n        } else {\r\n            return defer;\r\n        }\r\n    }\r\n    /**\r\n     * promise.\r\n     *\r\n     * @type {Promise<T>}\r\n     * @memberof Defer\r\n     */\r\n    promise: Promise<T>\r\n    /**\r\n     * resolve.\r\n     *\r\n     * @memberof Defer\r\n     */\r\n    resolve: (value?: T | PromiseLike<T>) => void;\r\n    /**\r\n     * reject.\r\n     *\r\n     * @memberof Defer\r\n     */\r\n    reject: (reason?: any) => void;\r\n\r\n    constructor() {\r\n        this.promise = new Promise<T>((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"Defer\",\"params\":{\"create\":[\"then\"],\"constructor\":[]}};\n                        }\n                   }\r\n\r\n/**\r\n * promise util.\r\n */\r\nexport namespace PromiseUtil {\r\n\r\n    /**\r\n     * create defer.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {((val: T) => T | PromiseLike<T>)} [then]\r\n     * @returns {Defer<T>}\r\n     */\r\n    export function defer<T>(then?: (val: T) => T | PromiseLike<T>): Defer<T> {\r\n        return Defer.create(then);\r\n    }\r\n\r\n    /**\r\n     * foreach opter for promises.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\r\n     * @param {Express<T, any>} express\r\n     * @param {T} [defVal]\r\n     * @returns\r\n     */\r\n    export function forEach<T>(promises: (T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[], express: Express<T, any>, defVal?: T) {\r\n        let defer = new Defer<string>();\r\n        let pf = Promise.resolve<T>(defVal);\r\n        let length = promises ? promises.length : 0;\r\n\r\n        if (length) {\r\n            promises.forEach((p, idx) => {\r\n                pf = pf.then(v => isFunction(p) ? p(v) : p)\r\n                    .then(data => {\r\n                        if (express(data) === false) {\r\n                            defer.resolve('complete');\r\n                            return Promise.reject<T>('complete');\r\n                        } else if (idx === length - 1) {\r\n                            defer.resolve('complete');\r\n                            return Promise.reject<T>('complete');\r\n                        }\r\n                        return data;\r\n                    });\r\n            });\r\n            pf.catch(err => {\r\n                return err;\r\n            });\r\n        } else {\r\n            defer.reject('array empty.');\r\n        }\r\n        return defer.promise;\r\n    }\r\n\r\n    /**\r\n     * run promise step by step.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\r\n     * @returns\r\n     */\r\n    export function step<T>(promises: (T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[]) {\r\n        let result = Promise.resolve<T>(null);\r\n        promises.forEach(p => {\r\n            result = result.then(v => isFunction(p) ? p(v) : p);\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * find first validate value from promises.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {(...(T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\r\n     * @param {Express<T, boolean>} validate\r\n     * @returns\r\n     */\r\n    export function find<T>(promises: (T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[], filter: Express<T, boolean>, defVal?: T) {\r\n        let defer = new Defer<T>();\r\n        forEach(promises, val => {\r\n            if (filter(val)) {\r\n                defer.resolve(val);\r\n                return false;\r\n            }\r\n            return true;\r\n        }, defVal)\r\n            .then(() => defer.resolve(null))\r\n            .catch(() => {\r\n                defer.resolve(null)\r\n            });\r\n        return defer.promise;\r\n    }\r\n\r\n    /**\r\n     *  action handle.\r\n     */\r\n    export type ActionHandle<T> = (ctx: T, next?: () => Promise<void>) => Promise<void>;\r\n\r\n    /**\r\n     * run action in chain.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {ActionHandle<T>[]} handles\r\n     * @param {T} ctx\r\n     * @param {() => Promise<void>} [next]\r\n     * @returns {Promise<void>}\r\n     */\r\n    export function runInChain<T>(handles: ActionHandle<T>[], ctx: T, next?: () => Promise<void>): Promise<void> {\r\n        let index = -1;\r\n        return dispatch(0);\r\n        function dispatch(idx: number): Promise<any> {\r\n            if (idx <= index) {\r\n                return Promise.reject('next called mutiple times');\r\n            }\r\n            index = idx;\r\n            let handle = idx < handles.length ? handles[idx] : null;\r\n            if (idx === handles.length) {\r\n                handle = next;\r\n            }\r\n            if (!handle) {\r\n                return Promise.resolve();\r\n            }\r\n            try {\r\n                return Promise.resolve(handle(ctx, dispatch.bind(null, idx + 1)));\r\n            } catch (err) {\r\n                return Promise.reject(err);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","export * from './typeCheck';\r\nexport * from './lang';\r\nexport * from './PromiseUtil';\r\n","import { Type, AbstractType, Token, SymbolType } from './types';\r\nimport { isClass, isFunction, lang } from './utils';\r\n\r\n\r\n/**\r\n * is registration class or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns\r\n */\r\nexport function isRegistrationClass(target: any): target is Type<Registration<any>> {\r\n    if (isClass(target)) {\r\n        return (<any>target).isIocRegClass === true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * inject token.\r\n * @export\r\n * @class Registration\r\n * @template T\r\n */\r\nexport class Registration<T> {\r\n    static readonly isIocRegClass = true;\r\n    protected type = '';\r\n    protected classType: SymbolType<any>;\r\n    protected desc: string;\r\n    /**\r\n     * Creates an instance of Registration.\r\n     * @param {(Token<T> | Token<any>)} provideType\r\n     * @param {string} desc\r\n     * @memberof Registration\r\n     */\r\n    constructor(provideType: Token<T> | Token<any>, desc: string) {\r\n        this.init(provideType, desc);\r\n    }\r\n\r\n    protected init(provideType: Token<T> | Token<any>, desc?: string) {\r\n        if (provideType instanceof Registration) {\r\n            if (desc) {\r\n                this.classType = provideType.toString();\r\n                this.desc = desc;\r\n            } else {\r\n                this.classType = provideType.getProvide();\r\n                this.desc = provideType.getDesc();\r\n            }\r\n        } else {\r\n            this.classType = provideType;\r\n            this.desc = desc;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get provide.\r\n     *\r\n     * @returns {SymbolType<any>}\r\n     * @memberof Registration\r\n     */\r\n    getProvide(): SymbolType<any> {\r\n        return this.classType;\r\n    }\r\n\r\n    /**\r\n     * get class.\r\n     *\r\n     * @returns\r\n     * @memberof Registration\r\n     */\r\n    getClass(): Type<T> | AbstractType<T> {\r\n        if (isClass(this.classType)) {\r\n            return this.classType;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * get desc.\r\n     *\r\n     * @returns\r\n     * @memberof Registration\r\n     */\r\n    getDesc() {\r\n        return this.desc;\r\n    }\r\n\r\n    /**\r\n     * to string.\r\n     *\r\n     * @returns {string}\r\n     * @memberof Registration\r\n     */\r\n    toString(): string {\r\n        return this.format(this);\r\n    }\r\n\r\n    protected format(reg: Token<T>): string {\r\n        if (reg instanceof Registration) {\r\n            let name = '';\r\n            if (isFunction(reg.classType)) {\r\n                name = `{${lang.getClassName(reg.classType)}}`;\r\n            }  else if (reg.classType) {\r\n                name = reg.classType.toString();\r\n            }\r\n            return [reg.type, name, reg.desc].filter(n => n).join('_');\r\n        } else if (isFunction(reg)) {\r\n            return `{${lang.getClassName(reg)}}`;\r\n        } else if (reg) {\r\n            return reg.toString();\r\n        }\r\n        return '';\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"Registration\",\"params\":{\"constructor\":[\"provideType\",\"desc\"],\"init\":[\"provideType\",\"desc\"],\"getProvide\":[],\"getClass\":[],\"getDesc\":[],\"toString\":[],\"format\":[\"reg\"]}};\n                        }\n                   }\r\n","import { Registration } from './Registration';\r\n\r\n/**\r\n * inject token.\r\n *\r\n * @export\r\n * @class InjectToken\r\n * @extends {Registration<T>}\r\n * @template T\r\n */\r\nexport class InjectToken<T> extends Registration<T> {\r\n    constructor(desc: string | symbol) {\r\n        super(desc, '');\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"InjectToken\",\"params\":{\"constructor\":[\"desc\"]}};\n                        }\n                   }\r\n","import {\r\n    Type, Token, Factory, SymbolType, Modules,\r\n    LoadType, ReferenceToken, RefTokenFac, RefTarget, ClassType, InstanceFactory\r\n} from './types';\r\nimport { IMethodAccessor } from './IMethodAccessor';\r\nimport { LifeScope } from './LifeScope';\r\nimport { InjectToken } from './InjectToken';\r\nimport { IContainerBuilder } from './IContainerBuilder';\r\nimport { IResolver, IResolverContainer } from './IResolver';\r\nimport { ResolverChain } from './resolves';\r\nimport { ParamProviders, IProviderParser, ProviderTypes } from './providers';\r\n\r\n/**\r\n * IContainer token.\r\n * it is a symbol id, you can use  @Inject, @Autowried or @Param to get container instance in yourself class.\r\n */\r\nexport const ContainerToken = new InjectToken<IContainer>('DI_IContainer');\r\n\r\n/**\r\n * resove way\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum ResoveWay {\r\n    /**\r\n     * current container.\r\n     */\r\n    current = 1,\r\n    /**\r\n     * traverse all curr node children.\r\n     */\r\n    traverse = 1 << 1,\r\n    /**\r\n     * bubble up all parent.\r\n     */\r\n    bubble = 1 << 2,\r\n    /**\r\n     * current and children.\r\n     */\r\n    nodes = current | traverse,\r\n    /**\r\n     * current and bubble.\r\n     */\r\n    routeup = current | bubble,\r\n    /**\r\n     *  traverse of curr node, children.\r\n     */\r\n    all = current | traverse | bubble\r\n}\r\n\r\n/**\r\n * container interface.\r\n *\r\n * @export\r\n * @interface IContainer\r\n */\r\nexport interface IContainer extends IMethodAccessor, IResolverContainer {\r\n\r\n    /**\r\n     * get or set parent container.\r\n     *\r\n     * @type {IContainer}\r\n     * @memberof IContainer\r\n     */\r\n    parent: IContainer;\r\n\r\n    /**\r\n     * children containers.\r\n     *\r\n     * @returns {IContainer[]}\r\n     * @memberof IContainer\r\n     */\r\n    children: IContainer[];\r\n\r\n    /**\r\n     * get root container.\r\n     *\r\n     * @returns {IContainer}\r\n     * @memberof IContainer\r\n     */\r\n    getRoot(): IContainer;\r\n\r\n    /**\r\n     * get provider parser.\r\n     *\r\n     * @returns {IProviderParser}\r\n     * @memberof IContainer\r\n     */\r\n    getProviderParser(): IProviderParser;\r\n\r\n    /**\r\n     * resolve chain.\r\n     *\r\n     * @type {ResolverChain}\r\n     * @memberof IContainer\r\n     */\r\n    getResolvers(): ResolverChain;\r\n\r\n    /**\r\n     * get container builder of this container.\r\n     *\r\n     * @returns {IContainerBuilder}\r\n     * @memberof IContainer\r\n     */\r\n    getBuilder(): IContainerBuilder;\r\n\r\n    /**\r\n     * current container has register.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} key\r\n     * @returns {boolean}\r\n     * @memberof IContainer\r\n     */\r\n    hasRegister<T>(key: Token<T>): boolean;\r\n\r\n    /**\r\n     * Retrieves an instance from the container based on the provided token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    get<T>(token: Token<T>, alias?: string, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * resolve token value in this container only.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    resolveValue<T>(token: Token<T>, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * resolve first token when not null.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>[]} tokens\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    resolveFirst<T>(tokens: Token<any>[], ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {(RefTarget | RefTarget[])} [target] service refrence target.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], target: RefTarget | RefTarget[], ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {(RefTarget | RefTarget[])} [target] service refrence target.\r\n     * @param {RefTokenFac<T>} toRefToken\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], target: RefTarget | RefTarget[], toRefToken: RefTokenFac<T>, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {(RefTarget | RefTarget[])} [target] service refrence target.\r\n     * @param {(boolean | Token<T>)} defaultToken\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], target: RefTarget | RefTarget[], defaultToken: boolean | Token<T>, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {(RefTarget | RefTarget[])} [target] service refrence target.\r\n     * @param {RefTokenFac<T>} toRefToken\r\n     * @param {(boolean | Token<T>)} defaultToken\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], target: RefTarget | RefTarget[], toRefToken: RefTokenFac<T>, defaultToken: boolean | Token<T>, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * get target reference service.\r\n     *\r\n     * @template T\r\n     * @param {ReferenceToken<T>} [refToken] reference service Registration Injector\r\n     * @param {(RefTarget | RefTarget[])} target  the service reference to.\r\n     * @param {Token<T>} [defaultToken] default service token.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getRefService<T>(refToken: ReferenceToken<T>, target: RefTarget | RefTarget[], defaultToken?: Token<T> | Token<any>[], ...providers: ParamProviders[]): T\r\n\r\n    /**\r\n     * get all service extends type.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n     * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getServices<T>(type: ClassType<T> | ((token: ClassType<T>) => boolean), resway?: ResoveWay, ...providers: ParamProviders[]): T[];\r\n\r\n    /**\r\n    * get all private services of target extends class `type`.\r\n    * @template T\r\n    * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n    * @param {(ClassType<any> | ClassType<any>[])} [target] service private of target.\r\n    * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n    * @param {...ParamProviders[]} providers\r\n    * @returns {T}\r\n    * @memberof IContainer\r\n    */\r\n    getServices<T>(type: Token<T> | ((token: ClassType<T>) => boolean), target: Token<any> | Token<any>[], resway?: ResoveWay, ...providers: ParamProviders[]): T[];\r\n\r\n    /**\r\n    * get all servies extends class `type` and all private services of target extends class `type`.\r\n    *\r\n    * @template T\r\n    * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n    * @param {(ClassType<any> | ClassType<any>[])} [target] service private of target.\r\n    * @param {boolean} both if true, will get all server and target private service of class extends `type` .\r\n    * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n    * @param {...ParamProviders[]} providers\r\n    * @returns {T}\r\n    * @memberof IContainer\r\n    */\r\n    getServices<T>(type: Token<T> | ((token: ClassType<T>) => boolean), target: Token<any> | Token<any>[], both: boolean, resway?: ResoveWay, ...providers: ParamProviders[]): T[];\r\n\r\n\r\n    /**\r\n     * iterator all service extends type.\r\n     *\r\n     * @template T\r\n     * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express\r\n     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n     * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    iteratorServices<T>(\r\n        express: (tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean,\r\n        type: ClassType<T> | ((token: ClassType<T>) => boolean),\r\n        resway?: ResoveWay,\r\n        ...providers: ParamProviders[]): void;\r\n\r\n    /**\r\n    * iterator all private services of target extends class `type`.\r\n    * @template T\r\n    * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express\r\n    * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n    * @param {(ClassType<any> | ClassType<any>[])} [target] service private of target.\r\n    * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n    * @param {...ParamProviders[]} providers\r\n    * @returns {T}\r\n    * @memberof IContainer\r\n    */\r\n    iteratorServices<T>(\r\n        express: (tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean,\r\n        type: Token<T> | ((token: ClassType<T>) => boolean),\r\n        target: Token<any> | Token<any>[],\r\n        resway?: ResoveWay,\r\n        ...providers: ParamProviders[]): void;\r\n\r\n    /**\r\n    * iterator all servies extends class `type` and all private services of target extends class `type`.\r\n    *\r\n    * @template T\r\n    * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express\r\n    * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n    * @param {(ClassType<any> | ClassType<any>[])} [target] service private of target.\r\n    * @param {boolean} both if true, will get all server and target private service of class extends `type` .\r\n    * @param {ResoveWay} [resway=ResoveWay.all] resolve way. bubble, traverse.\r\n    * @param {...ParamProviders[]} providers\r\n    * @returns {T}\r\n    * @memberof IContainer\r\n    */\r\n    iteratorServices<T>(\r\n        express: (tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean,\r\n        type: Token<T> | ((token: ClassType<T>) => boolean),\r\n        target: Token<any> | Token<any>[],\r\n        both: boolean,\r\n        resway?: ResoveWay,\r\n        ...providers: ParamProviders[]): void;\r\n\r\n\r\n    /**\r\n     * register type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {Factory<T>} [value]\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    register<T>(token: Token<T>, value?: Factory<T>): this;\r\n\r\n    /**\r\n     * register stingleton type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {Factory<T>} value\r\n     * @returns {this}\r\n     * @memberOf IContainer\r\n     */\r\n    registerSingleton<T>(token: Token<T>, value?: Factory<T>): this;\r\n\r\n    /**\r\n     * register value.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} value\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    registerValue<T>(token: Token<T>, value: T): this;\r\n\r\n    /**\r\n     * unregister value.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    unregisterValue<T>(token: Token<T>): this;\r\n\r\n    /**\r\n     * bind provider\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} provide\r\n     * @param {Token<T> | Factory<T>} provider\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindProvider<T>(provide: Token<T>, provider: Token<T> | Factory<T>): this;\r\n\r\n    /**\r\n     * bind providers.\r\n     *\r\n     * @param {...ProviderTypes[]} providers\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindProviders(...providers: ProviderTypes[]): this;\r\n\r\n    /**\r\n     * bind providers for only target class.\r\n     *\r\n     * @param {Token<any>} target\r\n     * @param {...ProviderTypes[]} providers\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindProviders<T>(target: Token<T>, ...providers: ProviderTypes[]): this;\r\n\r\n    /**\r\n     * bind providers for only target class.\r\n     *\r\n     * @param {Token<any>} target\r\n     * @param {(mapTokenKey: Token<any>) => void} onceBinded\r\n     * @param {...ProviderTypes[]} providers\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindProviders<T>(target: Token<T>, onceBinded: (mapTokenKey: Token<any>) => void, ...providers: ProviderTypes[]): this;\r\n\r\n    /**\r\n     * bind provider ref to target.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>} target\r\n     * @param {Token<T>} provide\r\n     * @param {(Token<T> | Factory<T>)} provider\r\n     * @param {string} [alias]\r\n     * @param {(refToken: Token<T>) => void} [onceBinded]\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindRefProvider<T>(target: Token<any>, provide: Token<T>, provider: Token<T> | Factory<T>, alias?: string, onceBinded?: (refToken: Token<T>) => void): this;\r\n\r\n    /**\r\n     * clear cache.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @memberof IContainer\r\n     */\r\n    clearCache(targetType: Type<any>);\r\n\r\n    /**\r\n     * get token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} target\r\n     * @param {string} [alias]\r\n     * @returns {Token<T>}\r\n     * @memberof IContainer\r\n     */\r\n    getToken<T>(target: Token<T>, alias?: string): Token<T>;\r\n\r\n    /**\r\n     * get tocken key.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {SymbolType<T>}\r\n     * @memberof IContainer\r\n     */\r\n    getTokenKey<T>(token: Token<T>, alias?: string): SymbolType<T>;\r\n\r\n    /**\r\n     * get token provider.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @returns {Type<T>}\r\n     * @memberof IContainer\r\n     */\r\n    getTokenProvider<T>(token: Token<T>): Type<T>;\r\n\r\n    /**\r\n     * iterate token  in  token class chain.  return false will break iterate.\r\n     *\r\n     * @param {RefTarget} target\r\n     * @param {(token: Token<any>, classProviders?: Token<any>[]) => boolean} express\r\n     * @memberof IContainer\r\n     */\r\n    forInRefTarget(target: RefTarget, express: (token: Token<any>, classProviders?: Token<any>[]) => boolean): void;\r\n\r\n    /**\r\n     * get token implement class and base classes.\r\n     *\r\n     * @param {Token<any>} token\r\n     * @param {boolean} [chain] get all base classes or only impletment class. default true.\r\n     * @returns {Token<any>[]}\r\n     * @memberof IContainer\r\n     */\r\n    getTokenClassChain(token: Token<any>, chain?: boolean): Token<any>[];\r\n\r\n    /**\r\n     * get life scope of container.\r\n     *\r\n     * @returns {LifeScope}\r\n     * @memberof IContainer\r\n     */\r\n    getLifeScope(): LifeScope;\r\n\r\n    /**\r\n     * use modules.\r\n     *\r\n     * @param {...Modules[]} modules\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    use(...modules: Modules[]): this;\r\n\r\n    /**\r\n     * load modules.\r\n     *\r\n     * @param {...LoadType[]} modules load modules.\r\n     * @returns {Promise<Type<any>[]>}  types loaded.\r\n     * @memberof IContainer\r\n     */\r\n    loadModule(...modules: LoadType[]): Promise<Type<any>[]>;\r\n\r\n    /**\r\n     * iterator all resovlers.\r\n     *\r\n     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean} callbackfn if callbackfn return false will break iterator.\r\n     * @param {boolean} [bubble=true]\r\n     * @memberof IContainer\r\n     */\r\n    iterator(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean, resway?: ResoveWay): void | boolean;\r\n\r\n}\r\n","import { Registration } from './Registration';\r\nimport { IContainer } from './IContainer';\r\nimport { ProviderTypes } from './providers';\r\n\r\n/**\r\n * module types.\r\n */\r\nexport type Modules = Type<any> | ObjectMap<any>;\r\n\r\n/**\r\n * load modules in base on an path.\r\n *\r\n * @export\r\n * @interface PathModules\r\n */\r\nexport interface PathModules {\r\n    /**\r\n     * fire express base on the root path.\r\n     *\r\n     * @type {string}\r\n     * @memberof LoadOptions\r\n     */\r\n    basePath?: string;\r\n    /**\r\n     * in nodejs:\r\n     * script files match express.\r\n     * see: https://github.com/isaacs/node-glob\r\n     *\r\n     * in browser:\r\n     * script file url.\r\n     * @type {(string | string[])}\r\n     * @memberof BuilderOptions\r\n     */\r\n    files?: string | string[];\r\n\r\n    /**\r\n     * modules\r\n     *\r\n     * @type {((Modules | string)[])}\r\n     * @memberof AsyncLoadOptions\r\n     */\r\n    modules?: (Modules | string)[];\r\n}\r\n\r\n\r\n/**\r\n * load module type.\r\n */\r\nexport type LoadType = Modules | string | PathModules;\r\n\r\n/**\r\n * class type.\r\n */\r\nexport type ClassType<T> = Type<T> | AbstractType<T>;\r\n/**\r\n * symbol type\r\n */\r\nexport type SymbolType<T> = ClassType<T> | string | symbol;\r\n\r\n/**\r\n * factory tocken.\r\n */\r\nexport type Token<T> = Registration<T> | SymbolType<T>;\r\n\r\n\r\n/**\r\n * instance factory.\r\n */\r\nexport type InstanceFactory<T> = (...providers: ProviderTypes[]) => T\r\n\r\n/**\r\n * to instance via container.\r\n */\r\nexport type ToInstance<T> = (container?: IContainer, ...providers: ProviderTypes[]) => T;\r\n\r\n/**\r\n * Factory of Token\r\n */\r\nexport type Factory<T> = T | Type<T> | ToInstance<T>;\r\n\r\n/**\r\n * object map.\r\n *\r\n * @export\r\n * @interface ObjectMap\r\n * @template T\r\n */\r\nexport interface ObjectMap<T> {\r\n    [index: string]: T\r\n}\r\n\r\n/**\r\n * class Annations\r\n *\r\n * @export\r\n * @interface ClassAnnations\r\n */\r\nexport interface ClassAnnations {\r\n    /**\r\n     * class name\r\n     *\r\n     * @type {string}\r\n     * @memberof ClassAnnations\r\n     */\r\n    name: string;\r\n    /**\r\n     * class params declaration.\r\n     *\r\n     * @type {ObjectMap<string[]>}\r\n     * @memberof ClassAnnations\r\n     */\r\n    params: ObjectMap<string[]>;\r\n}\r\n/**\r\n * class type\r\n * @export\r\n * @interface Type\r\n * @extends {Function}\r\n * @template T\r\n */\r\nexport interface Type<T> extends Function {\r\n    new(...args: any[]): T;\r\n    classAnnations?: ClassAnnations;\r\n    getClassAnnations?(): ClassAnnations;\r\n}\r\n\r\n/**\r\n * abstract type\r\n *\r\n * @export\r\n * @interface AbstractType\r\n * @extends {Function}\r\n * @template T\r\n */\r\nexport interface AbstractType<T> extends Function {\r\n    new?(...args: any[]): T;\r\n    classAnnations?: ClassAnnations;\r\n    getClassAnnations?(): ClassAnnations;\r\n}\r\n\r\n/**\r\n * ref service\r\n *\r\n * @export\r\n * @interface IRefService\r\n * @template T\r\n */\r\nexport interface IRefService<T> {\r\n    /**\r\n     * ref service\r\n     *\r\n     * @type {Token<T>}\r\n     * @memberof IReference\r\n     */\r\n    service: Token<T>;\r\n    /**\r\n     * is private service of target class or not.\r\n     *\r\n     * @type {boolean}\r\n     * @memberof IReference\r\n     */\r\n    isPrivate?: boolean;\r\n}\r\n\r\n/**\r\n * reference token type.\r\n */\r\nexport type RefTokenType<T> = IRefService<T> | Token<T>;\r\n\r\nexport type RefTokenFac<T> = (token: Token<any>) => RefTokenType<T> | RefTokenType<T>[];\r\n\r\nexport type RefTokenFacType<T> = Type<Registration<T>> | RefTokenType<T> | RefTokenFac<T>\r\n\r\n/**\r\n * reference token.\r\n */\r\nexport type ReferenceToken<T> = RefTokenFacType<T> | RefTokenFacType<T>[];\r\n\r\n/**\r\n * reference target level.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum RefTagLevel {\r\n    /**\r\n     * ref taget self only\r\n     */\r\n    self = 1,\r\n    /**\r\n     * ref taget provider.\r\n     */\r\n    providers = 1 << 1,\r\n    /**\r\n     * self provider\r\n     */\r\n    selfProviders = self | providers,\r\n    /**\r\n     * ref target class chain.\r\n     */\r\n    chain = 1 << 2,\r\n    /**\r\n     * self chain.\r\n     */\r\n     selfChain = self | chain,\r\n    /**\r\n     * chain providers.\r\n     */\r\n    chainProviders = chain | providers,\r\n    /**\r\n     * ref all.\r\n     */\r\n    all = self | providers | chain\r\n\r\n}\r\n\r\n/**\r\n * ref target\r\n *\r\n * @export\r\n * @interface IRefTarget\r\n */\r\nexport interface IRefTarget {\r\n    /**\r\n     * ref target.\r\n     *\r\n     * @type {Token<any>}\r\n     * @memberof IRefTarget\r\n     */\r\n    target: Token<any>;\r\n    /**\r\n     * ref target level.\r\n     *\r\n     * @type {RefTagLevel}\r\n     * @memberof IRefTarget\r\n     */\r\n    level: RefTagLevel;\r\n\r\n}\r\n\r\n/**\r\n * reference target.\r\n */\r\nexport type RefTarget = IRefTarget | Token<any> | Object;\r\n\r\n/**\r\n * express.\r\n *\r\n * @export\r\n * @interface Express\r\n * @template T\r\n * @template TResult\r\n */\r\nexport interface Express<T, TResult> {\r\n    (item: T): TResult\r\n}\r\n\r\n/**\r\n * express\r\n *\r\n * @export\r\n * @interface Express2\r\n * @template T1\r\n * @template T2\r\n * @template TResult\r\n */\r\nexport interface Express2<T1, T2, TResult> {\r\n    (arg1: T1, arg2: T2): TResult\r\n}\r\n/**\r\n * express\r\n *\r\n * @export\r\n * @interface Express3\r\n * @template T1\r\n * @template T2\r\n * @template T3\r\n * @template TResult\r\n */\r\nexport interface Express3<T1, T2, T3, TResult> {\r\n    (arg1: T1, arg2: T2, arg3: T3): TResult\r\n}\r\n/**\r\n * express\r\n *\r\n * @export\r\n * @interface Express4\r\n * @template T1\r\n * @template T2\r\n * @template T3\r\n * @template T4\r\n * @template TResult\r\n */\r\nexport interface Express4<T1, T2, T3, T4, TResult> {\r\n    (arg1: T1, arg2: T2, arg3: T3, arg4: T4): TResult\r\n}\r\n/**\r\n * express.\r\n *\r\n * @export\r\n * @interface Express5\r\n * @template T1\r\n * @template T2\r\n * @template T3\r\n * @template T4\r\n * @template T5\r\n * @template TResult\r\n */\r\nexport interface Express5<T1, T2, T3, T4, T5, TResult> {\r\n    (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): TResult\r\n}\r\n\r\n/**\r\n * State of type in ioc.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum IocState {\r\n    design = 'design',\r\n    runtime = 'runtime'\r\n}\r\n\r\n/**\r\n * iterate way.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum Mode {\r\n    /**\r\n     * route up. iterate in parents.\r\n     */\r\n    route = 1,\r\n    /**\r\n     * iterate in children.\r\n     */\r\n    children,\r\n    /**\r\n     * iterate as tree map. node first\r\n     */\r\n    traverse,\r\n\r\n    /**\r\n     * iterate as tree map. node last\r\n     */\r\n    traverseLast\r\n}\r\n","import { Token } from './types';\r\nimport { IParameter } from './IParameter';\r\nimport { InjectToken } from './InjectToken';\r\nimport { ParamProviders } from './providers';\r\n\r\n/**\r\n * IMethodAccessor interface symbol.\r\n * it is a symbol id, you can register yourself MethodAccessor for this.\r\n */\r\nexport const MethodAccessorToken = new InjectToken<IMethodAccessor>('DI_IMethodAccessor');\r\n\r\n/**\r\n * execution, invoke some type method.\r\n *\r\n * @export\r\n * @interface IExecution\r\n */\r\nexport interface IMethodAccessor {\r\n\r\n    /**\r\n     * try to async invoke the method of intance, if no instance will create by type.\r\n     *\r\n     * @template T\r\n     * @param {*} target\r\n     * @param {string} propertyKey\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {Promise<T>}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    invoke<T>(target: any, propertyKey: string, ...providers: ParamProviders[]): Promise<T>;\r\n\r\n    /**\r\n     * try to async invoke the method of intance, if no instance will create by type.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>} target\r\n     * @param {string} propertyKey\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {Promise<T>}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    invoke<T>(target: Token<any>, propertyKey: string, ...providers: ParamProviders[]): Promise<T>;\r\n\r\n    /**\r\n     * try to async invoke the method of intance, if no instance will create by type.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>} target\r\n     * @param {string} propertyKey\r\n     * @param {*} instance\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {Promise<T>}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    invoke<T>(target: Token<any>, propertyKey: string, instance: any, ...providers: ParamProviders[]): Promise<T>;\r\n\r\n    /**\r\n     * try to invoke the method of intance, if is token will create instance to invoke.\r\n     *\r\n     * @template T\r\n     * @param {*} target\r\n     * @param {string} propertyKey\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    syncInvoke<T>(target: any, propertyKey: string, ...providers: ParamProviders[]): T;\r\n    /**\r\n     * try create instance to invoke property method.\r\n     *\r\n     * @template T\r\n     * @param {*} target\r\n     * @param {string} propertyKey\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    syncInvoke<T>(target: any, propertyKey: string, ...providers: ParamProviders[]): T;\r\n\r\n    /**\r\n     * try to invoke the method of intance, if is token will create instance to invoke.\r\n     *\r\n     * @template T\r\n     * @param {*} target\r\n     * @param {string} propertyKey\r\n     * @param {*} instance\r\n     * @param {...ParamProviders[]} providers\r\n     * @memberof IMethodAccessor\r\n     */\r\n    syncInvoke<T>(target: any, propertyKey: string, instance: any, ...providers: ParamProviders[])\r\n\r\n    /**\r\n     * create params instances with IParameter and provider.\r\n     *\r\n     * @param {IParameter[]} params\r\n     * @param {...ParamProvider[]} providers\r\n     * @returns {any[]}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    createSyncParams(params: IParameter[], ...providers: ParamProviders[]): any[];\r\n\r\n    /**\r\n     * create params instances with IParameter and provider\r\n     *\r\n     * @param {IParameter[]} params\r\n     * @param {...AsyncParamProvider[]} providers\r\n     * @returns {Promise<any[]>}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    createParams(params: IParameter[], ...providers: ParamProviders[]): Promise<any[]>;\r\n}\r\n","import { Mode, Express } from '../types';\r\nimport { GComponent } from './GComponent';\r\n\r\n\r\n/**\r\n * null component.\r\n *\r\n * @export\r\n * @class NullComponent\r\n * @implements {IComponent}\r\n */\r\nexport class NullComponent implements GComponent<any> {\r\n\r\n    isEmpty(): boolean {\r\n        return true;\r\n    }\r\n    name: string;\r\n    parent?: any;\r\n    add(action: any): this {\r\n        return this;\r\n    }\r\n    remove(action: string | any): this {\r\n        return this;\r\n    }\r\n    find(express: any | Express<any, boolean>, mode?: Mode): any {\r\n        return NullNode;\r\n    }\r\n    filter(express: Express<any, boolean | void>, mode?: Mode): any[] {\r\n        return [];\r\n    }\r\n    each(express: Express<any, boolean | void>, mode?: Mode) {\r\n    }\r\n    trans(express: Express<any, boolean | void>) {\r\n    }\r\n    transAfter(express: Express<any, boolean | void>) {\r\n    }\r\n    routeUp(express: Express<any, boolean | void>) {\r\n    }\r\n    equals(node: any): boolean {\r\n        return node === NullNode;\r\n    }\r\n    empty() {\r\n        return NullNode;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"NullComponent\",\"params\":{\"isEmpty\":[],\"add\":[\"action\"],\"remove\":[\"action\"],\"find\":[\"express\",\"mode\"],\"filter\":[\"express\",\"mode\"],\"each\":[\"express\",\"mode\"],\"trans\":[\"express\"],\"transAfter\":[\"express\"],\"routeUp\":[\"express\"],\"equals\":[\"node\"],\"empty\":[]}};\n                        }\n                   }\r\n\r\n/**\r\n * Null node\r\n */\r\nexport const NullNode: GComponent<any> = new NullComponent();\r\n","import { Mode, Express } from '../types';\r\nimport { NullNode } from './NullComponent';\r\nimport { IComponent } from './IComponent';\r\nimport { isFunction, isString } from '../utils';\r\nimport { GComponent } from './GComponent';\r\n\r\n/**\r\n * generics composite\r\n *\r\n * @export\r\n * @class GComposite\r\n * @implements {GComponent<T>}\r\n * @template T\r\n */\r\nexport class GComposite<T extends IComponent> implements GComponent<T> {\r\n    parent: T;\r\n    protected children: T[];\r\n    constructor(public name: string) {\r\n        this.children = [];\r\n    }\r\n\r\n    add(node: T): this {\r\n        node.parent = this as IComponent;\r\n        this.children.push(node);\r\n        return this;\r\n\r\n    }\r\n\r\n    remove(node?: string | T): this {\r\n        let component: IComponent;\r\n        if (isString(node)) {\r\n            component = this.find(cmp => isString(node) ? cmp.name === node : cmp.equals(node));\r\n        } else if (node) {\r\n            component = node;\r\n        } else {\r\n            component = this as IComponent;\r\n        }\r\n\r\n        if (!component.parent) {\r\n            return this;\r\n        } else if (this.equals(component.parent as T)) {\r\n            this.children.splice(this.children.indexOf(component as T), 1);\r\n            component.parent = null;\r\n            return this;\r\n        } else {\r\n            component.parent.remove(component);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    find(express: T | Express<T, boolean>, mode?: Mode): T {\r\n        let component: any;\r\n        this.each(item => {\r\n            if (component) {\r\n                return false;\r\n            }\r\n            let isFinded = isFunction(express) ? express(item) : express === (item);\r\n            if (isFinded) {\r\n                component = item;\r\n                return false;\r\n            }\r\n            return true;\r\n        }, mode);\r\n        return (component || this.empty()) as T;\r\n    }\r\n\r\n    filter(express: Express<T, void | boolean>, mode?: Mode): T[] {\r\n        let nodes: IComponent[] = [];\r\n        this.each(item => {\r\n            if (express(item)) {\r\n                nodes.push(item);\r\n            }\r\n        }, mode);\r\n        return nodes as T[];\r\n    }\r\n\r\n    each(iterate: Express<T, boolean | void>, mode?: Mode) {\r\n        mode = mode || Mode.traverse;\r\n        let r;\r\n        switch (mode) {\r\n            case Mode.route:\r\n                r = this.routeUp(iterate);\r\n                break;\r\n            case Mode.children:\r\n                r = this.eachChildren(iterate);\r\n                break;\r\n\r\n            case Mode.traverse:\r\n                r = this.trans(iterate);\r\n                break;\r\n            case Mode.traverseLast:\r\n                r = this.transAfter(iterate);\r\n                break;\r\n            default:\r\n                r = this.trans(iterate);\r\n                break;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    eachChildren(iterate: Express<T, void | boolean>) {\r\n        (this.children || []).forEach(item => {\r\n            return iterate(item as T);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *do express work in routing.\r\n     *\r\n     *@param {Express<T, void | boolean>} express\r\n     *\r\n     *@memberOf IComponent\r\n     */\r\n    routeUp(iterate: Express<T, void | boolean>) {\r\n        let curr = this as IComponent;\r\n        if (iterate(curr as T) === false) {\r\n            return false;\r\n        };\r\n        if (this.parent && this.parent.routeUp) {\r\n            return this.parent.routeUp(iterate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *translate all sub context to do express work.\r\n     *\r\n     *@param {Express<T, void | boolean>} express\r\n     *\r\n     *@memberOf IComponent\r\n     */\r\n    trans(express: Express<T, void | boolean>) {\r\n        let curr = this as IComponent;\r\n        if (express(curr as T) === false) {\r\n            return false;\r\n        }\r\n        let children = this.children || [];\r\n        for (let i = 0; i < children.length; i++) {\r\n            let result = children[i].trans(express);\r\n            if (result === false) {\r\n                return result;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    transAfter(express: Express<T, void | boolean>) {\r\n        let children = this.children || []\r\n        for (let i = 0; i < children.length; i++) {\r\n            let result = children[i].transAfter(express);\r\n            if (result === false) {\r\n                return false;\r\n            }\r\n        }\r\n        let curr = this as IComponent;\r\n        if (express(curr as T) === false) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    equals(node: T): boolean {\r\n        return this === node as IComponent;\r\n    }\r\n\r\n    empty(): T {\r\n        return NullNode as T;\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        return this.equals(this.empty() as T);\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"GComposite\",\"params\":{\"constructor\":[\"name\"],\"add\":[\"node\"],\"remove\":[\"node\"],\"find\":[\"express\",\"mode\"],\"filter\":[\"express\",\"mode\"],\"each\":[\"iterate\",\"mode\"],\"eachChildren\":[\"iterate\"],\"routeUp\":[\"iterate\"],\"trans\":[\"express\"],\"transAfter\":[\"express\"],\"equals\":[\"node\"],\"empty\":[],\"isEmpty\":[]}};\n                        }\n                   }\r\n","import { Mode, Express } from '../types';\r\nimport { IComponent } from './IComponent';\r\nimport { GComposite } from './GComposite';\r\n\r\n/**\r\n * compoiste.\r\n *\r\n * @export\r\n * @class Composite\r\n * @implements {IComponent}\r\n */\r\nexport class Composite extends GComposite<IComponent> implements IComponent {\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    find<T extends IComponent>(express: T | Express<T, boolean>, mode?: Mode): T {\r\n        return super.find(express, mode) as T;\r\n    }\r\n    filter<T extends IComponent>(express: Express<T, boolean | void>, mode?: Mode): T[] {\r\n        return super.filter(express, mode) as T[];\r\n    }\r\n    each<T extends IComponent>(express: Express<T, boolean | void>, mode?: Mode) {\r\n        return super.each(express, mode);\r\n    }\r\n    eachChildren<T extends IComponent>(express: Express<T, void | boolean>) {\r\n        super.eachChildren(express);\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"Composite\",\"params\":{\"constructor\":[\"name\"],\"find\":[\"express\",\"mode\"],\"filter\":[\"express\",\"mode\"],\"each\":[\"express\",\"mode\"],\"eachChildren\":[\"express\"]}};\n                        }\n                   }\r\n","export * from  './Composite';\r\nexport * from './IComponent';\r\nexport * from './GComponent';\r\nexport * from './GComposite';\r\nexport * from './NullComponent';\r\n","import { ActionComponent } from './ActionComponent';\r\nimport { ActionData } from '../ActionData';\r\nimport { IContainer } from '../../IContainer';\r\nimport { NullComponent } from '../../components';\r\n\r\n/**\r\n * Null action.\r\n *\r\n * @class NullActionClass\r\n * @extends {NullComponent}\r\n * @implements {ActionComponent}\r\n */\r\nclass NullActionClass extends NullComponent implements ActionComponent {\r\n\r\n    insert(action: ActionComponent, index: number): this {\r\n        return this;\r\n    }\r\n    execute<T>(container: IContainer, data: ActionData<T>, name?: string) {\r\n\r\n    }\r\n\r\n    empty() {\r\n        return NullAction;\r\n    }\r\n\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"NullActionClass\",\"params\":{\"insert\":[\"action\",\"index\"],\"execute\":[\"container\",\"data\",\"name\"],\"empty\":[]}};\n                        }\n                   }\r\n\r\n/**\r\n * Null Action\r\n */\r\nexport const NullAction: ActionComponent = new NullActionClass();\r\n","import { ActionData } from '../ActionData';\r\nimport { NullAction } from './NullAction';\r\nimport { ActionComponent } from './ActionComponent';\r\nimport { Metadate } from '../metadatas';\r\nimport { IContainer } from '../../IContainer';\r\nimport { GComposite } from '../../components';\r\n\r\n/**\r\n * action composite\r\n *\r\n * @export\r\n * @class ActionComposite\r\n * @extends {GComposite<ActionComponent>}\r\n * @implements {ActionComponent}\r\n */\r\nexport class ActionComposite extends GComposite<ActionComponent> implements ActionComponent {\r\n\r\n    parent: ActionComponent;\r\n    protected children: ActionComponent[];\r\n    constructor(name: string) {\r\n        super(name);\r\n        this.children = [];\r\n    }\r\n\r\n    insert(node: ActionComponent, index: number): this {\r\n        node.parent = this;\r\n        if (index < 0) {\r\n            index = 0;\r\n        } else if (index >= this.children.length) {\r\n            index = this.children.length - 1;\r\n        }\r\n        this.children.splice(index, 0, node);\r\n        return this;\r\n    }\r\n\r\n    execute(container: IContainer, data: ActionData<Metadate>, name?: string) {\r\n        if (name) {\r\n            this.find(it => it.name === name)\r\n                .execute(container, data);\r\n        } else {\r\n            this.trans(action => {\r\n                if (action instanceof ActionComposite) {\r\n                    action.working(container, data);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    empty() {\r\n        return NullAction;\r\n    }\r\n\r\n    protected working(container: IContainer, data: ActionData<any>) {\r\n        // do nothing.\r\n    }\r\n\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ActionComposite\",\"params\":{\"constructor\":[\"name\"],\"insert\":[\"node\",\"index\"],\"execute\":[\"container\",\"data\",\"name\"],\"empty\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n","\r\n/**\r\n * life state.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum LifeState {\r\n\r\n    /**\r\n     * before create constructor Args\r\n     */\r\n    beforeCreateArgs = 'beforeCreateArgs',\r\n\r\n    /**\r\n     * before constructor advice action.\r\n     */\r\n    beforeConstructor = 'beforeConstructor',\r\n\r\n    /**\r\n     * after constructor advice action.\r\n     */\r\n    afterConstructor = 'afterConstructor',\r\n\r\n    /**\r\n     * on init.\r\n     */\r\n    onInit = 'onInit',\r\n\r\n    /**\r\n     * after init.\r\n     */\r\n    AfterInit = 'AfterInit'\r\n}\r\n","/**\r\n * cores decorator actions\r\n *\r\n * @export\r\n */\r\nexport enum CoreActions {\r\n    /**\r\n     * the action bind parameter type form metadata.\r\n     */\r\n    bindParameterType = 'bindParameterType',\r\n\r\n    /**\r\n     * the action bind Property type from metadata.\r\n     */\r\n    bindPropertyType = 'bindPropertyType',\r\n\r\n    /**\r\n     * inject property action.\r\n     */\r\n    injectProperty = 'injectProperty',\r\n\r\n    /**\r\n     * class provider bind action.\r\n     */\r\n    bindProvider = 'bindProvider',\r\n\r\n    /**\r\n     * bind parameter provider action.\r\n     */\r\n    bindParameterProviders = 'bindParameterProviders',\r\n\r\n    /**\r\n     * cache action.\r\n     */\r\n    cache = 'cache',\r\n\r\n    /**\r\n     * component init action.  after constructor befor property inject.\r\n     */\r\n    componentBeforeInit = 'componentBeforeInit',\r\n\r\n    /**\r\n     * component on init hooks. after property inject.\r\n     */\r\n    componentInit = 'componentInit',\r\n\r\n    /**\r\n     * component after init hooks. after component init.\r\n     */\r\n    componentAfterInit = 'componentAfterInit',\r\n\r\n    /**\r\n     * singleton action.\r\n     */\r\n    singletion = 'singletion',\r\n\r\n    /**\r\n     * autorun action.\r\n     */\r\n    autorun = 'autorun',\r\n\r\n    /**\r\n     * method autorun action.\r\n     */\r\n    methodAutorun = 'methodAutorun'\r\n}\r\n","import { Metadate } from '../metadatas';\r\nimport { lang, isMetadataObject } from '../../utils';\r\n\r\n\r\n/**\r\n * arg checker.\r\n *\r\n * @export\r\n * @interface CheckExpress\r\n * @template T\r\n */\r\nexport interface CheckExpress<T extends Metadate> {\r\n    /**\r\n     * arg matched or not.\r\n     *\r\n     * @param {*} arg\r\n     * @returns {boolean}\r\n     * @memberof CheckExpress\r\n     */\r\n    match(arg: any): boolean;\r\n    /**\r\n     * arg is meatdata or not.\r\n     *\r\n     * @param {*} arg\r\n     * @returns {boolean}\r\n     * @memberof CheckExpress\r\n     */\r\n    isMetadata?(arg: any): boolean;\r\n    /**\r\n     * set arg to metadata.\r\n     *\r\n     * @param {T} metadata\r\n     * @param {*} arg\r\n     * @memberof CheckExpress\r\n     */\r\n    setMetadata(metadata: T, arg: any): void\r\n}\r\n\r\n/**\r\n * args iterator.s\r\n *\r\n * @export\r\n * @class ArgsIterator\r\n */\r\nexport class ArgsIterator {\r\n    private idx: number;\r\n    private metadata: Metadate;\r\n    constructor(protected args: any[]) {\r\n        this.idx = -1;\r\n        this.metadata = null;\r\n    }\r\n\r\n    isCompeted(): boolean {\r\n        return this.idx >= this.args.length;\r\n    }\r\n\r\n    end() {\r\n        this.idx = this.args.length;\r\n    }\r\n\r\n    next<T>(express: CheckExpress<T>) {\r\n        this.idx++;\r\n        if (this.isCompeted()) {\r\n            return null;\r\n        }\r\n\r\n        let arg = this.args[this.idx];\r\n        if (express.isMetadata && express.isMetadata(arg)) {\r\n            this.metadata = lang.assign(this.metadata || {}, arg);\r\n            this.end();\r\n        } else if (express.match(arg)) {\r\n            this.metadata = this.metadata || {};\r\n            express.setMetadata(this.metadata as T, arg);\r\n        } else if (isMetadataObject(arg)) { // when match failed then check is base metadata.\r\n            this.metadata = lang.assign(this.metadata || {}, arg);\r\n            this.end();\r\n        } else {\r\n            this.end();\r\n        }\r\n    }\r\n\r\n    getArgs() {\r\n        return this.args;\r\n    }\r\n\r\n    getMetadata() {\r\n        return this.metadata;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ArgsIterator\",\"params\":{\"constructor\":[\"args\"],\"isCompeted\":[],\"end\":[],\"next\":[\"express\"],\"getArgs\":[],\"getMetadata\":[]}};\n                        }\n                   }\r\n\r\n","/**\r\n * decorator type category.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum DecoratorType {\r\n    /**\r\n     * Class decorator\r\n     */\r\n    Class = 1 << 0,\r\n    /**\r\n     * Parameter decorator\r\n     */\r\n    Parameter = 1 << 1,\r\n    /**\r\n     * Property decorator\r\n     */\r\n    Property = 1 << 2,\r\n    /**\r\n     * Method decorator\r\n     */\r\n    Method = 1 << 3,\r\n    /**\r\n     * decorator for any where.\r\n     */\r\n    All = Class | Parameter | Property | Method\r\n}\r\n","import 'reflect-metadata';\r\nimport { PropertyMetadata, MethodMetadata, ParameterMetadata, Metadate, ClassMetadata } from '../metadatas';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport {\r\n    isClass, isAbstractClass, isMetadataObject, isUndefined, isFunction,\r\n    isNumber, isArray, lang, isString\r\n} from '../../utils';\r\nimport { Type, AbstractType, ObjectMap, ClassType } from '../../types';\r\n\r\n\r\nexport const ParamerterName = 'paramerter_names';\r\n\r\nexport interface MetadataAdapter {\r\n    (args: ArgsIterator);\r\n}\r\n\r\n/**\r\n * extend metadata.\r\n *\r\n * @export\r\n * @interface MetadataExtends\r\n * @template T\r\n */\r\nexport interface MetadataExtends<T> {\r\n    (metadata: T): void;\r\n}\r\n\r\nexport interface MetadataTarget<T> {\r\n    (target: Type<any> | object): Type<any> | object\r\n}\r\n\r\n/**\r\n * decorator for all.\r\n *\r\n * @export\r\n * @interface IDecorator\r\n * @template T\r\n */\r\nexport interface IDecorator<T extends Metadate> {\r\n    /**\r\n     * define decorator setting with params.\r\n     *\r\n     * @param {(Type<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     */\r\n    (provider: string | symbol | Type<any>, alias?: string): any;\r\n    /**\r\n     * define decorator setting with metadata map.\r\n     *\r\n     * @param {T} [metadata] metadata map.\r\n     */\r\n    (metadata?: T): any;\r\n    (target: Type<any>): void;\r\n    (target: object, propertyKey: string | symbol): void;\r\n    (target: object, propertyKey: string | symbol, parameterIndex: number): void;\r\n    (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n/**\r\n * create dectorator for class params props methods.\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {*}\r\n */\r\nexport function createDecorator<T>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): any {\r\n    let metaName = `@${name}`;\r\n\r\n    let factory = (...args: any[]) => {\r\n        let metadata: T = null;\r\n        if (args.length < 1) {\r\n            return (...args: any[]) => {\r\n                return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n            }\r\n        }\r\n        metadata = argsToMetadata(args, adapter);\r\n        if (metadata) {\r\n            return (...args: any[]) => {\r\n                return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n            }\r\n        } else {\r\n            if (args.length === 1) {\r\n                if (!isClass(args[0])) {\r\n                    return (...args: any[]) => {\r\n                        return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n    }\r\n\r\n    factory.toString = () => metaName;\r\n    (<any>factory).decoratorType = DecoratorType.All;\r\n    return factory;\r\n}\r\n\r\nfunction argsToMetadata<T>(args: any[], adapter?: MetadataAdapter): T {\r\n    let metadata: T = null;\r\n    if (args.length) {\r\n        if (adapter) {\r\n            let iterator = new ArgsIterator(args);\r\n            adapter(iterator);\r\n            metadata = iterator.getMetadata() as T;\r\n        } else if (args.length === 1 && isMetadataObject(args[0])) {\r\n            metadata = args[0];\r\n        }\r\n    }\r\n    return metadata;\r\n}\r\n\r\n\r\nfunction storeMetadata<T>(name: string, metaName: string, args: any[], metadata?: any, metadataExtends?: MetadataExtends<T>) {\r\n    let target;\r\n    switch (args.length) {\r\n        case 1:\r\n            target = args[0];\r\n            if (isClass(target) || isAbstractClass(target)) {\r\n                setTypeMetadata(name, metaName, target, metadata, metadataExtends);\r\n                return target;\r\n            }\r\n            break;\r\n        case 2:\r\n            target = args[0];\r\n            let propertyKey = args[1];\r\n            setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);\r\n            break;\r\n        case 3:\r\n            if (isNumber(args[2])) {\r\n                target = args[0];\r\n                let propertyKey = args[1];\r\n                let parameterIndex = args[2];\r\n                setParamMetadata(name, metaName, target, propertyKey, parameterIndex, metadata, metadataExtends);\r\n            } else if (isUndefined(args[2])) {\r\n                target = args[0];\r\n                let propertyKey = args[1];\r\n                setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);\r\n            } else {\r\n                target = args[0];\r\n                let propertyKey = args[1];\r\n                let descriptor = args[2];\r\n                setMethodMetadata(name, metaName, target, propertyKey, descriptor, metadata, metadataExtends);\r\n                return descriptor;\r\n            }\r\n            break;\r\n        default:\r\n            throw new Error(`Invalid @${name} Decorator declaration.`);\r\n    }\r\n}\r\n\r\n/**\r\n * get type decorators of class.\r\n *\r\n * @export\r\n * @param {(Type<any> | AbstractType<any>)} target\r\n * @returns {string[]}\r\n */\r\nexport function getClassDecorators(target: Type<any> | AbstractType<any>): string[] {\r\n    return Reflect.getOwnMetadataKeys(target)\r\n        .filter(d => {\r\n            if (!(d && isString(d))) {\r\n                return false;\r\n            }\r\n            if (!/^@/.test(d)) {\r\n                return false;\r\n            }\r\n            return !/__\\w+$/.test(d);\r\n        });\r\n}\r\n\r\n/**\r\n * get type decorators of class.\r\n *\r\n * @export\r\n * @param {(Type<any> | AbstractType<any>)} target\r\n * @returns {string[]}\r\n */\r\nexport function getMethodDecorators(target: Type<any> | AbstractType<any>): string[] {\r\n    return Reflect.getMetadataKeys(target)\r\n        .filter(d => d && isString(d) && /^@\\S+__method$/.test(d))\r\n        .map(d => d.replace(/__method$/ig, ''));\r\n}\r\n\r\n\r\n/**\r\n * get type decorators of class.\r\n *\r\n * @export\r\n * @param {(Type<any> | AbstractType<any>)} target\r\n * @returns {string[]}\r\n */\r\nexport function getPropDecorators(target: Type<any> | AbstractType<any>): string[] {\r\n    return Reflect.getMetadataKeys(target)\r\n        .filter(d => d && isString(d) && /^@\\S+__props$/.test(d))\r\n        .map(d => d.replace(/__props$/ig, ''));\r\n}\r\n\r\n/**\r\n * get type decorators of class.\r\n *\r\n * @export\r\n * @param {(Type<any> | AbstractType<any>)} target\r\n * @returns {string[]}\r\n */\r\nexport function getParamDecorators(target: any, propertyKey?: string): string[] {\r\n    return ((propertyKey && propertyKey !== 'constructor') ? Reflect.getMetadataKeys(target, propertyKey) : Reflect.getOwnMetadataKeys(lang.getClass(target)) || [])\r\n        .filter(d => d && isString(d) && /^@\\S+__params$/.test(d))\r\n        .map((d: string) => d.replace(/__params$/ig, ''));\r\n}\r\n\r\n/**\r\n * get all class metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns\r\n */\r\nexport function getTypeMetadata<T>(decorator: string | Function, target: Type<any> | AbstractType<T>): T[] {\r\n    let annotations = Reflect.getOwnMetadata(isFunction(decorator) ? decorator.toString() : decorator, target);\r\n    annotations = isArray(annotations) ? annotations : [];\r\n    return annotations;\r\n}\r\n\r\n/**\r\n * get own class metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns\r\n */\r\nexport function getOwnTypeMetadata<T>(decorator: string | Function, target: Type<any> | AbstractType<T>): T[] {\r\n    let annotations = Reflect.getOwnMetadata(isFunction(decorator) ? decorator.toString() : decorator, target);\r\n    annotations = isArray(annotations) ? annotations : [];\r\n    return annotations;\r\n}\r\n\r\n/**\r\n * has class decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @returns {boolean}\r\n */\r\nexport function hasClassMetadata(decorator: string | Function, target: Type<any> | object): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasMetadata(name, target);\r\n}\r\n\r\n/**\r\n * has own class decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @returns {boolean}\r\n */\r\nexport function hasOwnClassMetadata(decorator: string | Function, target: Type<any> | object): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasOwnMetadata(name, target);\r\n}\r\n\r\n\r\nfunction setTypeMetadata<T extends ClassMetadata>(name: string, metaName: string, target: Type<T> | AbstractType<T>, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n    let annotations = getOwnTypeMetadata(metaName, target).slice(0);\r\n    let typeMetadata = (metadata || {}) as T;\r\n    if (!typeMetadata.type) {\r\n        typeMetadata.type = target;\r\n    }\r\n    typeMetadata.decorator = name;\r\n\r\n    if (metadataExtends) {\r\n        metadataExtends(typeMetadata);\r\n    }\r\n    annotations.unshift(typeMetadata);\r\n\r\n    setParamerterNames(target);\r\n    Reflect.defineMetadata(metaName, annotations, target);\r\n}\r\n\r\nlet methodMetadataExt = '__method';\r\n/**\r\n * get all method metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getMethodMetadata<T extends MethodMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getMetadata(name + methodMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getMetadata(name + methodMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n/**\r\n * get own method metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getOwnMethodMetadata<T extends MethodMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getOwnMetadata(name + methodMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getOwnMetadata(name + methodMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n/**\r\n * has own method decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @param {(string | symbol)} [propertyKey]\r\n * @returns {boolean}\r\n */\r\nexport function hasOwnMethodMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    if (propertyKey) {\r\n        let meta = getOwnMethodMetadata<any>(name, target);\r\n        return meta && meta.hasOwnProperty(propertyKey);\r\n    } else {\r\n        return Reflect.hasOwnMetadata(name + methodMetadataExt, target);\r\n    }\r\n}\r\n\r\n/**\r\n * has method decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @param {(string | symbol)} [propertyKey]\r\n * @returns {boolean}\r\n */\r\nexport function hasMethodMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    if (propertyKey) {\r\n        let meta = getMethodMetadata<any>(name, target);\r\n        return meta && meta.hasOwnProperty(propertyKey);\r\n    } else {\r\n        return Reflect.hasMetadata(name + methodMetadataExt, target);\r\n    }\r\n}\r\n\r\nfunction setMethodMetadata<T extends MethodMetadata>(name: string, metaName: string, target: Type<T>, propertyKey: string, descriptor: TypedPropertyDescriptor<T>, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n    let meta = lang.assign({}, getOwnMethodMetadata(metaName, target));\r\n    meta[propertyKey] = meta[propertyKey] || [];\r\n\r\n    let methodMeadata = (metadata || {}) as T;\r\n    methodMeadata.decorator = name;\r\n    methodMeadata.propertyKey = propertyKey;\r\n    // methodMeadata.descriptor = descriptor;\r\n\r\n    if (metadataExtends) {\r\n        metadataExtends(methodMeadata);\r\n    }\r\n    meta[propertyKey].unshift(methodMeadata);\r\n    Reflect.defineMetadata(metaName + methodMetadataExt, meta, target.constructor);\r\n}\r\n\r\nlet propertyMetadataExt = '__props';\r\n/**\r\n * get all property metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getPropertyMetadata<T extends PropertyMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getMetadata(name + propertyMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getMetadata(name + propertyMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n/**\r\n * get own property metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getOwnPropertyMetadata<T extends PropertyMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n\r\n/**\r\n * has property decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @param {(string | symbol)} [propertyKey]\r\n * @returns {boolean}\r\n */\r\nexport function hasPropertyMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    if (propertyKey) {\r\n        let meta = getPropertyMetadata<any>(name, target);\r\n        return meta && meta.hasOwnProperty(propertyKey);\r\n    } else {\r\n        return Reflect.hasMetadata(name + propertyMetadataExt, target);\r\n    }\r\n}\r\n\r\nfunction setPropertyMetadata<T extends PropertyMetadata>(name: string, metaName: string, target: Type<T>, propertyKey: string, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n    let meta = lang.assign({}, getOwnPropertyMetadata(metaName, target));\r\n    let propmetadata = (metadata || {}) as T;\r\n\r\n    propmetadata.propertyKey = propertyKey;\r\n    propmetadata.decorator = name;\r\n    if (!propmetadata.type) {\r\n        let t = Reflect.getMetadata('design:type', target, propertyKey);\r\n        if (!t) {\r\n            // Needed to support react native inheritance\r\n            t = Reflect.getMetadata('design:type', target.constructor, propertyKey);\r\n        }\r\n        propmetadata.type = t;\r\n    }\r\n\r\n    if (metadataExtends) {\r\n        metadataExtends(propmetadata);\r\n    }\r\n\r\n    if (!meta[propertyKey] || !isArray(meta[propertyKey])) {\r\n        meta[propertyKey] = [];\r\n    }\r\n\r\n    meta[propertyKey].unshift(propmetadata);\r\n    Reflect.defineMetadata(metaName + propertyMetadataExt, meta, target.constructor);\r\n}\r\n\r\n\r\nlet paramsMetadataExt = '__params';\r\n/**\r\n * get paramerter metadata of one specail decorator in target method.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {T[][]}\r\n */\r\nexport function getParamMetadata<T extends ParameterMetadata>(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): T[][] {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let parameters = Reflect.getMetadata(name + paramsMetadataExt, target, propertyKey);\r\n    parameters = isArray(parameters) ? parameters : [];\r\n    return parameters;\r\n}\r\n\r\n/**\r\n * get own paramerter metadata of one specail decorator in target method.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {T[][]}\r\n */\r\nexport function getOwnParamMetadata<T extends ParameterMetadata>(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): T[][] {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let parameters = Reflect.getOwnMetadata(name + paramsMetadataExt, target, propertyKey);\r\n    parameters = isArray(parameters) ? parameters : [];\r\n    return parameters;\r\n}\r\n\r\n/**\r\n * has param decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {boolean}\r\n */\r\nexport function hasParamMetadata(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasMetadata(name + paramsMetadataExt, target, propertyKey);\r\n}\r\n\r\n/**\r\n * has param decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {boolean}\r\n */\r\nexport function hasOwnParamMetadata(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasOwnMetadata(name + paramsMetadataExt, target, propertyKey);\r\n}\r\n\r\n\r\nfunction setParamMetadata<T extends ParameterMetadata>(name: string, metaName: string, target: Type<T>, propertyKey: string, parameterIndex: number, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n\r\n    let parameters: any[][] = getOwnParamMetadata(metaName, target, propertyKey).slice(0);\r\n    // there might be gaps if some in between parameters do not have annotations.\r\n    // we pad with nulls.\r\n    while (parameters.length <= parameterIndex) {\r\n        parameters.push(null);\r\n    }\r\n\r\n    parameters[parameterIndex] = parameters[parameterIndex] || [];\r\n\r\n    let paramMeadata = (metadata || {}) as ParameterMetadata;\r\n\r\n    if (!paramMeadata.type) {\r\n        let t = Reflect.getOwnMetadata('design:type', target, propertyKey);\r\n        if (!t) {\r\n            // Needed to support react native inheritance\r\n            t = Reflect.getOwnMetadata('design:type', target.constructor, propertyKey);\r\n        }\r\n        paramMeadata.type = t;\r\n    }\r\n    paramMeadata.propertyKey = propertyKey;\r\n    paramMeadata.decorator = name;\r\n    paramMeadata.index = parameterIndex;\r\n    if (metadataExtends) {\r\n        metadataExtends(paramMeadata);\r\n    }\r\n    parameters[parameterIndex].unshift(paramMeadata);\r\n    Reflect.defineMetadata(metaName + paramsMetadataExt, parameters, target, propertyKey);\r\n}\r\n\r\n\r\n\r\nexport function getParamerterNames(target: Type<any> | AbstractType<any>): ObjectMap<string[]> {\r\n    let meta = Reflect.getMetadata(ParamerterName, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getMetadata(ParamerterName, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\nexport function getOwnParamerterNames(target: Type<any> | AbstractType<any>): ObjectMap<string[]> {\r\n    let meta = Reflect.getOwnMetadata(ParamerterName, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getOwnMetadata(ParamerterName, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\nexport function setParamerterNames(target: ClassType<any>) {\r\n    let meta = lang.assign({}, getParamerterNames(target));\r\n    let descriptors = Object.getOwnPropertyDescriptors(target.prototype);\r\n    let isUglify = /^[a-z]/.test(target.name);\r\n    let anName = '';\r\n    let classAnnations = lang.getClassAnnations(target);\r\n\r\n    if (classAnnations && classAnnations.params) {\r\n        anName = classAnnations.name;\r\n        meta = lang.assign(meta, classAnnations.params);\r\n    }\r\n    if (!isUglify && target.name !== anName) {\r\n        lang.forIn(descriptors, (item, name) => {\r\n            if (name !== 'constructor') {\r\n                if (item.value) {\r\n                    meta[name] = getParamNames(item.value)\r\n                }\r\n                if (item.set) {\r\n                    meta[name] = getParamNames(item.set);\r\n                }\r\n            }\r\n        });\r\n        meta['constructor'] = getParamNames(target.prototype.constructor);\r\n    }\r\n\r\n    Reflect.defineMetadata(ParamerterName, meta, target);\r\n}\r\n\r\nconst STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\r\nconst ARGUMENT_NAMES = /([^\\s,]+)/g;\r\nfunction getParamNames(func) {\r\n    if (!isFunction(func)) {\r\n        return [];\r\n    }\r\n    let fnStr = func.toString().replace(STRIP_COMMENTS, '');\r\n    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\r\n    if (result === null) {\r\n        result = [];\r\n    }\r\n    return result;\r\n}\r\n\r\n","import 'reflect-metadata';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { Type, Token } from '../../types';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { Registration } from '../../Registration';\r\nimport { isString, isSymbol, isObject, isNumber, isBoolean, isToken } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\n\r\n/**\r\n * Type decorator.\r\n *\r\n * @export\r\n * @interface ITypeDecorator\r\n * @template T\r\n */\r\nexport interface ITypeDecorator<T extends ClassMetadata> {\r\n    /**\r\n     * define class decorator setting with metadata map.\r\n     *\r\n     * @param {T} [metadata] metadata map.\r\n     */\r\n    (metadata?: T): ClassDecorator;\r\n    /**\r\n     * not allow abstract to decorator with out metadata.\r\n     */\r\n    (target: Type<any>): void;\r\n}\r\n\r\n/**\r\n * class decorator.\r\n *\r\n * @export\r\n * @interface IClassDecorator\r\n */\r\nexport interface IClassDecorator<T extends ClassMetadata> extends ITypeDecorator<T> {\r\n\r\n    /**\r\n     * define class decorator setting with params.\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias?: string): ClassDecorator;\r\n\r\n    /**\r\n     * define class decorator setting with params.\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     * @param {Token<any>} [refTarget]  define the class as service of target.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias: string, refTarget: Token<any>): ClassDecorator;\r\n\r\n    /**\r\n     * define class decorator setting with params.\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     * @param {boolean} [singlton] define this class as singlton.\r\n     * @param {Token<any>} [refTarget]  define the class as service of target.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias: string, singlton: boolean, refTarget: Token<any>): ClassDecorator;\r\n\r\n    /**\r\n     * define class decorator setting with params.\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     * @param {boolean} [singlton] define this class as singlton.\r\n     * @param {number} [cache]  define class cahce expris when is not singlton.\r\n     * @param {Token<any>} [refTarget]  define the class as service of target.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias: string, cache: number, refTarget: Token<any>): ClassDecorator;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * create class decorator\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {*}\r\n */\r\nexport function createClassDecorator<T extends ClassMetadata>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): IClassDecorator<T> {\r\n\r\n    let classAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            match: (arg) => arg && (isSymbol(arg) || isString(arg) || (isObject(arg) && arg instanceof Registration)),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provide = arg;\r\n            }\r\n        });\r\n\r\n        args.next<T>({\r\n            match: (arg) => isString(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.alias = arg;\r\n            }\r\n        });\r\n\r\n        args.next<T>({\r\n            match: (arg) => isBoolean(arg) || isNumber(arg) || isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                if (isBoolean(arg)) {\r\n                    metadata.singleton = arg;\r\n                } else if (isNumber(arg)) {\r\n                    metadata.expires = arg;\r\n                } else if (isToken(arg)) {\r\n                    metadata.refs = { target: arg, provide: metadata.provide || metadata.type, alias: metadata.alias  };\r\n                }\r\n            }\r\n        });\r\n\r\n        args.next<T>({\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.expires = arg;\r\n            }\r\n        });\r\n    });\r\n    let decorator = createDecorator<T>(name, classAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Class;\r\n    return decorator;\r\n}\r\n\r\n","import 'reflect-metadata';\r\nimport { MethodMetadata } from '../metadatas';\r\nimport { ParamProviders } from '../../providers';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { isArray } from '../../utils';\r\n\r\n\r\n/**\r\n * Method decorator.\r\n *\r\n * @export\r\n * @interface IMethodDecorator\r\n */\r\nexport interface IMethodDecorator<T extends MethodMetadata> {\r\n    /**\r\n     * create method decorator with providers.\r\n     *\r\n     * @param  {ParamProviders[]} [providers]\r\n     */\r\n    (providers?: ParamProviders[]): MethodDecorator;\r\n    /**\r\n     * create method decorator with metadata map.\r\n     * @param {T} [metadata]\r\n     */\r\n    (metadata?: T): MethodDecorator;\r\n    /**\r\n     * create method decorator.\r\n     * @param {Object} target\r\n     * @param {(string | symbol)} propertyKey\r\n     * @param {TypedPropertyDescriptor<any>} descriptor\r\n     */\r\n    (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n\r\n/**\r\n * create method decorator.\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns\r\n */\r\nexport function createMethodDecorator<T extends MethodMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IMethodDecorator<T> {\r\n\r\n    let methodAdapter = (args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n\r\n        args.next<T>({\r\n            match: (arg) => isArray(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.providers = arg;\r\n            }\r\n        });\r\n    }\r\n\r\n    let decorator = createDecorator<T>(name, methodAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Method;\r\n    return decorator;\r\n}\r\n","import 'reflect-metadata';\r\nimport { ParameterMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { isToken, isProvideMetadata } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { Token } from '../../types';\r\n\r\n\r\n/**\r\n * Parameter decorator.\r\n *\r\n * @export\r\n * @interface IParameterDecorator\r\n */\r\nexport interface IParameterDecorator<T extends ParameterMetadata> {\r\n    /**\r\n     * define parameter decorator with param.\r\n     *\r\n     * @param {Token<T>} provider define provider to resolve value to the parameter.\r\n     */\r\n    (provider: Token<T>): ParameterDecorator;\r\n    /**\r\n     * define parameter decorator with metadata map.\r\n     * @param {T} [metadata] define matadata map to resolve value to the parameter.\r\n     */\r\n    (metadata?: T): ParameterDecorator;\r\n    /**\r\n     * define paramete decorator.\r\n     */\r\n    (target: object, propertyKey: string | symbol, parameterIndex: number): void;\r\n}\r\n\r\n\r\n\r\n/**\r\n * create parameter decorator.\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns\r\n */\r\nexport function createParamDecorator<T extends ParameterMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IParameterDecorator<T> {\r\n\r\n    let paramAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            isMetadata: (arg) => isProvideMetadata(arg, 'index'),\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provider = arg;\r\n            }\r\n        });\r\n        // args.next<T>({\r\n        //     match: (arg) => isString(arg),\r\n        //     setMetadata: (metadata, arg) => {\r\n        //         metadata.alias = arg;\r\n        //     }\r\n        // });\r\n    });\r\n    let decorator = createDecorator<T>(name, paramAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Parameter;\r\n    return decorator;\r\n}\r\n","import { PropertyMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { isToken, isProvideMetadata } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { Token } from '../../types';\r\n\r\n/**\r\n * property decorator.\r\n *\r\n * @export\r\n * @interface IPropertyDecorator\r\n */\r\nexport interface IPropertyDecorator<T extends PropertyMetadata> {\r\n    /**\r\n     * define property decorator with param.\r\n     *\r\n     * @param {Token<T>} provider define provider to resolve value to the property.\r\n     */\r\n    (provider: Token<any>): PropertyDecorator;\r\n    /**\r\n     * define property decorator with metadata map.\r\n     * @param {T} [metadata] define matadata map to resolve value to the property.\r\n     */\r\n    (metadata?: T): PropertyDecorator;\r\n    /**\r\n     * define property decorator.\r\n     */\r\n    (target: object, propertyKey: string | symbol): void;\r\n}\r\n\r\n\r\n/**\r\n * create property decorator.\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns\r\n */\r\nexport function createPropDecorator<T extends PropertyMetadata>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): IPropertyDecorator<T> {\r\n    let propPropAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            isMetadata: (arg) => isProvideMetadata(arg),\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provider = arg;\r\n            }\r\n        });\r\n    });\r\n    let decorator = createDecorator<T>(name, propPropAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Property;\r\n    return decorator;\r\n}\r\n\r\n","import 'reflect-metadata';\r\nimport { ParamPropMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { isToken, isProvideMetadata } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { Token } from '../../types';\r\n\r\n\r\n/**\r\n * property parameter decorator.\r\n */\r\nexport type PropParamDecorator = (target: Object, propertyKey: string | symbol, parameterIndex?: number) => void;\r\n\r\n/**\r\n * Parameter and Property decorator.\r\n *\r\n * @export\r\n * @interface IParamPropDecorator\r\n */\r\nexport interface IParamPropDecorator<T extends ParamPropMetadata> {\r\n    /**\r\n     * define parameter or property decorator with param.\r\n     *\r\n     * @param {Token<T>} provider define provider to resolve value to the parameter or property.\r\n     */\r\n    (provider: Token<any>): PropParamDecorator;\r\n    /**\r\n     * define parameter or property decorator with metadata map.\r\n     * @param {T} [metadata] define matadata map to resolve value to the parameter or property.\r\n     */\r\n    (metadata?: T): PropParamDecorator;\r\n    /**\r\n     * define parameter or property decorator.\r\n     */\r\n    (target: object, propertyKey: string | symbol, parameterIndex?: number): void;\r\n}\r\n\r\n/**\r\n * create parameter or property decorator\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {IParamPropDecorator<T>}\r\n */\r\nexport function createParamPropDecorator<T extends ParamPropMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IParamPropDecorator<T> {\r\n    let paramPropAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            isMetadata: (arg) => isProvideMetadata(arg, 'index'),\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provider = arg;\r\n            }\r\n        });\r\n        // args.next<T>({\r\n        //     match: (arg) => isString(arg),\r\n        //     setMetadata: (metadata, arg) => {\r\n        //         metadata.alias = arg;\r\n        //     }\r\n        // });\r\n    });\r\n    let decorator = createDecorator<T>(name, paramPropAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Property | DecoratorType.Parameter;\r\n    return decorator;\r\n}\r\n\r\n","import { Type } from '../../types';\r\nimport { TypeMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory'\r\nimport { DecoratorType } from './DecoratorType';\r\n\r\n\r\nexport type ClassMethodDecorator = (target: Object | Type<any>, propertyKey?: string | symbol, descriptor?: TypedPropertyDescriptor<any>) => void;\r\n\r\n/**\r\n * class method decorator\r\n *\r\n * @export\r\n * @interface IClassMethodDecorator\r\n * @template T\r\n */\r\nexport interface IClassMethodDecorator<T extends TypeMetadata> {\r\n    /**\r\n     * create decorator with metadata map. for class or method decorator.\r\n     *\r\n     * @param {T} [metadata] metadata map.\r\n     */\r\n    (metadata?: T): ClassMethodDecorator;\r\n\r\n    (target: Type<any>): void;\r\n    (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n/**\r\n * create decorator for class and method.\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {IClassMethodDecorator<T>}\r\n */\r\nexport function createClassMethodDecorator<T extends TypeMetadata>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): IClassMethodDecorator<T> {\r\n    let decorator = createDecorator<T>(name, adapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Class | DecoratorType.Method;\r\n    return decorator;\r\n}\r\n\r\n","import { MethodPropMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\n\r\n\r\n\r\nexport type MethodPropDecorator = (target: Object, propertyKey: string | symbol, descriptor?: TypedPropertyDescriptor<any>) => void;\r\n/**\r\n * method and Property decorator.\r\n *\r\n * @export\r\n * @interface IMethodPropDecorator\r\n */\r\nexport interface IMethodPropDecorator<T extends MethodPropMetadata> {\r\n    /**\r\n     * create method decorator with metadata map.\r\n     * @param {T} [metadata]\r\n     */\r\n    (metadata?: T): MethodPropDecorator;\r\n    (target: object, propertyKey: string | symbol, descriptor?: TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n/**\r\n * create method or property decorator\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {IMethodPropDecorator<T>}\r\n */\r\nexport function createMethodPropDecorator<T extends MethodPropMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IMethodPropDecorator<T> {\r\n    let decorator = createDecorator<T>(name, adapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Method | DecoratorType.Property;\r\n    return decorator;\r\n}\r\n\r\n","import { TypeMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\n\r\n\r\n\r\nexport type MethodPropParamDecorator = (target: Object, propertyKey: string | symbol, descriptor?: number | TypedPropertyDescriptor<any>) => void;\r\n/**\r\n * method, property or parameter decorator.\r\n *\r\n * @export\r\n * @interface IMethodPropParamDecorator\r\n */\r\nexport interface IMethodPropParamDecorator<T extends TypeMetadata> {\r\n    /**\r\n     * define method, property or parameter decorator with metadata map.\r\n     * @param {T} [metadata] metadata map\r\n     */\r\n    (metadata?: T): MethodPropParamDecorator;\r\n    /**\r\n     * define method, property or parameter decorator.\r\n     */\r\n    (target: object, propertyKey: string | symbol, descriptor?: number | TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n/**\r\n * create method, property or parameter decorator.\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {IMethodPropParamDecorator<T>}\r\n */\r\nexport function createMethodPropParamDecorator<T extends TypeMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IMethodPropParamDecorator<T> {\r\n\r\n    let decorator = createDecorator<T>(name, adapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Method | DecoratorType.Property | DecoratorType.Parameter;\r\n    return decorator;\r\n}\r\n\r\n","export * from './ArgsIterator';\r\nexport * from './DecoratorType';\r\nexport * from './DecoratorFactory';\r\n\r\nexport * from './ClassDecoratorFactory';\r\nexport * from './MethodDecoratorFactory';\r\nexport * from './ParamDecoratorFactory';\r\nexport * from './PropertyDecoratorFactory';\r\nexport * from './ParamPropDecoratorFactory';\r\nexport * from './ClassMethodDecoratorFactory';\r\nexport * from './MethodPropDecoratorFactory';\r\nexport * from './MethodPropParamDecoratorFactory';\r\n\r\n\r\n","import { Registration } from './Registration';\r\nimport { Token } from './types';\r\nimport { isString } from './utils';\r\n\r\n/**\r\n * Reference registration.\r\n *\r\n * @export\r\n * @class RefRegistration\r\n * @extends {Registration<T>}\r\n * @template T\r\n */\r\nexport class RefRegistration<T> extends Registration<T> {\r\n    constructor(provideType: Token<T> | Token<any>, desc: string) {\r\n        super(provideType, desc);\r\n        this.type = 'Ref';\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"RefRegistration\",\"params\":{\"constructor\":[\"provideType\",\"desc\"]}};\n                        }\n                   }\r\n\r\n/**\r\n * inject reference.\r\n *\r\n * @export\r\n * @class InjectReference\r\n * @extends {Registration<T>}\r\n * @template T\r\n */\r\nexport class InjectReference<T> extends Registration<T> {\r\n    constructor(provideType: Token<T>, private target: Token<any>) {\r\n        super(provideType, '');\r\n    }\r\n\r\n    protected init(provideType: Token<T>) {\r\n        this.classType = this.format(provideType);\r\n    }\r\n\r\n    /**\r\n     * to string.\r\n     *\r\n     * @returns {string}\r\n     * @memberof Registration\r\n     */\r\n    toString(): string {\r\n        let key = super.toString();\r\n        let target = this.format(this.target)\r\n        return `Ref ${key} for ${target}`;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"InjectReference\",\"params\":{\"constructor\":[\"provideType\",\"target\"],\"init\":[\"provideType\"],\"toString\":[]}};\n                        }\n                   }\r\n\r\n/**\r\n * is inject reference token or not.\r\n *\r\n * @export\r\n * @template T\r\n * @param {*} target\r\n * @returns {target is InjectReference<T>}\r\n */\r\nexport function isInjectReference<T>(target: any): target is InjectReference<T> {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    return target instanceof InjectReference || (isString(target) && /^Ref\\s+[\\w\\{\\}]+\\sfor/.test(target));\r\n}\r\n\r\n/**\r\n * class provides.\r\n *\r\n * @export\r\n * @interface IClassProvides\r\n */\r\nexport interface IClassProvides {\r\n    /**\r\n     * decorators of class\r\n     *\r\n     * @type {string[]}\r\n     * @memberof IClassProvides\r\n     */\r\n    decors: string[];\r\n    /**\r\n     * provides of class\r\n     *\r\n     * @type {Token<any>[]}\r\n     * @memberof IClassProvides\r\n     */\r\n    provides: Token<any>[];\r\n}\r\n\r\n/**\r\n * inject class provides token.\r\n *\r\n * @export\r\n * @class InjectClassProvidesToken\r\n * @extends {RefRegistration<IClassProvides>}\r\n */\r\nexport class InjectClassProvidesToken extends RefRegistration<IClassProvides> {\r\n    constructor(provideType: Token<any>) {\r\n        super(provideType, 'class_provides')\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"InjectClassProvidesToken\",\"params\":{\"constructor\":[\"provideType\"]}};\n                        }\n                   }\r\n","import { ActionComposite } from './ActionComposite';\r\nimport { ActionData } from '../ActionData';\r\nimport { CoreActions } from './CoreActions';\r\nimport { getOwnTypeMetadata } from '../factories';\r\nimport { IContainer } from '../../IContainer';\r\nimport { Token } from '../../types';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { InjectClassProvidesToken } from '../../InjectReference';\r\n\r\n/**\r\n * bind provider action data.\r\n *\r\n * @export\r\n * @interface BindProviderActionData\r\n * @extends {ActionData<Token<any>[]>}\r\n */\r\nexport interface BindProviderActionData extends ActionData<Token<any>[]> {\r\n\r\n}\r\n\r\n/**\r\n * bind provider action. for binding a factory to an token.\r\n *\r\n * @export\r\n * @class BindProviderAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class BindProviderAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.bindProvider)\r\n    }\r\n\r\n    protected working(container: IContainer, data: BindProviderActionData) {\r\n        let type = data.targetType;\r\n        let raiseContainer = data.raiseContainer;\r\n        let lifeScope = container.getLifeScope();\r\n        let matchs = lifeScope.getClassDecorators(type, surm => surm.actions.includes(CoreActions.bindProvider));\r\n        let clpds = new InjectClassProvidesToken(type);\r\n        // has binding.\r\n        let classPds = raiseContainer.resolveValue(clpds) || { provides: [clpds.toString()], decors: [] };\r\n        if (classPds.decors.length) {\r\n            matchs = matchs.filter(d => classPds.decors.indexOf(d.name) < 0);\r\n        }\r\n\r\n        if (matchs.length < 1) {\r\n            data.execResult = classPds.provides;\r\n            return;\r\n        }\r\n\r\n        matchs.forEach(surm => {\r\n            let metadata = getOwnTypeMetadata<ClassMetadata>(surm.name, type);\r\n            classPds.decors.push(surm.name);\r\n            if (Array.isArray(metadata) && metadata.length > 0) {\r\n                // bind all provider.\r\n                metadata.forEach(c => {\r\n                    if (!c) {\r\n                        return;\r\n                    }\r\n                    if (c.provide) {\r\n                        let provide = raiseContainer.getToken(c.provide, c.alias);\r\n                        classPds.provides.push(provide);\r\n                        raiseContainer.bindProvider(provide, c.type);\r\n                    }\r\n                    if (c.refs && c.refs.target) {\r\n                        raiseContainer.bindRefProvider(c.refs.target,\r\n                            c.refs.provide ? c.refs.provide : c.type,\r\n                            c.type,\r\n                            c.refs.provide ? c.refs.alias : '',\r\n                            tk => classPds.provides.push(tk));\r\n                    }\r\n                    // class private provider.\r\n                    if (c.providers && c.providers.length) {\r\n                        raiseContainer.bindProviders(\r\n                            c.type,\r\n                            refKey => classPds.provides.push(refKey),\r\n                            ...c.providers);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        raiseContainer.bindProvider(clpds, classPds);\r\n        data.execResult = classPds.provides;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"BindProviderAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import { ActionComposite } from './ActionComposite';\r\nimport { ActionData } from '../ActionData';\r\nimport { CoreActions } from './CoreActions';\r\nimport { getParamMetadata, getOwnParamMetadata } from '../factories';\r\nimport { ParameterMetadata } from '../metadatas';\r\nimport { IContainer } from '../../IContainer';\r\nimport { Token } from '../../types';\r\nimport { isArray } from '../../utils';\r\n\r\n/**\r\n * bind parameter type action data.\r\n *\r\n * @export\r\n * @interface BindParameterTypeActionData\r\n * @extends {ActionData<Token<any>[]>}\r\n */\r\nexport interface BindParameterTypeActionData extends ActionData<Token<any>[]> {\r\n}\r\n\r\n/**\r\n * bind parameter type action.\r\n *\r\n * @export\r\n * @class BindParameterTypeAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class BindParameterTypeAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.bindParameterType)\r\n    }\r\n\r\n    protected working(container: IContainer, data: ActionData<Token<any>[]>) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        let target = data.target\r\n        let type = data.targetType;\r\n        let propertyKey = data.propertyKey;\r\n        let lifeScope = container.getLifeScope();\r\n        let designParams: Token<any>[];\r\n\r\n        if (target && propertyKey) {\r\n            designParams = Reflect.getMetadata('design:paramtypes', target, propertyKey) || [];\r\n        } else {\r\n            designParams = Reflect.getMetadata('design:paramtypes', type) || [];\r\n        }\r\n\r\n        designParams = designParams.slice(0);\r\n        designParams.forEach(dtype => {\r\n            if (lifeScope.isVaildDependence(dtype)) {\r\n                if (!container.has(dtype)) {\r\n                    container.register(dtype);\r\n                }\r\n            }\r\n        });\r\n\r\n\r\n        let matchs = lifeScope.getParameterDecorators(target || type, propertyKey, surm => surm.actions.includes(CoreActions.bindParameterType));\r\n\r\n        matchs.forEach(surm => {\r\n            let parameters = (target || propertyKey !== 'constructor') ? getParamMetadata<ParameterMetadata>(surm.name, target, propertyKey) : getOwnParamMetadata<ParameterMetadata>(surm.name, type);\r\n            if (isArray(parameters) && parameters.length) {\r\n                parameters.forEach(params => {\r\n                    let parm = (isArray(params) && params.length > 0) ? params[0] : null;\r\n                    if (parm && parm.index >= 0) {\r\n                        if (lifeScope.isVaildDependence(parm.provider)) {\r\n                            if (!container.has(parm.provider, parm.alias)) {\r\n                                container.register(container.getToken(parm.provider, parm.alias));\r\n                            }\r\n                        }\r\n                        if (lifeScope.isVaildDependence(parm.type)) {\r\n                            if (!container.has(parm.type)) {\r\n                                container.register(parm.type);\r\n                            }\r\n                        }\r\n                        let token = parm.provider ? container.getTokenKey(parm.provider, parm.alias) : parm.type;\r\n                        if (token) {\r\n                            designParams[parm.index] = token;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n\r\n        data.execResult = designParams;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"BindParameterTypeAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import { ActionComposite } from './ActionComposite';\r\nimport { ActionData } from '../ActionData';\r\nimport { CoreActions } from './CoreActions';\r\nimport { getPropertyMetadata } from '../factories';\r\nimport { PropertyMetadata } from '../metadatas';\r\nimport { IContainer } from '../../IContainer';\r\n\r\n/**\r\n * bind property type action data.\r\n *\r\n * @export\r\n * @interface BindPropertyTypeActionData\r\n * @extends {ActionData<PropertyMetadata[]>}\r\n */\r\nexport interface BindPropertyTypeActionData extends ActionData<PropertyMetadata[]> {\r\n\r\n}\r\n\r\n/**\r\n * bind property type action. to get the property autowride token of Type calss.\r\n *\r\n * @export\r\n * @class SetPropAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class BindPropertyTypeAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.bindPropertyType)\r\n    }\r\n\r\n    protected working(container: IContainer, data: BindPropertyTypeActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        let type = data.targetType;\r\n        let lifeScope = container.getLifeScope();\r\n\r\n        let matchs = lifeScope.getPropertyDecorators(type, surm => surm.actions.includes(CoreActions.bindPropertyType));\r\n        let list: PropertyMetadata[] = [];\r\n        matchs.forEach(surm => {\r\n            let propMetadata = getPropertyMetadata<PropertyMetadata>(surm.name, type);\r\n\r\n            for (let n in propMetadata) {\r\n                list = list.concat(propMetadata[n]);\r\n            }\r\n            list = list.filter(n => !!n);\r\n            list.forEach(prop => {\r\n                if (lifeScope.isVaildDependence(prop.provider)) {\r\n                    if (!container.has(prop.provider, prop.alias)) {\r\n                        container.register(container.getToken(prop.provider, prop.alias));\r\n                    }\r\n                }\r\n                if (lifeScope.isVaildDependence(prop.type)) {\r\n                    if (!container.has(prop.type)) {\r\n                        container.register(prop.type);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        data.execResult = list;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"BindPropertyTypeAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import { Token, Express2, Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { isFunction, isObject, isUndefined } from '../utils';\r\nimport { ProviderTypes } from './types';\r\n\r\n/**\r\n * type provider.\r\n *\r\n * @export\r\n * @interface TypeProvider\r\n * @extends {Type<any>}\r\n */\r\nexport interface TypeProvider extends Type<any> {\r\n\r\n}\r\n\r\n/**\r\n * Provider interface.\r\n *\r\n * @export\r\n * @interface IProvider\r\n */\r\nexport interface IProvider {\r\n    /**\r\n     * this type provider to.\r\n     *\r\n     * @type {SymbolType<any>}\r\n     * @memberof Provider\r\n     */\r\n    provide: Token<any>;\r\n}\r\n\r\n\r\n/**\r\n * @usageNotes\r\n * ```\r\n * @Injectable()\r\n * class MyService {}\r\n *\r\n * const provider: ClassProvider = {provide: 'someToken', useClass: MyService};\r\n * ```\r\n *\r\n * @description\r\n * Configures the `Injector` to return an instance of `useClass` for a token.\r\n *\r\n */\r\nexport interface ClassProvider extends IProvider {\r\n    /**\r\n     * use class for provide.\r\n     *\r\n     * @type {Type<any>}\r\n     * @memberof ClassProvider\r\n     */\r\n    useClass: Type<any>;\r\n    /**\r\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\r\n     * used as arguments to the `useFactory` function.\r\n     */\r\n    deps?: any[];\r\n}\r\n\r\n/**\r\n * value provider.\r\n *\r\n * @usageNotes\r\n * ```\r\n * const provider: ClassProvider = {provide: 'someToken', useClass: MyService};\r\n * ```\r\n * @description\r\n * Configures the `Injector` to return an instance of `useValue` for a token.\r\n *\r\n * @export\r\n * @interface ValueProvider\r\n * @extends {IProvider}\r\n */\r\nexport interface ValueProvider extends IProvider {\r\n    /**\r\n     * use value for provide.\r\n     *\r\n     * @type {*}\r\n     * @memberof ValueProvider\r\n     */\r\n    useValue: any;\r\n}\r\n\r\n/**\r\n * @usageNotes\r\n * ```\r\n * function serviceFactory() { ... }\r\n *\r\n * const provider: FactoryProvider = {provide: 'someToken', useFactory: serviceFactory, deps: []};\r\n * ```\r\n *\r\n * @description\r\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\r\n *\r\n *\r\n */\r\nexport interface FactoryProvider extends IProvider {\r\n    /**\r\n    * A function to invoke to create a value for this `token`. The function is invoked with\r\n    * resolved values of `token`s in the `deps` field.\r\n    */\r\n    useFactory: Function;\r\n\r\n    /**\r\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\r\n     * used as arguments to the `useFactory` function.\r\n     */\r\n    deps?: any[];\r\n}\r\n\r\n/**\r\n * existing provider.\r\n *\r\n * @usageNotes\r\n * ```\r\n * const provider: ClassProvider = {provide: 'someToken', useExisting: 'registeredToken'};\r\n * ```\r\n * @export\r\n * @interface ExistingProvider\r\n * @extends {IProvider}\r\n */\r\nexport interface ExistingProvider extends IProvider {\r\n    /**\r\n     * use existing registered token for provide.\r\n     *\r\n     * @type {Token<any>}\r\n     * @memberof ExistingProvider\r\n     */\r\n    useExisting: Token<any>\r\n}\r\n\r\n/**\r\n * provider type.\r\n */\r\nexport type ProviderType =\r\n    TypeProvider | ValueProvider | ClassProvider | ExistingProvider | FactoryProvider | Provider;\r\n\r\n\r\n/**\r\n *  provider, to dynamic resovle instance of params in run time.\r\n *\r\n * @export\r\n * @class Provider\r\n */\r\nexport class Provider {\r\n    /**\r\n     * service provider is value or value factory.\r\n     *\r\n     * @memberof Provider\r\n     */\r\n    protected value?: any\r\n    /**\r\n     * service is instance of type.\r\n     *\r\n     * @type {Token<any>}\r\n     * @memberof Provider\r\n     */\r\n    type?: Token<any>;\r\n\r\n    constructor(type?: Token<any>, value?: any) {\r\n        this.type = type;\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * resolve provider value.\r\n     *\r\n     * @template T\r\n     * @param {IContainer} container\r\n     * @param {ProviderTypes[]} providers\r\n     * @returns {T}\r\n     * @memberof Provider\r\n     */\r\n    resolve<T>(container: IContainer, ...providers: ProviderTypes[]): T {\r\n        if (isUndefined(this.value)) {\r\n            return container.has(this.type) ? container.resolve(this.type, ...providers) : null;\r\n        } else {\r\n            return this.value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * create provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} type\r\n     * @param {(any)} value\r\n     * @returns Provider\r\n     * @memberof Provider\r\n     */\r\n    static create(type: Token<any>, value: any): Provider {\r\n        return new Provider(type, value);\r\n    }\r\n\r\n    /**\r\n     * create extends provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} token\r\n     * @param {(any)} value\r\n     * @param {Express2<any, ExtendsProvider, void>} [extendsTarget]\r\n     * @returns {ExtendsProvider}\r\n     * @memberof Provider\r\n     */\r\n    static createExtends(token: Token<any>, value: any, extendsTarget?: Express2<any, ExtendsProvider, void>): ExtendsProvider {\r\n        return new ExtendsProvider(token, value, extendsTarget);\r\n    }\r\n\r\n    /**\r\n     * create invoked provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} token\r\n     * @param {string} method\r\n     * @param {(any)} [value]\r\n     * @returns {InvokeProvider}\r\n     * @memberof Provider\r\n     */\r\n    static createInvoke(token: Token<any>, method: string, value?: any): InvokeProvider {\r\n        return new InvokeProvider(token, method, value);\r\n    }\r\n\r\n    /**\r\n     * create param provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} token\r\n     * @param {(any)} value\r\n     * @param {number} [index]\r\n     * @param {string} [method]\r\n     * @returns {ParamProvider}\r\n     * @memberof Provider\r\n     */\r\n    static createParam(token: Token<any>, value: any, index?: number, method?: string): ParamProvider {\r\n        return new ParamProvider(token, value, index, method);\r\n    }\r\n\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"Provider\",\"params\":{\"constructor\":[\"type\",\"value\"],\"resolve\":[\"container\",\"providers\"],\"create\":[\"type\",\"value\"],\"createExtends\":[\"token\",\"value\",\"extendsTarget\"],\"createInvoke\":[\"token\",\"method\",\"value\"],\"createParam\":[\"token\",\"value\",\"index\",\"method\"]}};\n                        }\n                   }\r\n\r\n/**\r\n * InvokeProvider\r\n *\r\n * @export\r\n * @class InvokeProvider\r\n * @extends {Provider}\r\n */\r\nexport class InvokeProvider extends Provider {\r\n    /**\r\n     * service value is the result of type instance invoke the method return value.\r\n     *\r\n     * @type {string}\r\n     * @memberof Provider\r\n     */\r\n    protected method?: string;\r\n\r\n    constructor(type?: Token<any>, method?: string, value?: any) {\r\n        super(type, value);\r\n        this.method = method;\r\n    }\r\n\r\n    resolve<T>(container: IContainer, ...providers: ProviderTypes[]): T {\r\n        if (this.method) {\r\n            return container.syncInvoke<T>(this.type, this.method, ...providers);\r\n        }\r\n        return super.resolve(container, ...providers);\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"InvokeProvider\",\"params\":{\"constructor\":[\"type\",\"method\",\"value\"],\"resolve\":[\"container\",\"providers\"]}};\n                        }\n                   }\r\n\r\n\r\n/**\r\n * param provider.\r\n *\r\n * @export\r\n * @interface ParamProvider\r\n */\r\nexport class ParamProvider extends InvokeProvider {\r\n    /**\r\n     * param index, param name.\r\n     *\r\n     * @type {number}\r\n     * @memberof ParamProvider\r\n     */\r\n    index?: number;\r\n\r\n    constructor(token?: Token<any>, value?: any, index?: number, method?: string) {\r\n        super(token, method, value);\r\n        this.index = index;\r\n    }\r\n\r\n    /**\r\n     * resolve param\r\n     *\r\n     * @template T\r\n     * @param {IContainer} container\r\n     * @param {...ProviderTypes[]} providers\r\n     * @returns {T}\r\n     * @memberof ParamProvider\r\n     */\r\n    resolve<T>(container: IContainer, ...providers: ProviderTypes[]): T {\r\n        return super.resolve(container, ...providers);\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ParamProvider\",\"params\":{\"constructor\":[\"token\",\"value\",\"index\",\"method\"],\"resolve\":[\"container\",\"providers\"]}};\n                        }\n                   }\r\n\r\n/**\r\n * Provider enable exntends target with provider in dynamic.\r\n *\r\n * @export\r\n * @class ExtendsProvider\r\n * @extends {Provider}\r\n */\r\nexport class ExtendsProvider extends Provider {\r\n\r\n\r\n    constructor(token: Token<any>, value?: any, private extendsTarget?: Express2<any, ExtendsProvider, void>) {\r\n        super(token, value);\r\n    }\r\n\r\n    resolve<T>(container: IContainer, ...providers: ProviderTypes[]): T {\r\n        return super.resolve(container, ...providers);\r\n    }\r\n\r\n    extends(target: any) {\r\n        if (isObject(target) && isFunction(this.extendsTarget)) {\r\n            this.extendsTarget(target, this);\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ExtendsProvider\",\"params\":{\"constructor\":[\"token\",\"value\",\"extendsTarget\"],\"resolve\":[\"container\",\"providers\"],\"extends\":[\"target\"]}};\n                        }\n                   }\r\n","import { isToken, isFunction, isUndefined, isObject, isNumber, MapBase } from '../utils';\r\nimport { Token, InstanceFactory, SymbolType, Factory, Type } from '../types';\r\nimport { IContainer, ResoveWay } from '../IContainer';\r\nimport { InjectToken } from '../InjectToken';\r\nimport { IResolver, IResolverContainer } from '../IResolver';\r\nimport { ProviderTypes, ParamProviders } from './types';\r\n\r\n// use core-js in browser.\r\n\r\nexport const ProviderMapToken = new InjectToken<ProviderMap>('DI_ProviderMap');\r\n\r\n/**\r\n * Provider Map.\r\n *\r\n * note: object map provider can not resolve token.\r\n *\r\n * @export\r\n * @class Providers\r\n */\r\nexport class ProviderMap extends MapBase<Token<any> | number, InstanceFactory<any>> implements IResolverContainer {\r\n\r\n    constructor(private container: IContainer) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * has provide or not.\r\n     *\r\n     * @param {(Token<any> | number)} provide\r\n     * @returns {boolean}\r\n     * @memberof ProviderMap\r\n     */\r\n    has(provide: Token<any> | number): boolean {\r\n        return this.map.has(this.getTokenKey(provide));\r\n    }\r\n\r\n    provides(): Token<any>[] {\r\n        return this.keys().filter(k => isToken(k)) as Token<any>[];\r\n    }\r\n\r\n    /**\r\n     * get token key.\r\n     *\r\n     * @param {(Token<any> | number)} token\r\n     * @returns {(SymbolType<any> | number)}\r\n     * @memberof ProviderMap\r\n     */\r\n    getTokenKey(token: Token<any> | number): SymbolType<any> | number {\r\n        if (isToken(token)) {\r\n            return this.container.getTokenKey(token);\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * get token factory.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | number)} provide\r\n     * @returns {InstanceFactory<T>}\r\n     * @memberof ProviderMap\r\n     */\r\n    get<T>(provide: Token<T> | number): InstanceFactory<T> {\r\n        return this.map.get(this.getTokenKey(provide));\r\n    }\r\n\r\n    getTokenImpl<T>(token: Token<T>, resway?: ResoveWay): Type<T> {\r\n        return this.container.getTokenImpl(token, resway);\r\n    }\r\n\r\n    unregister<T>(token: Token<T>, resway?: ResoveWay): this {\r\n        let key = this.getTokenKey(token);\r\n        if (this.map.has(key)) {\r\n            this.map.delete(key);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * add and bind token provider.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | number)} provide\r\n     * @param {(Token<T> | Factory<T>)} provider\r\n     * @returns {this}\r\n     * @memberof ProviderMap\r\n     */\r\n    add<T>(provide: Token<T> | number, provider: Token<T> | Factory<T>): this {\r\n        let key = this.getTokenKey(provide);\r\n        if (isUndefined(key)) {\r\n            return this;\r\n        }\r\n        let factory;\r\n        if (isToken(provider) && this.container.has(provider)) {\r\n            factory = (...providers: ProviderTypes[]) => {\r\n                return this.container.resolve(provider, ...providers);\r\n            };\r\n        } else {\r\n            if (isFunction(provider)) {\r\n                factory = provider;\r\n            } else {\r\n                factory = () => {\r\n                    return provider;\r\n                };\r\n            }\r\n        }\r\n        if (factory) {\r\n            this.map.set(key, factory);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * resolve instance via provide token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} provide\r\n     * @param {...ProviderTypes[]} providers\r\n     * @returns {T}\r\n     * @memberof ProviderMap\r\n     */\r\n    resolve<T>(provide: Token<T> | number, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T {\r\n        let key = this.getTokenKey(provide);\r\n        let way: ResoveWay;\r\n        if (isNumber(resway)) {\r\n            way = resway;\r\n        } else {\r\n            if (resway) {\r\n                providers.unshift(resway);\r\n            }\r\n            way = ResoveWay.current;\r\n        }\r\n        if ((way & ResoveWay.current) && this.map.has(key)) {\r\n            let provider = this.map.get(key);\r\n            return isFunction(provider) ? provider(...providers) : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    forEach(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void): void {\r\n        this.map.forEach((fac, key) => {\r\n            !isNumber(key) && callbackfn(key, fac, this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * copy provider map.\r\n     *\r\n     * @param {ProviderMap} map\r\n     * @returns\r\n     * @memberof ProviderMap\r\n     */\r\n    copy(map: ProviderMap): this {\r\n        if (!map) {\r\n            return this;\r\n        }\r\n        this.map.forEach((fac, key) => {\r\n            this.map.set(key, fac);\r\n        });\r\n        return this;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ProviderMap\",\"params\":{\"constructor\":[\"container\"],\"has\":[\"provide\"],\"provides\":[],\"getTokenKey\":[\"token\"],\"get\":[\"provide\"],\"getTokenImpl\":[\"token\",\"resway\"],\"unregister\":[\"token\",\"resway\"],\"add\":[\"provide\",\"provider\"],\"resolve\":[\"provide\",\"resway\",\"providers\"],\"forEach\":[\"callbackfn\"],\"copy\":[\"map\"]}};\n                        }\n                   }\r\n\r\n\r\n\r\n/**\r\n * object is provider map or not.\r\n *\r\n * @export\r\n * @param {object} target\r\n * @returns {target is ProviderMap}\r\n */\r\nexport function isProviderMap(target: object): target is ProviderMap {\r\n    if (!isObject(target)) {\r\n        return false;\r\n    }\r\n    return target instanceof ProviderMap;\r\n}\r\n","import { ParamProviders } from './types';\r\nimport { ProviderMap } from '../providers';\r\nimport { InjectToken } from '../InjectToken';\r\n\r\n/**\r\n * Providers parser token.\r\n */\r\nexport const ProviderParserToken = new InjectToken<IProviderParser>('DI_IProviderParser');\r\n\r\n/**\r\n * Providers Parser interface.\r\n *\r\n * @export\r\n * @interface IProviderParser\r\n */\r\nexport interface IProviderParser {\r\n    /**\r\n     * convert to provider map.\r\n     *\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {ProviderMap}\r\n     * @memberof IProviderParser\r\n     */\r\n    parse(...providers: ParamProviders[]): ProviderMap;\r\n}\r\n","import { ParamProviders } from './types';\r\nimport {\r\n    isClass, isArray, isFunction, isNumber, isString,\r\n    isUndefined, isNull, isToken, isBaseObject, lang\r\n} from '../utils';\r\nimport { IProviderParser } from './IProviderParser';\r\nimport { IContainer } from '../IContainer';\r\nimport { ProviderMap, isProviderMap, ProviderMapToken } from './ProviderMap';\r\nimport { Provider, ParamProvider } from './Provider';\r\n\r\n/**\r\n * provider matcher. use to find custome providers in resolve.\r\n *\r\n * note: object map provider can not resolve token.\r\n *\r\n * @export\r\n * @class ProviderMatcher\r\n * @implements {IProviderMatcher}\r\n */\r\nexport class ProviderParser implements IProviderParser {\r\n\r\n    constructor(private container: IContainer) {\r\n\r\n    }\r\n\r\n    parse(...providers: ParamProviders[]): ProviderMap {\r\n        if (providers.length === 1 && isProviderMap(providers[0])) {\r\n            return providers[0] as ProviderMap;\r\n        }\r\n        let map = this.container.resolve(ProviderMapToken);\r\n        providers.forEach((p, index) => {\r\n            if (isUndefined(p) || isNull(p)) {\r\n                return;\r\n            }\r\n            if (isProviderMap(p)) {\r\n                map.copy(p);\r\n            } else if (p instanceof Provider) {\r\n                if (p instanceof ParamProvider) {\r\n                    if (!p.type && isNumber(p.index)) {\r\n                        map.add(p.index, (...providers: ParamProviders[]) => p.resolve(this.container, ...providers));\r\n                    } else {\r\n                        map.add(p.type, (...providers: ParamProviders[]) => p.resolve(this.container, ...providers));\r\n                    }\r\n\r\n                } else {\r\n                    map.add(p.type, (...providers: ParamProviders[]) => p.resolve(this.container, ...providers));\r\n                }\r\n            } else if (isClass(p)) {\r\n                if (!this.container.has(p)) {\r\n                    this.container.register(p);\r\n                }\r\n                map.add(p, p);\r\n            } else if (isBaseObject(p)) {\r\n                let pr: any = p;\r\n                let isobjMap = false;\r\n                if (isToken(pr.provide)) {\r\n                    if (isArray(pr.deps) && pr.deps.length) {\r\n                        pr.deps.forEach(d => {\r\n                            if (isClass(d) && !this.container.has(d)) {\r\n                                this.container.register(d);\r\n                            }\r\n                        });\r\n                    }\r\n                    if (!isUndefined(pr.useValue)) {\r\n                        map.add(pr.provide, () => pr.useValue);\r\n                    } else if (isClass(pr.useClass)) {\r\n                        if (!this.container.has(pr.useClass)) {\r\n                            this.container.register(pr.useClass);\r\n                        }\r\n                        map.add(pr.provide, pr.useClass);\r\n                    } else if (isFunction(pr.useFactory)) {\r\n                        map.add(pr.provide, (...providers) => {\r\n                            let args = [];\r\n                            if (isArray(pr.deps) && pr.deps.length) {\r\n                                args = pr.deps.map(d => {\r\n                                    if (isToken(d)) {\r\n                                        return this.container.resolve(d, ...providers);\r\n                                    } else {\r\n                                        return d;\r\n                                    }\r\n                                });\r\n                            }\r\n                            return pr.useFactory.apply(pr, args);\r\n                        });\r\n                    } else if (isToken(pr.useExisting)) {\r\n                        map.add(pr.provide, (...providers) => this.container.resolve(pr.useExisting, ...providers));\r\n                    } else {\r\n                        isobjMap = true;\r\n                    }\r\n                } else {\r\n                    isobjMap = true;\r\n                }\r\n\r\n                if (isobjMap) {\r\n                    lang.forIn<any>(p, (val, name) => {\r\n                        if (name && isString(name)) {\r\n                            // object map can not resolve token. set all fileld as value factory.\r\n                            map.add(name, () => val);\r\n                        }\r\n                    });\r\n                }\r\n\r\n            } else if (isFunction(p)) {\r\n                map.add(name, () => p);\r\n            }\r\n        });\r\n\r\n        return map;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ProviderParser\",\"params\":{\"constructor\":[\"container\"],\"parse\":[\"providers\"]}};\n                        }\n                   }\r\n\r\nexport function isProvider(target: any): boolean {\r\n    return isProviderMap(target) || isBaseObject(target) || target instanceof Provider;\r\n}\r\n","export * from './Provider';\r\nexport * from './ProviderMap';\r\nexport * from './IProviderParser';\r\nexport * from './ProviderParser';\r\nexport * from './types';\r\n","import { BindPropertyTypeActionData } from './BindPropertyTypeAction';\r\nimport { IContainer, ContainerToken } from '../../IContainer';\r\nimport { CoreActions } from './CoreActions';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { InjectReference } from '../../InjectReference';\r\nimport { ProviderMap } from '../../providers';\r\nimport { ObjectMap } from '../../types';\r\n\r\n\r\n/**\r\n * inject property action data.\r\n *\r\n * @export\r\n * @interface InjectPropertyActionData\r\n * @extends {BindPropertyTypeActionData}\r\n */\r\nexport interface InjectPropertyActionData extends BindPropertyTypeActionData {\r\n    injecteds?: ObjectMap<boolean>;\r\n}\r\n\r\n/**\r\n * inject property value action, to inject property value for resolve instance.\r\n *\r\n * @export\r\n * @class SetPropAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class InjectPropertyAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.injectProperty)\r\n    }\r\n\r\n    protected working(container: IContainer, data: InjectPropertyActionData) {\r\n        if (!data.execResult) {\r\n            this.parent.find(act => act.name === CoreActions.bindPropertyType).execute(container, data);\r\n        }\r\n\r\n        if (data.target && data.execResult && data.execResult.length) {\r\n            let providerMap = data.providerMap;\r\n            data.injecteds = data.injecteds || {};\r\n            data.execResult.forEach((prop, idx) => {\r\n                if (prop && !data.injecteds[prop.propertyKey]) {\r\n                    let token = prop.provider ? container.getToken(prop.provider, prop.alias) : prop.type;\r\n                    let pdrMap = container.get(new InjectReference(ProviderMap, data.targetType));\r\n                    if (token === ContainerToken) {\r\n                        Object.defineProperty(data.target, prop.propertyKey, { enumerable: false, writable: true });\r\n                    }\r\n                    if (pdrMap && pdrMap.has(token)) {\r\n                        data.target[prop.propertyKey] = pdrMap.resolve(token, providerMap);\r\n                        data.injecteds[prop.propertyKey] = true;\r\n                    } else if (providerMap && providerMap.has(token)) {\r\n                        data.target[prop.propertyKey] = providerMap.resolve(token, providerMap);\r\n                        data.injecteds[prop.propertyKey] = true;\r\n                    } else if (container.has(token)) {\r\n                        data.target[prop.propertyKey] = container.resolve(token, providerMap);\r\n                        data.injecteds[prop.propertyKey] = true;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"InjectPropertyAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import { ActionComposite } from './ActionComposite';\r\nimport { ActionData } from '../ActionData';\r\nimport { CoreActions } from './CoreActions';\r\nimport { getOwnMethodMetadata, hasOwnMethodMetadata } from '../factories';\r\nimport { MethodMetadata } from '../metadatas';\r\nimport { IContainer } from '../../IContainer';\r\nimport { ParamProviders } from '../../providers';\r\nimport { isArray } from '../../utils';\r\n\r\n/**\r\n * bind parameter provider action data.\r\n *\r\n * @export\r\n * @interface BindParameterProviderActionData\r\n * @extends {ActionData<ParamProviders[]>}\r\n */\r\nexport interface BindParameterProviderActionData extends ActionData<ParamProviders[]> {\r\n\r\n}\r\n\r\n/**\r\n * bind parameters action.\r\n *\r\n * @export\r\n * @class BindParameterProviderAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class BindParameterProviderAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.bindParameterProviders)\r\n    }\r\n\r\n    protected working(container: IContainer, data: BindParameterProviderActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        let type = data.targetType;\r\n        let propertyKey = data.propertyKey;\r\n        let lifeScope = container.getLifeScope();\r\n\r\n        let matchs = lifeScope.getMethodDecorators(type, surm => surm.actions.includes(CoreActions.bindParameterProviders) && hasOwnMethodMetadata(surm.name, type));\r\n\r\n        let providers: ParamProviders[] = [];\r\n        matchs.forEach(surm => {\r\n            let methodmtas = getOwnMethodMetadata<MethodMetadata>(surm.name, type);\r\n            let metadatas = methodmtas[propertyKey];\r\n            if (metadatas && isArray(metadatas) && metadatas.length > 0) {\r\n                metadatas.forEach(meta => {\r\n                    if (meta.providers && meta.providers.length > 0) {\r\n                        providers = providers.concat(meta.providers);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        data.execResult = providers;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"BindParameterProviderAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import { ActionData } from '../ActionData';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { BeforeInit } from '../ComponentLifecycle';\r\nimport { isFunction } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\nimport { DecoratorType } from '../factories';\r\n\r\n\r\n\r\n/**\r\n * component before init action data.\r\n *\r\n * @export\r\n * @interface ComponentBeforeInitActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface ComponentBeforeInitActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * component before init action, to run @Component decorator class before init hooks.\r\n *\r\n * @export\r\n * @class ComponentBeforeInitAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class ComponentBeforeInitAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.componentBeforeInit)\r\n    }\r\n\r\n    protected working(container: IContainer, data: ComponentBeforeInitActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.targetType && data.target) {\r\n            if (container.getLifeScope().hasDecorator(data.targetType, DecoratorType.Class, surm => surm.actions.includes(CoreActions.componentBeforeInit))) {\r\n                let component = data.target as BeforeInit;\r\n                if (isFunction(component.beforeInit)) {\r\n                    container.syncInvoke(data.target || data.targetType, 'beforeInit', data.target);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ComponentBeforeInitAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import { ActionData } from '../ActionData';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { OnInit } from '../ComponentLifecycle';\r\nimport { isFunction } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\nimport { DecoratorType } from '../factories';\r\n\r\n\r\n\r\n/**\r\n * component init action data.\r\n *\r\n * @export\r\n * @interface ComponentInitActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface ComponentInitActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * component before init action, to run @Component decorator class before init hooks.\r\n *\r\n * @export\r\n * @class ComponentInitAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class ComponentInitAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.componentInit)\r\n    }\r\n\r\n    protected working(container: IContainer, data: ComponentInitActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.targetType && data.target) {\r\n            if (container.getLifeScope().hasDecorator(data.targetType, DecoratorType.Class, surm => surm.actions.includes(CoreActions.componentInit))) {\r\n                let component = data.target as OnInit;\r\n                if (isFunction(component.onInit)) {\r\n                    container.syncInvoke(data.target || data.targetType, 'onInit', data.target);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ComponentInitAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import { ActionData } from '../ActionData';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { AfterInit } from '../ComponentLifecycle';\r\nimport { isFunction } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\nimport { DecoratorType } from '../factories';\r\n\r\n\r\n/**\r\n * component after init action data.\r\n *\r\n * @export\r\n * @interface ComponentAfterInitActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface ComponentAfterInitActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * component after init action, to run @Component decorator class after init hooks.\r\n *\r\n * @export\r\n * @class ComponentAfterInitAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class ComponentAfterInitAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.componentAfterInit)\r\n    }\r\n\r\n    protected working(container: IContainer, data: ComponentAfterInitActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.targetType && data.target) {\r\n            if (container.getLifeScope().hasDecorator(data.targetType, DecoratorType.Class, surm => surm.actions.includes(CoreActions.componentAfterInit))) {\r\n                let component = data.target as AfterInit;\r\n                if (isFunction(component.afterInit)) {\r\n                    container.syncInvoke(data.target || data.targetType, 'afterInit', data.target);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ComponentAfterInitAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import { Type } from './types';\r\nimport { InjectToken } from './InjectToken';\r\n\r\n/**\r\n * ICacheManager interface token.\r\n * it is a token id, you can register yourself ICacheManager for this.\r\n */\r\nexport const CacheManagerToken = new InjectToken<ICacheManager>('DI_ICacheManager');\r\n\r\n/**\r\n * cache manager inteface.\r\n *\r\n * @export\r\n * @interface ICacheManager\r\n */\r\nexport interface ICacheManager {\r\n    /**\r\n     * has cache\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @returns {boolean}\r\n     * @memberof ICacheManager\r\n     */\r\n    hasCache(targetType: Type<any>): boolean;\r\n    /**\r\n     * cache target.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @param {*} target\r\n     * @param {number} expires\r\n     * @memberof ICacheManager\r\n     */\r\n    cache(targetType: Type<any>, target: any, expires: number);\r\n    /**\r\n     * get cache target, if set expires will refresh cache timeout.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @param {number} [expires] if set number will reset cache timeout.\r\n     * @returns {*}\r\n     * @memberof ICacheManager\r\n     */\r\n    get(targetType: Type<any>, expires?: number): any;\r\n    /**\r\n     * is check expires or not.\r\n     *\r\n     * @returns {boolean}\r\n     * @memberof ICacheManager\r\n     */\r\n    isChecking(): boolean;\r\n    /**\r\n     * run check expires.\r\n     *\r\n     * @memberof ICacheManager\r\n     */\r\n    checkExpires();\r\n    /**\r\n     * destory cache\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @param {*} [target]\r\n     * @memberof ICacheManager\r\n     */\r\n    destroy(targetType: Type<any>, target?: any);\r\n}\r\n","import { ActionData } from '../ActionData';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { isNumber, isClass } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\nimport { getOwnTypeMetadata } from '../factories';\r\nimport { CacheManagerToken } from '../../ICacheManager';\r\n\r\n\r\n/**\r\n * cache action data.\r\n *\r\n * @export\r\n * @interface CacheActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface CacheActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * cache action. To cache instance of Token. define cache expires in decorator.\r\n *\r\n * @export\r\n * @class CacheAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class CacheAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.cache)\r\n    }\r\n\r\n    protected working(container: IContainer, data: CacheActionData) {\r\n\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return data;\r\n        }\r\n\r\n        if (data.singleton || !data.targetType || !isClass(data.targetType)) {\r\n            return data;\r\n        }\r\n        let cacheManager = container.get(CacheManagerToken);\r\n\r\n        if (data.target) {\r\n            if (!cacheManager.hasCache(data.targetType)) {\r\n                let cacheMetadata = this.getCacheMetadata(container, data);\r\n                if (cacheMetadata) {\r\n                    cacheManager.cache(data.targetType, data.target, cacheMetadata.expires);\r\n                }\r\n            }\r\n        } else {\r\n            let target = cacheManager.get(data.targetType);\r\n            if (target) {\r\n                let cacheMetadata = this.getCacheMetadata(container, data);\r\n                if (cacheMetadata) {\r\n                    cacheManager.cache(data.targetType, target, cacheMetadata.expires);\r\n                    data.execResult = target;\r\n                }\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    getCacheMetadata(container: IContainer, data: CacheActionData): ClassMetadata {\r\n        let lifeScope = container.getLifeScope();\r\n        let matchs = lifeScope.getClassDecorators(data.targetType);\r\n        let cacheMetadata: ClassMetadata;\r\n        for (let i = 0; i < matchs.length; i++) {\r\n            let surm = matchs[i];\r\n            let metadata = getOwnTypeMetadata<ClassMetadata>(surm.name, data.targetType);\r\n            if (Array.isArray(metadata) && metadata.length > 0) {\r\n                cacheMetadata = metadata.find(c => c && isNumber(c.expires) && c.expires > 0);\r\n                if (cacheMetadata) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return cacheMetadata;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"CacheAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"],\"getCacheMetadata\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import { ActionData } from '../ActionData';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { CoreActions } from './CoreActions';\r\n\r\n\r\n\r\n/**\r\n * singleton action data.\r\n *\r\n * @export\r\n * @interface SingletionActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface SingletionActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * singleton action, to set the factory of Token as singleton.\r\n *\r\n * @export\r\n * @class SingletionAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class SingletionAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.singletion)\r\n    }\r\n\r\n    protected working(container: IContainer, data: SingletionActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.tokenKey && data.target && data.singleton) {\r\n            container.registerValue(data.tokenKey, data.target);\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"SingletionAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import { IClassMethodDecorator, createClassMethodDecorator, ClassMethodDecorator } from '../factories';\r\nimport { AutorunMetadata } from '../metadatas';\r\nimport { isClassMetadata, isString, isNumber } from '../../utils';\r\n\r\n\r\n/**\r\n * autorun decorator inteface\r\n *\r\n * @export\r\n * @interface IAutorunDecorator\r\n * @extends {IClassMethodDecorator<AutorunMetadata>}\r\n */\r\nexport interface IAutorunDecorator extends IClassMethodDecorator<AutorunMetadata> {\r\n    /**\r\n     * Autorun decorator, for class.  use to define the class auto run (via a method or not) after registered.\r\n     * @Autorun\r\n     *\r\n     * @param {string} [autorun] the special method name when define to class.\r\n     */\r\n    (autorun: string): ClassDecorator;\r\n\r\n    /**\r\n     * Autorun decorator, for method.  use to define the method auto run (via a method or not) after registered.\r\n     * @Autorun\r\n     *\r\n     * @param {string} [autorun] the special method name when define to class.\r\n     */\r\n    (order: number): MethodDecorator;\r\n\r\n    /**\r\n     * Autorun decorator, for class or method. use to define the class auto run (via a method or not) after registered.\r\n     * @Autorun\r\n     *\r\n     * @param {AutorunMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: AutorunMetadata): ClassMethodDecorator;\r\n}\r\n\r\n/**\r\n * Autorun decorator, for class or method.  use to define the class auto run (via a method or not) after registered.\r\n *\r\n * @Autorun\r\n */\r\nexport const Autorun: IAutorunDecorator = createClassMethodDecorator<AutorunMetadata>('Autorun', args => {\r\n    args.next<AutorunMetadata>({\r\n        isMetadata: (arg) => isClassMetadata(arg, 'autorun'),\r\n        match: (arg) => isString(arg) || isNumber(arg),\r\n        setMetadata: (metadata, arg) => {\r\n            if (isString(arg)) {\r\n                metadata.autorun = arg;\r\n            } else {\r\n                metadata.order = arg;\r\n            }\r\n        }\r\n    });\r\n}, (metadata) => {\r\n    metadata.singleton = true;\r\n    return metadata;\r\n}) as IAutorunDecorator;\r\n","import { createClassDecorator, ITypeDecorator } from '../factories';\r\nimport { AutorunMetadata } from '../metadatas';\r\nimport { isClassMetadata, isString } from '../../utils';\r\n\r\n/**\r\n * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.\r\n *\r\n * @IocExt\r\n */\r\nexport interface IocExtDecorator extends ITypeDecorator<AutorunMetadata> {\r\n    /**\r\n     * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.\r\n     *\r\n     * @IocExt\r\n     *\r\n     * @param {string} [autorun] auto run special method.\r\n     */\r\n    (autorun?: string): ClassDecorator;\r\n\r\n    /**\r\n     * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.\r\n     *\r\n     * @IocExt\r\n     *\r\n     * @param {AutorunMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: AutorunMetadata): ClassDecorator;\r\n}\r\n\r\n/**\r\n * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.\r\n *\r\n * @IocExt\r\n */\r\nexport const IocExt: IocExtDecorator = createClassDecorator<AutorunMetadata>('IocExt',\r\n    args => {\r\n        args.next<AutorunMetadata>({\r\n            isMetadata: (arg) => isClassMetadata(arg, 'autorun'),\r\n            match: (arg) => isString(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.autorun = arg;\r\n            }\r\n        })\r\n    }, (metadata) => {\r\n        metadata.singleton = true;\r\n        return metadata;\r\n    }) as IocExtDecorator;\r\n\r\nexport const IocModule = IocExt;\r\n","import { ActionData } from '../ActionData';\r\nimport { AutorunMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { isFunction } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\nimport { hasClassMetadata, getTypeMetadata } from '../factories';\r\nimport { Autorun } from '../decorators/AutoRun';\r\nimport { IocExt } from '../decorators/IocExt';\r\n\r\n/**\r\n * auto run action data.\r\n *\r\n * @export\r\n * @interface AutorunActionData\r\n * @extends {ActionData<AutorunMetadata>}\r\n */\r\nexport interface AutorunActionData extends ActionData<AutorunMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * Inject DrawType action.\r\n *\r\n * @export\r\n * @class SetPropAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class AutorunAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.autorun)\r\n    }\r\n\r\n    protected getDecorator(): Function[] {\r\n        return [IocExt, Autorun];\r\n    }\r\n\r\n    protected working(container: IContainer, data: AutorunActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.tokenKey && data.targetType) {\r\n            let decorators = this.getDecorator();\r\n            decorators.forEach(decorator => {\r\n                if (hasClassMetadata(decorator, data.targetType)) {\r\n                    let metas = getTypeMetadata<AutorunMetadata>(decorator, data.targetType);\r\n                    let meta = metas.find(it => !!it.autorun);\r\n                    if (!meta && metas.length) {\r\n                        meta = metas[0]\r\n                    }\r\n                    if (meta) {\r\n                        let instance = container.get(data.tokenKey);\r\n                        if (instance && meta.autorun && isFunction(instance[meta.autorun])) {\r\n                            container.syncInvoke(instance, meta.autorun);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"AutorunAction\",\"params\":{\"constructor\":[],\"getDecorator\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","export * from './ActionComponent';\r\nexport * from './ActionComposite';\r\nexport * from './LifeState';\r\nexport * from './CoreActions';\r\n\r\nexport * from './NullAction';\r\nexport * from './BindProviderAction'\r\nexport * from './BindParameterTypeAction';\r\nexport * from './BindPropertyTypeAction';\r\nexport * from './InjectPropertyAction';\r\nexport * from './BindParameterProviderAction';\r\nexport * from './ComponentBeforeInitAction';\r\nexport * from './ComponentInitAction';\r\nexport * from './ComponentAfterInitAction';\r\nexport * from './CacheAction';\r\nexport * from './SingletonAction';\r\nexport * from './AutorunAction';\r\n\r\n","/**\r\n * define the property enumerable of not.\r\n *\r\n * @export\r\n * @param {boolean} value\r\n * @returns\r\n */\r\nexport function enumerable(value: boolean) {\r\n    return function (target: any, propertyKey: string, descriptor?: PropertyDescriptor) {\r\n        if (descriptor) {\r\n            descriptor.enumerable = value;\r\n        } else {\r\n            descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || {writable: true};\r\n            descriptor.enumerable = value;\r\n            Object.defineProperty(target, propertyKey, descriptor);\r\n        }\r\n    };\r\n}\r\n\r\nexport function configurable(value: boolean) {\r\n    return function (target: any, propertyKey: string, descriptor?: PropertyDescriptor) {\r\n        if (descriptor) {\r\n            descriptor.configurable = value;\r\n        } else {\r\n            descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || {writable: true};\r\n            descriptor.configurable = value;\r\n            Object.defineProperty(target, propertyKey, descriptor);\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * define class is sealed.\r\n *\r\n * @param {Function} constructor\r\n */\r\nexport function sealed(constructor: Function) {\r\n    Object.seal(constructor);\r\n    Object.seal(constructor.prototype);\r\n}\r\n","import { createClassDecorator, IClassDecorator } from '../factories';\r\nimport { InjectableMetadata } from '../metadatas';\r\n\r\n/**\r\n * Component decorator\r\n *\r\n * @export\r\n * @interface IInjectableDecorator\r\n * @extends {IClassDecorator<InjectableMetadata>}\r\n */\r\nexport interface IComponentDecorator extends IClassDecorator<InjectableMetadata> {\r\n    /**\r\n     * Component decorator, define for class. use to define the class. it can setting provider to some token, singleton or not. it will execute  [`ComponentLifecycle`]\r\n     *\r\n     * @Component\r\n     *\r\n     * @param {InjectableMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: InjectableMetadata): ClassDecorator;\r\n}\r\n\r\n/**\r\n * Component decorator, define for class. use to define the class. it can setting provider to some token, singleton or not. it will execute  [`ComponentLifecycle`]\r\n *\r\n * @Component\r\n */\r\nexport const Component: IComponentDecorator = createClassDecorator<InjectableMetadata>('Component');\r\n\r\n","import { createClassDecorator, IClassDecorator } from '../factories';\r\nimport { InjectableMetadata } from '../metadatas';\r\n\r\n/**\r\n * Injectable decorator\r\n *\r\n * @export\r\n * @interface IInjectableDecorator\r\n * @extends {IClassDecorator<InjectableMetadata>}\r\n */\r\nexport interface IInjectableDecorator extends IClassDecorator<InjectableMetadata> {\r\n    // /**\r\n    //  * Injectable decorator, define for class.  use to define the class. it can setting provider to some token, singleton or not.\r\n    //  *\r\n    //  * @Injectable\r\n    //  *\r\n    //  * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n    //  * @param {string} [alias] define this class provider with alias for provide.\r\n    //  * @param {boolean} [singlton] define this class as singlton.\r\n    //  * @param {number} [cache]  define class cahce expris when is not singlton.\r\n    //  */\r\n    // (provide: Registration<any> | symbol | string, alias?: string, singlton?: boolean, cache?: number): ClassDecorator;\r\n\r\n    /**\r\n     * Injectable decorator, define for class.  use to define the class. it can setting provider to some token, singleton or not.\r\n     *\r\n     * @Injectable\r\n     *\r\n     * @param {InjectableMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: InjectableMetadata): ClassDecorator;\r\n}\r\n\r\n\r\n/**\r\n * Injectable decorator, define for class.  use to define the class. it can setting provider to some token, singleton or not.\r\n *\r\n * @Injectable\r\n */\r\nexport const Injectable: IInjectableDecorator = createClassDecorator<InjectableMetadata>('Injectable');\r\n\r\n","import { createDecorator, ArgsIterator } from '../factories';\r\nimport { RefMetadata } from '../metadatas';\r\nimport { isToken, isString } from '../../utils';\r\nimport { Token } from '../../types';\r\n\r\n/**\r\n * Refs decorator, for class. use to define the class as service of target.\r\n *\r\n * @Refs\r\n *\r\n * @export\r\n * @interface IRefToDecorator\r\n * @extends {IClassDecorator<RefMetadata>}\r\n */\r\nexport interface IRefsDecorator {\r\n    /**\r\n     * Refs decorator, for class. use to define the class as service of target.\r\n     *\r\n     * @Refs\r\n     *\r\n     * @param {Token<any>} target reference to target token.\r\n     */\r\n    (target: Token<any>): ClassDecorator;\r\n\r\n    /**\r\n     * Refs decorator, for class. use to define the class as service of target.\r\n     *\r\n     * @Refs\r\n     *\r\n     * @param {Token<any>} target reference to target token.\r\n     * @param {Token<any>} provide define this class ref provider for provide.\r\n     * @param {string} [alias] define this class ref provider with alias for provide.\r\n    */\r\n    (target: Token<any>, provide: Token<any>, alias?: string): ClassDecorator;\r\n\r\n    /**\r\n     * Refs decorator, for class. use to define the class as service of target.\r\n     *\r\n     * @Refs\r\n     *\r\n     * @param {RefMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata: RefMetadata): ClassDecorator;\r\n}\r\n\r\n/**\r\n * Refs decorator, for class. use to define the class as service of target.\r\n *\r\n * @Refs\r\n */\r\nexport const Refs: IRefsDecorator = createDecorator<RefMetadata>('Refs', ((args: ArgsIterator) => {\r\n    args.next<RefMetadata>({\r\n        match: arg => isToken(arg),\r\n        setMetadata: (metadata, arg) => {\r\n            metadata.refs = { target: arg };\r\n        }\r\n    });\r\n    args.next<RefMetadata>({\r\n        match: arg => isToken(arg),\r\n        setMetadata: (metadata, arg) => {\r\n            metadata.refs.provide = arg;\r\n        }\r\n    });\r\n    args.next<RefMetadata>({\r\n        match: arg => isString(arg),\r\n        setMetadata: (metadata, arg) => {\r\n            metadata.refs.alias = arg;\r\n        }\r\n    });\r\n})) as IRefsDecorator;\r\n\r\n","import { createDecorator, ArgsIterator } from '../factories';\r\nimport { ProvidersMetadata } from '../metadatas';\r\nimport { isArray } from '../../utils';\r\nimport { ProviderTypes } from '../../providers';\r\n\r\n/**\r\n * @Providers decorator, for class. use to define the class as service of target.\r\n *\r\n * @Providers\r\n *\r\n * @export\r\n * @interface IProvidersDecorator\r\n * @extends {IClassDecorator<ProvidersMetadata>}\r\n */\r\nexport interface IProvidersDecorator {\r\n    /**\r\n     * Providers decorator, for class. use to add ref service to the class.\r\n     *\r\n     * @Providers\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} providers provider reference service to target.\r\n     */\r\n    (providers: ProviderTypes[]): ClassDecorator;\r\n\r\n    /**\r\n     * Providers decorator, for class. use to add ref service to the class.\r\n     *\r\n     * @Providers\r\n     *\r\n     * @param {ProvidersMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata: ProvidersMetadata): ClassDecorator;\r\n}\r\n\r\n/**\r\n * Providers decorator, for class. use to add ref service to the class.\r\n *\r\n * @Providers\r\n */\r\nexport const Providers: IProvidersDecorator = createDecorator<ProvidersMetadata>('Providers', ((args: ArgsIterator) => {\r\n    args.next<ProvidersMetadata>({\r\n        match: arg => isArray(arg),\r\n        setMetadata: (metadata, arg) => {\r\n            metadata.providers = arg;\r\n        }\r\n    });\r\n})) as IProvidersDecorator;\r\n\r\n","import { IParamPropDecorator, createParamPropDecorator } from '../factories';\r\nimport { InjectMetadata } from '../metadatas';\r\n\r\n/**\r\n * Inject decorator, for property or param, use to auto wried type instance or value to the instance of one class with the decorator.\r\n *\r\n * @Inject\r\n */\r\nexport const Inject: IParamPropDecorator<InjectMetadata> = createParamPropDecorator<InjectMetadata>('Inject');\r\n","import { IParamPropDecorator, createParamPropDecorator } from '../factories';\r\nimport { AutoWiredMetadata } from '../metadatas';\r\n\r\n/**\r\n * AutoWired decorator, for property or param. use to auto wried type instance or value to the instance of one class with the decorator.\r\n *\r\n * @AutoWired\r\n */\r\nexport const AutoWired: IParamPropDecorator<AutoWiredMetadata> = createParamPropDecorator<AutoWiredMetadata>('AutoWired');\r\n\r\n","import { ParameterMetadata } from '../metadatas';\r\nimport { createParamDecorator, IParameterDecorator } from '../factories';\r\n\r\n/**\r\n * param decorator, define for parameter. use to auto wried type instance or value to the instance of one class with the decorator.\r\n *\r\n * @Param\r\n */\r\nexport const Param: IParameterDecorator<ParameterMetadata> = createParamDecorator<ParameterMetadata>('Param');\r\n","import { MethodMetadata } from '../metadatas';\r\nimport { createMethodDecorator, IMethodDecorator } from '../factories';\r\n\r\n/**\r\n * method decorator.\r\n *\r\n * @Method\r\n */\r\nexport const Method: IMethodDecorator<MethodMetadata> = createMethodDecorator<MethodMetadata>('Method');\r\n","import { createClassDecorator, ITypeDecorator } from '../factories';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { Registration } from '../../Registration';\r\n\r\n/**\r\n * Singleton decorator, for class. use to define the class is singleton.\r\n *\r\n * @Singleton\r\n *\r\n * @export\r\n * @interface ISingletonDecorator\r\n * @extends {IClassDecorator<ClassMetadata>}\r\n */\r\nexport interface ISingletonDecorator extends ITypeDecorator<ClassMetadata> {\r\n    /**\r\n     * Singleton decorator, for class. use to define the class is singleton.\r\n     *\r\n     * @Singleton\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias?: string): ClassDecorator;\r\n\r\n    /**\r\n     * Singleton decorator, for class. use to define the class is singleton.\r\n     *\r\n     * @Singleton\r\n     *\r\n     * @param {ClassMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: ClassMetadata): ClassDecorator;\r\n}\r\n\r\n/**\r\n * Singleton decorator, for class. use to define the class is singleton.\r\n *\r\n * @Singleton\r\n */\r\nexport const Singleton: ISingletonDecorator = createClassDecorator<ClassMetadata>('Singleton', null, (metadata) => {\r\n    metadata.singleton = true;\r\n    return metadata;\r\n}) as ISingletonDecorator;\r\n\r\n","import { createClassDecorator, ITypeDecorator } from '../factories';\r\nimport { ClassMetadata } from '../metadatas';\r\n\r\n\r\n\r\n/**\r\n * Abstract decorator. define for class.\r\n *\r\n * @Abstract\r\n */\r\nexport const Abstract: ITypeDecorator<ClassMetadata> = createClassDecorator<ClassMetadata>('Abstract');\r\n\r\n","export * from './basic';\r\nexport * from './Component';\r\nexport * from './Injectable';\r\nexport * from './Refs';\r\nexport * from './Providers';\r\nexport * from './Inject';\r\nexport * from './AutoWried';\r\nexport * from './Param';\r\nexport * from './Method';\r\nexport * from './Singleton';\r\nexport * from './Abstract';\r\nexport * from './AutoRun';\r\nexport * from './IocExt';\r\n","import { InjectToken } from '../InjectToken';\r\n/**\r\n * IRecognizer interface token.\r\n * it is a token id, you can register yourself IRecognizer for this.\r\n */\r\nexport const RecognizerToken = new InjectToken<IRecognizer>('DI_IRecognizer');\r\n\r\n/**\r\n * recognize the vaule is special alias for registor to container.\r\n *\r\n * @export\r\n * @interface IRecognizer\r\n */\r\nexport interface IRecognizer {\r\n    /**\r\n     * recognize the special alias of value.\r\n     *\r\n     * @param {*} value\r\n     * @returns {string}\r\n     * @memberof IRecognizer\r\n     */\r\n    recognize(value: any): string;\r\n}\r\n","import { ActionData } from '../ActionData';\r\nimport { AutorunMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { lang, isNumber } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\nimport { hasMethodMetadata, getMethodMetadata } from '../factories';\r\nimport { Autorun } from '../decorators';\r\n\r\n\r\n\r\n/**\r\n * auto run action data.\r\n *\r\n * @export\r\n * @interface AutorunActionData\r\n * @extends {ActionData<AutorunMetadata>}\r\n */\r\nexport interface MethodAutorunActionData extends ActionData<AutorunMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * Inject DrawType action.\r\n *\r\n * @export\r\n * @class SetPropAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class MethodAutorun extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.methodAutorun)\r\n    }\r\n\r\n    protected working(container: IContainer, data: MethodAutorunActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.target && data.targetType) {\r\n            if (hasMethodMetadata(Autorun, data.targetType)) {\r\n                let metas = getMethodMetadata<AutorunMetadata>(Autorun, data.targetType);\r\n                let lastmetas: AutorunMetadata[] = [];\r\n                let idx = lang.keys(metas).length;\r\n                lang.forIn(metas, (mm, key: string) => {\r\n                    if (mm && mm.length) {\r\n                        let m = mm[0];\r\n                        m.autorun = key;\r\n                        idx++;\r\n                        if (!isNumber(m.order)) {\r\n                            m.order = idx;\r\n                        }\r\n                        lastmetas.push(m);\r\n                    }\r\n                });\r\n\r\n                lastmetas.sort((au1, au2) => {\r\n                    return au1.order - au1.order;\r\n                }).forEach(aut => {\r\n                    container.syncInvoke(data.target || data.targetType, aut.autorun, data.target);\r\n                });\r\n            }\r\n\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"MethodAutorun\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n","import {\r\n    ActionComponent, ActionComposite,\r\n    CoreActions, BindParameterTypeAction,\r\n    BindPropertyTypeAction, InjectPropertyAction,\r\n    BindParameterProviderAction, BindProviderAction,\r\n    ComponentInitAction, ComponentBeforeInitAction, ComponentAfterInitAction,\r\n    CacheAction, SingletionAction, AutorunAction\r\n} from './actions';\r\nimport { MethodAutorun } from './actions/MethodAutorun';\r\n\r\n\r\n/**\r\n * action factory.\r\n *\r\n * @export\r\n * @class ActionFactory\r\n */\r\nexport class ActionFactory {\r\n    /**\r\n     * create action by action type. type in 'CoreActions'\r\n     *\r\n     * @param {string} type\r\n     * @returns {ActionComponent}\r\n     * @memberof ActionFactory\r\n     */\r\n    create(type: string): ActionComponent {\r\n        let action: ActionComponent;\r\n        switch (type) {\r\n            case CoreActions.bindParameterType:\r\n                action = new BindParameterTypeAction();\r\n                break;\r\n\r\n            case CoreActions.bindPropertyType:\r\n                action = new BindPropertyTypeAction();\r\n                break;\r\n\r\n            case CoreActions.injectProperty:\r\n                action = new InjectPropertyAction();\r\n                break;\r\n\r\n            case CoreActions.bindProvider:\r\n                action = new BindProviderAction();\r\n                break;\r\n\r\n            case CoreActions.bindParameterProviders:\r\n                action = new BindParameterProviderAction();\r\n                break;\r\n\r\n            case CoreActions.componentInit:\r\n                action = new ComponentInitAction();\r\n                break;\r\n\r\n            case CoreActions.componentBeforeInit:\r\n                action = new ComponentBeforeInitAction();\r\n                break;\r\n\r\n            case CoreActions.componentAfterInit:\r\n                action = new ComponentAfterInitAction();\r\n                break;\r\n\r\n            case CoreActions.cache:\r\n                action = new CacheAction();\r\n                break;\r\n\r\n            case CoreActions.singletion:\r\n                action = new SingletionAction();\r\n                break;\r\n\r\n            case CoreActions.autorun:\r\n                action = new AutorunAction();\r\n                break;\r\n            case CoreActions.methodAutorun:\r\n                action = new MethodAutorun();\r\n                break;\r\n            default:\r\n                action = new ActionComposite(type);\r\n                break;\r\n\r\n        }\r\n\r\n        return action;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ActionFactory\",\"params\":{\"create\":[\"type\"]}};\n                        }\n                   }\r\n","import { Token, Type, Express } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { RefRegistration } from '../InjectReference';\r\nimport { ComponentMetadata } from './metadatas';\r\n\r\n/**\r\n * annotation metadata.\r\n *\r\n * @export\r\n * @interface IAnnotationMetadata\r\n * @extends {ClassMetadata}\r\n * @template T\r\n */\r\nexport interface IAnnotationMetadata<T> extends ComponentMetadata {\r\n    /**\r\n     * annotation for the type.\r\n     *\r\n     * @type {Token<T>}\r\n     * @memberof AnnotationConfigure\r\n     */\r\n    token?: Token<T>;\r\n    /**\r\n     * Annotation class Type.\r\n     *\r\n     * @type {Type<T>}\r\n     * @memberof IAnnotationMetadata\r\n     */\r\n    type?: Type<T>;\r\n    /**\r\n     * bootstrap.\r\n     *\r\n     * @type {Token<T>}\r\n     * @memberof IAnnotationMetadata\r\n     */\r\n    bootstrap?: Token<T>;\r\n}\r\n\r\n/**\r\n * module metadata accessor\r\n *\r\n * @export\r\n * @interface IMetaAccessor\r\n * @template T\r\n */\r\nexport interface IMetaAccessor<T> {\r\n    /**\r\n     * get then first decorator metadata contain via decorators in order.\r\n     *\r\n     * @param {Type<T>} type\r\n     * @returns {string[]}\r\n     * @memberof IMetaAccessor\r\n     */\r\n    getDecorators(type: Type<T>): string[];\r\n\r\n    /**\r\n     * get metadata config of target type. via decorators in order.\r\n     *\r\n     * @param {Token<T>} type\r\n     * @param {IContainer} container\r\n     * @param {IAnnotationMetadata<T>} [extConfig] ext config to merge with metadata.\r\n     * @param {Express<string, boolean>} [decorFilter]\r\n     * @returns {IAnnotationMetadata<T>}\r\n     * @memberof IMetaAccessor\r\n     */\r\n    getMetadata(type: Token<T>, container: IContainer, extConfig?: IAnnotationMetadata<T>, decorFilter?: Express<string, boolean>): IAnnotationMetadata<T>;\r\n\r\n    /**\r\n     * find metadata.\r\n     *\r\n     * @param {Token<T>} type\r\n     * @param {IContainer} container\r\n     * @param {Express<IAnnotationMetadata<T>, boolean>} filter\r\n     * @param {Express<string, boolean>} [decorFilter]\r\n     * @returns {IAnnotationMetadata<T>}\r\n     * @memberof IMetaAccessor\r\n     */\r\n    find(type: Token<T>, container: IContainer, filter: Express<IAnnotationMetadata<T>, boolean>, decorFilter?: Express<string, boolean>): IAnnotationMetadata<T>;\r\n\r\n    /**\r\n     * filter metadata.\r\n     *\r\n     * @param {Token<T>} type\r\n     * @param {IContainer} container\r\n     * @param {Express<IAnnotationMetadata<T>, boolean>} filter\r\n     * @param {Express<string, boolean>} [decorFilter]\r\n     * @returns {IAnnotationMetadata<T>[]}\r\n     * @memberof IMetaAccessor\r\n     */\r\n    filter(type: Token<T>, container: IContainer, filter: Express<IAnnotationMetadata<T>, boolean>, decorFilter?: Express<string, boolean>): IAnnotationMetadata<T>[];\r\n\r\n    /**\r\n     * get token of metadata.\r\n     *\r\n     * @param {AnnotationConfigure<any>} config\r\n     * @returns {Token<any>}\r\n     * @param {IContainer} [container]  vaild container.\r\n     * @memberof IMetadataManager\r\n     */\r\n    getToken(config: IAnnotationMetadata<any>, container?: IContainer): Token<any>;\r\n\r\n    /**\r\n     * get boot token of module config.\r\n     *\r\n     * @param {IAnnotationMetadata<any>} cfg\r\n     * @param {IContainer} [container]  vaild container.\r\n     * @returns {Token<any>}\r\n     * @memberof IModuleValidate\r\n     */\r\n    getBootToken(cfg: IAnnotationMetadata<any>, container?: IContainer): Token<any>\r\n}\r\n\r\n/**\r\n * application service token.\r\n *\r\n * @export\r\n * @class InjectMetaAccessorToken\r\n * @extends {Registration<MetaAccessor<T>>}\r\n * @template T\r\n */\r\nexport class InjectMetaAccessorToken<T> extends RefRegistration<IMetaAccessor<T>> {\r\n    constructor(type: Token<T>) {\r\n        super(type, 'metaAccessor');\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"InjectMetaAccessorToken\",\"params\":{\"constructor\":[\"type\"]}};\n                        }\n                   }\r\n\r\n/**\r\n * MetaAccessor token.\r\n */\r\nexport const MetaAccessorToken = new InjectMetaAccessorToken<any>(Object);\r\n","import { LifeScope, DecorSummary } from '../LifeScope';\r\nimport { Type, ObjectMap, Token, IocState, Express } from '../types';\r\nimport { isClass, isAbstractClass, isArray, lang } from '../utils';\r\nimport { Singleton } from './decorators/Singleton';\r\nimport { MethodMetadata } from './metadatas';\r\nimport { IContainer } from '../IContainer';\r\nimport { CoreActions, ActionComponent, LifeState } from './actions';\r\nimport {\r\n    DecoratorType, getOwnParamerterNames, getOwnMethodMetadata, hasOwnClassMetadata,\r\n    getMethodDecorators, getClassDecorators, getPropDecorators, getParamDecorators\r\n} from './factories';\r\nimport { ActionData } from './ActionData';\r\nimport { ActionFactory } from './ActionFactory';\r\nimport { IParameter } from '../IParameter';\r\nimport { MetaAccessorToken } from './IMetaAccessor';\r\n\r\n\r\n/**\r\n * default implement life scope.\r\n *\r\n * @export\r\n * @class DefaultLifeScope\r\n * @implements {LifeScope}\r\n */\r\nexport class DefaultLifeScope implements LifeScope {\r\n    decorators: DecorSummary[];\r\n    action: ActionComponent;\r\n    constructor(private container: IContainer) {\r\n        this.decorators = [];\r\n        this.buildAction();\r\n    }\r\n\r\n    addAction(action: ActionComponent, ...nodepaths: string[]): this {\r\n        let parent = this.action;\r\n        nodepaths.forEach(pathname => {\r\n            parent = parent.find(act => act.name === pathname);\r\n        });\r\n        if (parent) {\r\n            parent.add(action);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    registerDecorator(decorator: Function, ...actions: string[]): this {\r\n        let type = this.getDecoratorType(decorator);\r\n        return this.registerCustomDecorator(decorator, type, ...actions);\r\n    }\r\n\r\n    registerCustomDecorator(decorator: Function, type: DecoratorType, ...actions: string[]): this {\r\n        let types = this.toActionName(type);\r\n        let name = decorator.toString();\r\n        if (!this.decorators.some(d => d.name === name)) {\r\n            this.decorators.push({\r\n                name: name,\r\n                types: types,\r\n                actions: actions\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    execute<T>(data: ActionData<T>, ...names: string[]) {\r\n        names = names.filter(n => !!n);\r\n        let act: ActionComponent = this.action;\r\n        names.forEach(name => {\r\n            act = act.find(itm => itm.name === name);\r\n        });\r\n        if (act) {\r\n            act.execute(this.container, data);\r\n        }\r\n    }\r\n\r\n    routeExecute<T>(data: ActionData<T>, ...names: string[]) {\r\n        this.execute(data, ...names);\r\n        let container = this.container.parent;\r\n        while (container) {\r\n            container.getLifeScope().execute(lang.assign({}, data), ...names);\r\n            container = container.parent;\r\n        }\r\n    }\r\n\r\n    hasDecorator(target: Type<any> | any, dtype: DecoratorType, match?: Express<DecorSummary, boolean>): boolean {\r\n        let decors;\r\n        switch (dtype) {\r\n            case DecoratorType.Class:\r\n                decors = getClassDecorators(target);\r\n                break;\r\n            case DecoratorType.Property:\r\n                decors = getPropDecorators(target);\r\n                break;\r\n            case DecoratorType.Parameter:\r\n                decors = getParamDecorators(target);\r\n                break;\r\n            case DecoratorType.Method:\r\n                decors = getMethodDecorators(target);\r\n                break;\r\n        }\r\n        if (decors) {\r\n            return decors.some(dec => this.decorators.some(d => d.name === dec && match(d)));\r\n        }\r\n        return false;\r\n    }\r\n\r\n    getClassDecorators(type: Type<any>, match?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return getClassDecorators(type)\r\n            .map(dec => this.decorators.find(d => d.name === dec))\r\n            .filter(d => d && (match ? match(d) : true));\r\n    }\r\n\r\n    getMethodDecorators(type: Type<any>, match?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return getMethodDecorators(type)\r\n            .map(dec => this.decorators.find(d => d.name === dec))\r\n            .filter(d => d && (match ? match(d) : true));\r\n    }\r\n\r\n    getPropertyDecorators(type: Type<any>, match?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return getPropDecorators(type)\r\n            .map(dec => this.decorators.find(d => d.name === dec))\r\n            .filter(d => d && (match ? match(d) : true));\r\n    }\r\n\r\n    getParameterDecorators(target: any, propertyKey: string, match?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return getParamDecorators(target, propertyKey)\r\n            .map(dec => this.decorators.find(d => d.name === dec))\r\n            .filter(d => d && (match ? match(d) : true));\r\n    }\r\n\r\n    getDecoratorType(decirator: any): DecoratorType {\r\n        return decirator.decoratorType || DecoratorType.All;\r\n    }\r\n\r\n    /**\r\n     * is vaildate dependence type or not. dependence type must with class decorator.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} target\r\n     * @returns {boolean}\r\n     * @memberof Container\r\n     */\r\n    isVaildDependence<T>(target: Type<T>): boolean {\r\n        if (!target) {\r\n            return false;\r\n        }\r\n        if (!isClass(target)) {\r\n            return false;\r\n        }\r\n\r\n        if (isAbstractClass(target)) {\r\n            return false;\r\n        }\r\n        return this.getClassDecorators(target).length > 0;\r\n    }\r\n\r\n    getAtionByName(name: string): ActionComponent {\r\n        return this.action.find(action => action.name === name) as ActionComponent;\r\n    }\r\n\r\n    getClassAction(): ActionComponent {\r\n        return this.getAtionByName(this.toActionName(DecoratorType.Class));\r\n    }\r\n    getMethodAction(): ActionComponent {\r\n        return this.getAtionByName(this.toActionName(DecoratorType.Method));\r\n    }\r\n\r\n    getPropertyAction(): ActionComponent {\r\n        return this.getAtionByName(this.toActionName(DecoratorType.Property));\r\n    }\r\n    getParameterAction(): ActionComponent {\r\n        return this.getAtionByName(this.toActionName(DecoratorType.Parameter));\r\n    }\r\n\r\n    /**\r\n     * get constructor parameters metadata.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @returns {IParameter[]}\r\n     * @memberof IContainer\r\n     */\r\n    getConstructorParameters<T>(type: Type<T>): IParameter[] {\r\n        return this.getParameters(type);\r\n    }\r\n\r\n    /**\r\n     * get method params metadata.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @param {T} instance\r\n     * @param {(string | symbol)} propertyKey\r\n     * @returns {IParameter[]}\r\n     * @memberof IContainer\r\n     */\r\n    getMethodParameters<T>(type: Type<T>, instance: T, propertyKey: string): IParameter[] {\r\n        return this.getParameters(type, instance, propertyKey);\r\n    }\r\n\r\n    /**\r\n     * get paramerter names.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @param {string} propertyKey\r\n     * @returns {string[]}\r\n     * @memberof DefaultLifeScope\r\n     */\r\n    getParamerterNames<T>(type: Type<T>, propertyKey: string): string[] {\r\n        let metadata = getOwnParamerterNames(type);\r\n        let paramNames = [];\r\n        if (metadata && metadata.hasOwnProperty(propertyKey)) {\r\n            paramNames = metadata[propertyKey]\r\n        }\r\n        if (!isArray(paramNames)) {\r\n            paramNames = [];\r\n        }\r\n        return paramNames;\r\n    }\r\n\r\n    isSingletonType<T>(type: Type<T>): boolean {\r\n        if (hasOwnClassMetadata(Singleton, type)) {\r\n            return true;\r\n        }\r\n        let metadata = this.container.get(MetaAccessorToken).find(type, this.container, m => m.singleton === true);\r\n        return !!metadata;\r\n    }\r\n\r\n    getMethodMetadatas<T>(type: Type<T>, propertyKey: string): MethodMetadata[] {\r\n        let metadatas = [];\r\n        this.getMethodDecorators(type)\r\n            .forEach(dec => {\r\n                let metas: ObjectMap<MethodMetadata[]> = getOwnMethodMetadata<MethodMetadata>(dec.name, type);\r\n                if (metas.hasOwnProperty(propertyKey)) {\r\n                    metadatas = metadatas.concat(metas[propertyKey] || []);\r\n                }\r\n            });\r\n        return metadatas;\r\n    }\r\n\r\n    filerDecorators(express?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return this.decorators.filter(express);\r\n    }\r\n\r\n    protected getParameters<T>(type: Type<T>, instance?: T, propertyKey?: string): IParameter[] {\r\n        propertyKey = propertyKey || 'constructor';\r\n        let data = {\r\n            target: instance,\r\n            targetType: type,\r\n            propertyKey: propertyKey\r\n        } as ActionData<Token<any>[]>;\r\n        this.execute(data, LifeState.onInit, CoreActions.bindParameterType);\r\n\r\n        let paramNames = this.getParamerterNames(type, propertyKey);\r\n\r\n        if (data.execResult.length) {\r\n            return data.execResult.map((typ, idx) => {\r\n                return {\r\n                    type: typ,\r\n                    name: paramNames[idx]\r\n                }\r\n            });\r\n        } else {\r\n            return paramNames.map(name => {\r\n                return {\r\n                    name: name,\r\n                    type: undefined\r\n                }\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    protected getTypeDecorators(decType: string, match?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return this.filerDecorators(value => {\r\n            let flag = (value.types || '').indexOf(decType) >= 0;\r\n            if (flag && match) {\r\n                flag = match(value);\r\n            }\r\n            return flag;\r\n        });\r\n    }\r\n\r\n    protected buildAction() {\r\n        let factory = new ActionFactory();\r\n\r\n        let action = factory.create('');\r\n        action\r\n            .add(factory.create(IocState.design)\r\n                .add(factory.create(CoreActions.bindProvider))\r\n                .add(factory.create(CoreActions.autorun))\r\n            )\r\n            .add(factory.create(IocState.runtime)\r\n                .add(factory.create(LifeState.beforeCreateArgs))\r\n                .add(factory.create(LifeState.beforeConstructor))\r\n                .add(factory.create(LifeState.afterConstructor))\r\n                .add(factory.create(LifeState.onInit)\r\n                    .add(factory.create(CoreActions.componentBeforeInit))\r\n                    .add(factory.create(this.toActionName(DecoratorType.Class)))\r\n                    .add(factory.create(this.toActionName(DecoratorType.Method)))\r\n                    .add(factory.create(this.toActionName(DecoratorType.Property))\r\n                        .add(factory.create(CoreActions.bindPropertyType))\r\n                        .add(factory.create(CoreActions.injectProperty)))\r\n                    .add(factory.create(this.toActionName(DecoratorType.Parameter))\r\n                        .add(factory.create(CoreActions.bindParameterType))\r\n                        .add(factory.create(CoreActions.bindParameterProviders)))\r\n                    .add(factory.create(CoreActions.componentInit))\r\n                )\r\n                .add(factory.create(LifeState.AfterInit)\r\n                    .add(factory.create(CoreActions.singletion))\r\n                    .add(factory.create(CoreActions.componentAfterInit))\r\n                    .add(factory.create(CoreActions.methodAutorun)))\r\n            )\r\n            .add(factory.create(CoreActions.cache));\r\n\r\n        this.action = action;\r\n    }\r\n\r\n\r\n    toActionName(type: DecoratorType): string {\r\n        let types = [];\r\n        if (type & DecoratorType.Class) {\r\n            types.push('ClassDecorator');\r\n        }\r\n        if (type & DecoratorType.Method) {\r\n            types.push('MethodDecorator');\r\n        }\r\n        if (type & DecoratorType.Property) {\r\n            types.push('PropertyDecorator');\r\n        }\r\n        if (type & DecoratorType.Parameter) {\r\n            types.push('ParameterDecorator');\r\n        }\r\n\r\n        return types.join(',');\r\n    }\r\n\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"DefaultLifeScope\",\"params\":{\"constructor\":[\"container\"],\"addAction\":[\"action\",\"nodepaths\"],\"registerDecorator\":[\"decorator\",\"actions\"],\"registerCustomDecorator\":[\"decorator\",\"type\",\"actions\"],\"execute\":[\"data\",\"names\"],\"routeExecute\":[\"data\",\"names\"],\"hasDecorator\":[\"target\",\"dtype\",\"match\"],\"getClassDecorators\":[\"type\",\"match\"],\"getMethodDecorators\":[\"type\",\"match\"],\"getPropertyDecorators\":[\"type\",\"match\"],\"getParameterDecorators\":[\"target\",\"propertyKey\",\"match\"],\"getDecoratorType\":[\"decirator\"],\"isVaildDependence\":[\"target\"],\"getAtionByName\":[\"name\"],\"getClassAction\":[],\"getMethodAction\":[],\"getPropertyAction\":[],\"getParameterAction\":[],\"getConstructorParameters\":[\"type\"],\"getMethodParameters\":[\"type\",\"instance\",\"propertyKey\"],\"getParamerterNames\":[\"type\",\"propertyKey\"],\"isSingletonType\":[\"type\"],\"getMethodMetadatas\":[\"type\",\"propertyKey\"],\"filerDecorators\":[\"express\"],\"getParameters\":[\"type\",\"instance\",\"propertyKey\"],\"getTypeDecorators\":[\"decType\",\"match\"],\"buildAction\":[],\"toActionName\":[\"type\"]}};\n                        }\n                   }\r\n","import { Token, Type, Express } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { isClass, isToken, lang } from '../utils';\r\nimport { IMetaAccessor, IAnnotationMetadata } from './IMetaAccessor';\r\nimport { getClassDecorators, getTypeMetadata } from './factories';\r\n\r\n\r\n/**\r\n * class metadata accessor.\r\n *\r\n * @export\r\n * @class MetaAccessor\r\n * @implements {IMetaAccessor<any>}\r\n */\r\nexport class MetaAccessor implements IMetaAccessor<any> {\r\n\r\n    constructor() {\r\n    }\r\n\r\n    getDecorators(type: Type<any>): string[] {\r\n        return getClassDecorators(type);\r\n    }\r\n\r\n    /**\r\n     * get metadata config of target type. via decorators in order.\r\n     *\r\n     * @param {Token<any>} token\r\n     * @param {IContainer} container\r\n     * @param {IAnnotationMetadata<any>} [extConfig]\r\n     * @param {Express<string, boolean>} [decorFilter]\r\n     * @returns {IAnnotationMetadata<any>}\r\n     * @memberof MetaAccessor\r\n     */\r\n    getMetadata(token: Token<any>, container: IContainer, extConfig?: IAnnotationMetadata<any>, decorFilter?: Express<string, boolean>): IAnnotationMetadata<any> {\r\n        let type = isClass(token) ? token : container.getTokenImpl(token);\r\n        let cfg;\r\n        if (isClass(type)) {\r\n            let decors = this.getDecorators(type);\r\n            if (decorFilter) {\r\n                decors = decors.filter(decorFilter);\r\n            }\r\n            let classmeta = {};\r\n            decors.forEach(decor => {\r\n                let metas = getTypeMetadata<IAnnotationMetadata<any>>(decor, type);\r\n                if (metas && metas.length) {\r\n                    metas.forEach(meta => {\r\n                        if (meta) {\r\n                            classmeta = lang.assign({}, classmeta, meta);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n            cfg = classmeta;\r\n        }\r\n        if (cfg) {\r\n            return lang.assign({}, cfg, extConfig || {});\r\n        } else {\r\n            return extConfig || {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find metadata accessor.\r\n     *\r\n     * @param {Token<any>} token\r\n     * @param {IContainer} container\r\n     * @param {Express<IAnnotationMetadata<any>, boolean>} filter\r\n     * @param {Express<string, boolean>} [decorFilter]\r\n     * @returns {IAnnotationMetadata<any>}\r\n     * @memberof MetaAccessor\r\n     */\r\n    find(token: Token<any>, container: IContainer, filter: Express<IAnnotationMetadata<any>, boolean>, decorFilter?: Express<string, boolean>): IAnnotationMetadata<any> {\r\n        let type = isClass(token) ? token : container.getTokenImpl(token);\r\n        let metadata = null;\r\n        if (isClass(type)) {\r\n            let decors = this.getDecorators(type);\r\n            if (decorFilter) {\r\n                decors = decors.filter(decorFilter);\r\n            }\r\n            decors.some(decor => {\r\n                let metas = getTypeMetadata<IAnnotationMetadata<any>>(decor, type);\r\n                if (metas && metas.length) {\r\n                    return metas.some(meta => {\r\n                        if (meta && filter(meta)) {\r\n                            metadata = meta;\r\n                        }\r\n                        return !!metadata;\r\n                    });\r\n                }\r\n                return false;\r\n            });\r\n        }\r\n        return metadata;\r\n    }\r\n\r\n    /**\r\n     * filter metadata accessor.\r\n     *\r\n     * @param {Token<any>} token\r\n     * @param {IContainer} container\r\n     * @param {Express<IAnnotationMetadata<any>, boolean>} filter\r\n     * @param {Express<string, boolean>} [decorFilter]\r\n     * @returns {IAnnotationMetadata<any>[]}\r\n     * @memberof MetaAccessor\r\n     */\r\n    filter(token: Token<any>, container: IContainer, filter: Express<IAnnotationMetadata<any>, boolean>, decorFilter?: Express<string, boolean>): IAnnotationMetadata<any>[] {\r\n        let type = isClass(token) ? token : container.getTokenImpl(token);\r\n        let metadatas = [];\r\n        if (isClass(type)) {\r\n            let decors = this.getDecorators(type);\r\n            if (decorFilter) {\r\n                decors = decors.filter(decorFilter);\r\n            }\r\n            decors.forEach(decor => {\r\n                let metas = getTypeMetadata<IAnnotationMetadata<any>>(decor, type);\r\n                if (metas && metas.length) {\r\n                    metas.filter(meta => meta && filter(meta)).forEach(meta => {\r\n                        metadatas.push(meta);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        return metadatas;\r\n    }\r\n\r\n    /**\r\n     * get token of metadata config.\r\n     *\r\n     * @param {IAnnotationMetadata<any>} config\r\n     * @param {IContainer} [container] vaild token in container or not.\r\n     * @returns {Token<any>}\r\n     * @memberof MetadataManager\r\n     */\r\n    getToken(config: IAnnotationMetadata<any>, container?: IContainer): Token<any> {\r\n        let token = this.getTokenInConfig(config);\r\n        if (this.validateToken(token, container)) {\r\n            return token;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get module boot token from module configure.\r\n     *\r\n     * @param {IAnnotationMetadata<any>} config\r\n     * @param {IContainer} [container]  vaild container.\r\n     * @returns {Token<any>}\r\n     * @memberof ModuelValidate\r\n     */\r\n    getBootToken(config: IAnnotationMetadata<any>, container?: IContainer): Token<any> {\r\n        let token = this.getBootTokenInConfig(config);\r\n        if (this.validateToken(token, container)) {\r\n            return token\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    protected validateToken(token: Token<any>, container?: IContainer): boolean {\r\n        return isToken(token);\r\n    }\r\n\r\n    protected getTokenInConfig(config: IAnnotationMetadata<any>): Token<any> {\r\n        return config.token || config.type;\r\n    }\r\n\r\n    protected getBootTokenInConfig(config: IAnnotationMetadata<any>) {\r\n        return config.bootstrap;\r\n    }\r\n\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"MetaAccessor\",\"params\":{\"constructor\":[],\"getDecorators\":[\"type\"],\"getMetadata\":[\"token\",\"container\",\"extConfig\",\"decorFilter\"],\"find\":[\"token\",\"container\",\"filter\",\"decorFilter\"],\"filter\":[\"token\",\"container\",\"filter\",\"decorFilter\"],\"getToken\":[\"config\",\"container\"],\"getBootToken\":[\"config\",\"container\"],\"validateToken\":[\"token\",\"container\"],\"getTokenInConfig\":[\"config\"],\"getBootTokenInConfig\":[\"config\"]}};\n                        }\n                   }\r\n","import { IContainer } from '../IContainer';\r\nimport { IMethodAccessor } from '../IMethodAccessor';\r\nimport { BindParameterProviderActionData, CoreActions, LifeState } from './actions';\r\nimport { isToken, isFunction, lang, isNullOrUndefined } from '../utils';\r\nimport { Type } from '../types';\r\nimport { IParameter } from '../IParameter';\r\nimport { ParamProviders, isProvider } from '../providers';\r\n\r\n/**\r\n * method accessor\r\n *\r\n * @export\r\n * @class MethodAccessor\r\n * @implements {IMethodAccessor}\r\n */\r\nexport class MethodAccessor implements IMethodAccessor {\r\n\r\n    constructor(private container: IContainer) {\r\n\r\n    }\r\n\r\n    async invoke<T>(target: any, propertyKey: string, instance?: any, ...providers: ParamProviders[]): Promise<T> {\r\n\r\n        let targetClass: Type<any>;\r\n        if (isProvider(instance)) {\r\n            providers.unshift(instance);\r\n            instance = undefined;\r\n        }\r\n        if (isToken(target)) {\r\n            if (isNullOrUndefined(instance)) {\r\n                targetClass = this.container.getTokenImpl(target);\r\n                instance = this.container.resolve(target, ...providers);\r\n            } else {\r\n                targetClass = lang.getClass(instance) || this.container.getTokenImpl(target);\r\n            }\r\n            lang.assert(targetClass, target.toString() + ' is not implements by any class.');\r\n        } else {\r\n            targetClass = lang.getClass(target);\r\n            instance = target;\r\n        }\r\n\r\n        lang.assertExp(instance && isFunction(instance[propertyKey]), `type: ${targetClass} has no method ${propertyKey.toString()}.`);\r\n        let actionData = {\r\n            target: instance,\r\n            targetType: targetClass,\r\n            propertyKey: propertyKey,\r\n        } as BindParameterProviderActionData;\r\n        let lifeScope = this.container.getLifeScope();\r\n        lifeScope.execute(actionData, LifeState.onInit, CoreActions.bindParameterProviders);\r\n        providers = providers.concat(actionData.execResult);\r\n\r\n        let parameters = lifeScope.getMethodParameters(targetClass, instance, propertyKey);\r\n\r\n        let paramInstances = await this.createParams(parameters, ...providers);\r\n\r\n        return instance[propertyKey](...paramInstances) as T;\r\n\r\n    }\r\n\r\n    syncInvoke<T>(target: any, propertyKey: string, instance?: any, ...providers: ParamProviders[]): T {\r\n        let targetClass: Type<any>;\r\n        if (isProvider(instance)) {\r\n            providers.unshift(instance);\r\n            instance = undefined;\r\n        }\r\n        if (isToken(target)) {\r\n            targetClass = this.container.getTokenImpl(target);\r\n            lang.assert(targetClass, target.toString() + ' is not implements by any class.');\r\n            if (isNullOrUndefined(instance)) {\r\n                instance = this.container.resolve(target, ...providers);\r\n            }\r\n        } else {\r\n            targetClass = lang.getClass(target);\r\n            instance = target;\r\n        }\r\n        lang.assertExp(instance && isFunction(instance[propertyKey]), `type: ${targetClass} has no method ${propertyKey.toString()}.`);\r\n\r\n        let actionData = {\r\n            target: instance,\r\n            targetType: targetClass,\r\n            propertyKey: propertyKey,\r\n        } as BindParameterProviderActionData;\r\n        let lifeScope = this.container.getLifeScope();\r\n        lifeScope.execute(actionData, LifeState.onInit, CoreActions.bindParameterProviders);\r\n\r\n        providers = providers.concat(actionData.execResult);\r\n        let parameters = lifeScope.getMethodParameters(targetClass, instance, propertyKey);\r\n        let paramInstances = this.createSyncParams(parameters, ...providers);\r\n\r\n        return instance[propertyKey](...paramInstances) as T;\r\n    }\r\n\r\n    createSyncParams(params: IParameter[], ...providers: ParamProviders[]): any[] {\r\n        let providerMap = this.container.getProviderParser().parse(...providers);\r\n        return params.map((param, index) => {\r\n            if (param.name && providerMap.has(param.name)) {\r\n                return providerMap.resolve(param.name);\r\n            } else if (isToken(param.type)) {\r\n                if (providerMap.has(param.type)) {\r\n                    return providerMap.resolve(param.type);\r\n                }\r\n                return this.container.resolve(param.type, providerMap);\r\n            } else {\r\n                return undefined;\r\n            }\r\n        });\r\n    }\r\n\r\n    createParams(params: IParameter[], ...providers: ParamProviders[]): Promise<any[]> {\r\n        let providerMap = this.container.getProviderParser().parse(...providers);\r\n        return Promise.all(params.map((param, index) => {\r\n            if (param.name && providerMap.has(param.name)) {\r\n                return providerMap.resolve(param.name);\r\n            } else if (isToken(param.type)) {\r\n                if (providerMap.has(param.type)) {\r\n                    return providerMap.resolve(param.type);\r\n                }\r\n                return this.container.resolve(param.type, providerMap);\r\n            } else {\r\n                return undefined;\r\n            }\r\n        }));\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"MethodAccessor\",\"params\":{\"constructor\":[\"container\"],\"invoke\":[\"target\",\"propertyKey\",\"instance\",\"providers\"],\"syncInvoke\":[\"target\",\"propertyKey\",\"instance\",\"providers\"],\"createSyncParams\":[\"params\",\"providers\"],\"createParams\":[\"params\",\"providers\"]}};\n                        }\n                   }\r\n","import { isFunction, isNumber } from '../utils';\r\nimport { Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { OnDestroy } from './ComponentLifecycle';\r\nimport { ICacheManager } from '../ICacheManager';\r\n\r\n/**\r\n * cache target.\r\n *\r\n * @export\r\n * @interface CacheTarget\r\n */\r\nexport interface CacheTarget {\r\n    target: any;\r\n    expires: number;\r\n}\r\n\r\n/**\r\n * cache manager.\r\n *\r\n * @export\r\n * @class CacheManager\r\n * @implements {ICacheManager}\r\n */\r\nexport class CacheManager implements ICacheManager {\r\n\r\n    cacheTokens: Map<Type<any>, CacheTarget>;\r\n    constructor(private container: IContainer) {\r\n        this.cacheTokens = new Map();\r\n    }\r\n\r\n    isChecking() {\r\n        return !!this.timeout;\r\n    }\r\n\r\n    hasCache(targetType: Type<any>) {\r\n        return this.cacheTokens.has(targetType);\r\n    }\r\n\r\n    cache(targetType: Type<any>, target: any, expires: number) {\r\n        let cache: CacheTarget;\r\n        if (this.hasCache(targetType)) {\r\n            cache = this.cacheTokens.get(targetType)\r\n            cache.expires = Date.now() + expires;\r\n        } else {\r\n            cache = {\r\n                target: target,\r\n                expires: Date.now() + expires\r\n            }\r\n        }\r\n        this.cacheTokens.set(targetType, cache);\r\n        if (!this.isChecking()) {\r\n            this.checkExpires();\r\n        }\r\n    }\r\n\r\n    get(targetType: Type<any>, expires?: number) {\r\n        let result = null;\r\n        if (!this.cacheTokens.has(targetType)) {\r\n            return null;\r\n        }\r\n        let cache = this.cacheTokens.get(targetType);\r\n        if (cache.expires <= Date.now()) {\r\n            result = cache.target;\r\n            if (isNumber(expires) && expires > 0) {\r\n                cache.expires = Date.now() + expires;\r\n                this.cacheTokens.set(targetType, cache);\r\n            }\r\n        } else {\r\n            this.destroy(targetType, cache.target);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private timeout;\r\n    checkExpires() {\r\n        if (this.timeout) {\r\n            clearTimeout(this.timeout);\r\n            this.timeout = 0;\r\n        }\r\n        if (this.cacheTokens.size > 0) {\r\n            let timeoutCaches = [];\r\n            this.cacheTokens.forEach((cache, targetType) => {\r\n                if (cache.expires >= Date.now()) {\r\n                    timeoutCaches.push(targetType);\r\n                }\r\n            });\r\n\r\n            if (timeoutCaches.length) {\r\n                timeoutCaches.forEach(targetType => {\r\n                    this.destroy(targetType, this.cacheTokens.get(targetType).target);\r\n                });\r\n            }\r\n\r\n            this.timeout = setTimeout(() => {\r\n                this.checkExpires();\r\n            }, 60000);\r\n        }\r\n    }\r\n\r\n    destroy(targetType: Type<any>, target?: any) {\r\n\r\n        if (!this.hasCache(targetType)) {\r\n            return;\r\n        }\r\n        if (!target) {\r\n            target = this.cacheTokens.get(targetType).target;\r\n        }\r\n\r\n        try {\r\n            let component = target as OnDestroy;\r\n            if (isFunction(component.onDestroy)) {\r\n                this.container.syncInvoke(target || targetType, 'onDestroy', target);\r\n            }\r\n            this.cacheTokens.delete(targetType);\r\n        } catch (err) {\r\n            console.error && console.error(err);\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"CacheManager\",\"params\":{\"constructor\":[\"container\"],\"isChecking\":[],\"hasCache\":[\"targetType\"],\"cache\":[\"targetType\",\"target\",\"expires\"],\"get\":[\"targetType\",\"expires\"],\"checkExpires\":[],\"destroy\":[\"targetType\",\"target\"]}};\n                        }\n                   }\r\n","\r\nexport * from './actions';\r\nexport * from './decorators';\r\nexport * from './metadatas';\r\nexport * from './factories';\r\n\r\nexport * from './IRecognizer';\r\nexport * from './ActionData';\r\nexport * from './ActionFactory';\r\nexport * from './DefaultLifeScope';\r\nexport * from './IExecutable';\r\nexport * from './IMetaAccessor';\r\nexport * from './MetaAccessor';\r\nexport * from './MethodAccessor';\r\nexport * from './ComponentLifecycle';\r\nexport * from './CacheManager';\r\n","import { IContainer } from './IContainer';\r\nimport { Type, Modules, LoadType } from './types';\r\nimport { InjectToken } from './InjectToken';\r\nimport { IModuleLoader, IModuleInjectorChain } from './injectors';\r\n\r\n/**\r\n * ContainerBuilder interface token.\r\n * it is a token id, you can register yourself IContainerBuilder for this.\r\n */\r\nexport const ContainerBuilderToken = new InjectToken<IContainerBuilder>('DI_IContainerBuilder');\r\n\r\n/**\r\n * container builder.\r\n *\r\n * @export\r\n * @interface IContainerBuilder\r\n */\r\nexport interface IContainerBuilder {\r\n\r\n    /**\r\n     * loader\r\n     *\r\n     * @type {IModuleLoader}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    readonly loader: IModuleLoader;\r\n\r\n    /**\r\n     * create a new container.\r\n     *\r\n     * @returns {IContainer}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    create(): IContainer;\r\n\r\n    /**\r\n     * create a new container and load module via options.\r\n     *\r\n     * @param {...LoadType[]} modules\r\n     * @param {string} [basePath]\r\n     * @returns {Promise<IContainer>}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    build(...modules: LoadType[]): Promise<IContainer>;\r\n\r\n    /**\r\n     * build container in sync.\r\n     *\r\n     * @param {LoadOptions} options\r\n     * @returns {IContainer}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    syncBuild(...modules: Modules[]): IContainer;\r\n\r\n    /**\r\n     * load modules for container.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {...LoadType[]} modules\r\n     * @returns {Promise<Type<any>[]>}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    loadModule(container: IContainer, ...modules: LoadType[]): Promise<Type<any>[]>;\r\n\r\n    /**\r\n     * sync load modules\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {...Modules[]} modules\r\n     * @memberof IContainerBuilder\r\n     */\r\n    syncLoadModule(container: IContainer, ...modules: Modules[]);\r\n\r\n    /**\r\n     * get moduleInjector chain.\r\n     *\r\n     * @param {IContainer} container\r\n     * @returns {IModuleInjectorChain}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    getInjectorChain(container: IContainer): IModuleInjectorChain;\r\n\r\n}\r\n","import { MethodMetadata, ActionComponent, ActionData, DecoratorType } from './core';\r\nimport { Type, Express } from './types';\r\nimport { IParameter } from './IParameter';\r\nimport { InjectToken } from './InjectToken';\r\n\r\n/**\r\n * Decorator summary.\r\n *\r\n * @export\r\n * @interface DecorSummary\r\n */\r\nexport interface DecorSummary {\r\n    /**\r\n     * decorator name.\r\n     *\r\n     * @type {string}\r\n     * @memberof DecorSummary\r\n     */\r\n    name: string;\r\n    /**\r\n     * decorator types.\r\n     *\r\n     * @type {string}\r\n     * @memberof DecorSummary\r\n     */\r\n    types: string;\r\n    /**\r\n     * decorator registed actions.\r\n     *\r\n     * @type {string[]}\r\n     * @memberof DecorSummary\r\n     */\r\n    actions: string[];\r\n}\r\n\r\n/**\r\n * life scope interface symbol.\r\n * it is a symbol id, you can register yourself MethodAccessor for this.\r\n */\r\nexport const LifeScopeToken = new InjectToken<LifeScope>('DI_LifeScope');\r\n\r\n/**\r\n * life scope of decorator.\r\n *\r\n * @export\r\n * @interface LifeScope\r\n */\r\nexport interface LifeScope {\r\n    /**\r\n     * execute the action work.\r\n     *\r\n     * @template T\r\n     * @param {ActionData<T>} data execute data;\r\n     * @param {string} names execute action name.\r\n     * @memberof ActionComponent\r\n     */\r\n    execute<T>(data: ActionData<T>, ...names: string[]);\r\n\r\n    /**\r\n     * execute the action work route with parent container.\r\n     *\r\n     * @template T\r\n     * @param {ActionData<T>} data\r\n     * @param {...string[]} names\r\n     * @memberof LifeScope\r\n     */\r\n    routeExecute<T>(data: ActionData<T>, ...names: string[]);\r\n\r\n    /**\r\n     * register action.\r\n     *\r\n     * @param {ActionComponent} action the action.\r\n     * @param {...string[]} express the path  of action point to add the action.\r\n     * @returns {this}\r\n     * @memberof LifeScope\r\n     */\r\n    addAction(action: ActionComponent, ...nodepaths: string[]): this;\r\n\r\n    /**\r\n     * register decorator.\r\n     *\r\n     * @param {Function} decorator decorator\r\n     * @param {...string[]} actions action names.\r\n     * @returns {this}\r\n     * @memberof LifeScope\r\n     */\r\n    registerDecorator(decorator: Function, ...actions: string[]): this;\r\n\r\n    /**\r\n     * register decorator.\r\n     *\r\n     * @param {Function} decorator decorator\r\n     * @param {DecoratorType} type  custom set decorator type.\r\n     * @param {...string[]} actions action names.\r\n     * @returns {this}\r\n     * @memberof LifeScope\r\n     */\r\n    registerCustomDecorator(decorator: Function, type: DecoratorType, ...actions: string[]): this;\r\n\r\n    /**\r\n     * filter match decorators.\r\n     *\r\n     * @param {Express<DecorSummary, boolean>} express\r\n     * @returns {DecorSummary[]}\r\n     * @memberof LifeScope\r\n     */\r\n    filerDecorators(express: Express<DecorSummary, boolean>): DecorSummary[];\r\n\r\n    /**\r\n     * has decorator.\r\n     *\r\n     * @param {(Type<any> | any)} target\r\n     * @param {DecoratorType} dtype\r\n     * @param {Express<DecorSummary, boolean>} [match]\r\n     * @returns {boolean}\r\n     * @memberof LifeScope\r\n     */\r\n    hasDecorator(target: Type<any> | any, dtype: DecoratorType, match?: Express<DecorSummary, boolean>): boolean;\r\n\r\n    /**\r\n     * get class decorators\r\n     *\r\n     * @param {Type<any>} type\r\n     * @param {Express<DecorSummary, boolean>} [match]\r\n     * @returns {DecorSummary[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getClassDecorators(type: Type<any>, match?: Express<DecorSummary, boolean>): DecorSummary[];\r\n\r\n    /**\r\n     * get method decorators\r\n     *\r\n     * @param {Type<any>} type\r\n     * @param {Express<DecorSummary, boolean>} [match]\r\n     * @returns {DecorSummary[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getMethodDecorators(type: Type<any>, match?: Express<DecorSummary, boolean>): DecorSummary[];\r\n\r\n    /**\r\n     * get property decorators\r\n     *\r\n     * @param {Type<any>} type\r\n     * @param {Express<DecorSummary, boolean>} [match]\r\n     * @returns {DecorSummary[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getPropertyDecorators(type: Type<any>, match?: Express<DecorSummary, boolean>): DecorSummary[];\r\n\r\n    /**\r\n     * get parameter decorators\r\n     *\r\n     * @param {Type<any>} type\r\n     * @param {string} propertyKey\r\n     * @param {Express<DecorSummary, boolean>} [match]\r\n     * @returns {DecorSummary[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getParameterDecorators(target: any, propertyKey: string, match?: Express<DecorSummary, boolean>): DecorSummary[];\r\n\r\n\r\n    /**\r\n     * get decorator type.\r\n     *\r\n     * @param {*} decorator\r\n     * @returns {DecoratorType}\r\n     * @memberof LifeScope\r\n     */\r\n    getDecoratorType(decorator: any): DecoratorType;\r\n\r\n    /**\r\n     * is vaildate dependence type or not. dependence type must with class decorator.\r\n     *\r\n     * @template T\r\n     * @param {any} target\r\n     * @returns {boolean}\r\n     * @memberof LifeScope\r\n     */\r\n    isVaildDependence<T>(target: any): boolean;\r\n\r\n    /**\r\n     * is singleton or not.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @returns {boolean}\r\n     * @memberof LifeScope\r\n     */\r\n    isSingletonType<T>(type: Type<T>): boolean;\r\n\r\n    /**\r\n     * get action by name.\r\n     *\r\n     * @param {string} name\r\n     * @returns {ActionComponent}\r\n     * @memberof LifeScope\r\n     */\r\n    getAtionByName(name: string): ActionComponent;\r\n\r\n    /**\r\n     * get class action.\r\n     *\r\n     * @returns {ActionComponent}\r\n     * @memberof LifeScope\r\n     */\r\n    getClassAction(): ActionComponent;\r\n\r\n    /**\r\n     * get method action.\r\n     *\r\n     * @returns {ActionComponent}\r\n     * @memberof LifeScope\r\n     */\r\n    getMethodAction(): ActionComponent;\r\n\r\n    /**\r\n     * get propert action.\r\n     *\r\n     * @returns {ActionComponent}\r\n     * @memberof LifeScope\r\n     */\r\n    getPropertyAction(): ActionComponent;\r\n\r\n    /**\r\n     * get parameter action.\r\n     *\r\n     * @returns {ActionComponent}\r\n     * @memberof LifeScope\r\n     */\r\n    getParameterAction(): ActionComponent;\r\n\r\n    /**\r\n     * get paramerter names.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @param {string} propertyKey\r\n     * @returns {string[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getParamerterNames<T>(type: Type<T>, propertyKey: string): string[];\r\n\r\n    /**\r\n     * get constructor parameters metadata.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @returns {IParameter[]}\r\n     * @memberof IContainer\r\n     */\r\n    getConstructorParameters<T>(type: Type<T>): IParameter[];\r\n\r\n    /**\r\n     * get method params metadata.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @param {T} instance\r\n     * @param {string} propertyKey\r\n     * @returns {IParameter[]}\r\n     * @memberof IContainer\r\n     */\r\n    getMethodParameters<T>(type: Type<T>, instance: T, propertyKey: string): IParameter[];\r\n\r\n\r\n    /**\r\n     * get method metadatas\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @param {(string | symbol)} propertyKey\r\n     * @returns {MethodMetadata[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getMethodMetadatas<T>(type: Type<T>, propertyKey: string | symbol): MethodMetadata[];\r\n\r\n    /**\r\n     * convert decorator type to action name.\r\n     *\r\n     * @param {DecoratorType} type\r\n     * @returns {string}\r\n     * @memberof LifeScope\r\n     */\r\n    toActionName(type: DecoratorType): string;\r\n}\r\n","import { Type, Token, InstanceFactory } from '../types';\r\nimport { IContainer, ResoveWay } from '../IContainer';\r\nimport { InjectToken } from '../InjectToken';\r\nimport { IResolver, IResolverContainer } from '../IResolver';\r\nimport { ParamProviders, ProviderMap, isProviderMap } from '../providers';\r\nimport { isString, isNumber, isFunction, isClass } from '../utils';\r\n\r\n/**\r\n *  resolver chain token.\r\n */\r\nexport const ResolverChainToken = new InjectToken<ResolverChain>('di_ResolverChain');\r\n\r\n/**\r\n * resover chain.\r\n *\r\n * resove by setp.\r\n *\r\n * @export\r\n * @class ResolverChain\r\n * @implements {IResolver}\r\n */\r\nexport class ResolverChain implements IResolverContainer {\r\n\r\n    /**\r\n     * resolvers\r\n     *\r\n     * @protected\r\n     * @type {IResolver[]}\r\n     * @memberof ResolverChain\r\n     */\r\n    protected resolvers: IResolver[];\r\n\r\n    constructor(protected container: IContainer) {\r\n        this.resolvers = [];\r\n    }\r\n\r\n    get size(): number {\r\n        return this.resolvers.length + 1;\r\n    }\r\n\r\n    /**\r\n     * reigister next resolver.\r\n     *\r\n     * @param {IResolver} resolver\r\n     * @memberof ResolverChain\r\n     */\r\n    next(resolver: IResolver) {\r\n        if (!this.hasResolver(resolver)) {\r\n            this.resolvers.push(resolver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * has resolver or not.\r\n     *\r\n     * @param {IResolver} resolver\r\n     * @returns\r\n     * @memberof ResolverChain\r\n     */\r\n    hasResolver(resolver: IResolver) {\r\n        if (resolver === this.container) {\r\n            return true;\r\n        }\r\n        return this.resolvers.indexOf(resolver) >= 0;\r\n    }\r\n\r\n    /**\r\n     * resove token via registered resolver chain.\r\n     *\r\n     * @template T\r\n     * @param {SymbolType<T>} token\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof ResolverChain\r\n     */\r\n    resolve<T>(token: Token<T>, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T {\r\n        let key = this.container.getTokenKey(token, isString(resway) ? resway : null);\r\n        let way: ResoveWay;\r\n        if (isNumber(resway)) {\r\n            way = resway;\r\n        } else {\r\n            if (resway) {\r\n                providers.unshift(resway);\r\n            }\r\n            way = ResoveWay.all;\r\n        }\r\n        let providerMap: ProviderMap;\r\n        if (providers.length) {\r\n            if (providers.length === 1 && isProviderMap(providers[0])) {\r\n                providerMap = providers[0] as ProviderMap;\r\n            } else {\r\n                providerMap = this.container.getProviderParser().parse(...providers);\r\n            }\r\n        }\r\n        if (providerMap && providerMap.has(token)) {\r\n            return providerMap.resolve(token, providerMap);\r\n        }\r\n\r\n        if ((way & ResoveWay.current) && this.container.hasRegister(key)) {\r\n            return this.container.resolveValue(key, providerMap);\r\n        }\r\n        if ((way & ResoveWay.traverse)) {\r\n            let resolver = this.resolvers.find(r => r.has(key, ResoveWay.nodes));\r\n            if (resolver) {\r\n                return resolver.resolve(key, ResoveWay.nodes, providerMap);\r\n            }\r\n        }\r\n        if (this.container.parent && (way & ResoveWay.bubble)) {\r\n            return this.container.parent.resolve(key, resway, providerMap);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * unregister token in registered resolver chain.\r\n     *\r\n     * @template T\r\n     * @param {SymbolType<T>} token\r\n     * @memberof ResolverChain\r\n     */\r\n    unregister<T>(token: Token<T>, resway?: ResoveWay) {\r\n        resway = resway || ResoveWay.all;\r\n        let tokenKey = this.container.getTokenKey(token);\r\n        if (resway & ResoveWay.current) {\r\n            this.container.unregisterValue(tokenKey);\r\n        }\r\n        if (resway & ResoveWay.traverse) {\r\n            this.resolvers.forEach((r: IResolverContainer) => {\r\n                if (isFunction(r.unregister)) {\r\n                    r.unregister(tokenKey, ResoveWay.nodes);\r\n                }\r\n            });\r\n        }\r\n        if ((resway & ResoveWay.bubble) && this.container.parent) {\r\n            this.container.parent.unregister(token, resway);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * get token implements class in the registered resolver chain.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @returns {Type<T>}\r\n     * @memberof ResolverChain\r\n     */\r\n    getTokenImpl<T>(token: Token<T>, resway?: ResoveWay): Type<T> {\r\n        if (isClass(token)) {\r\n            return token;\r\n        }\r\n        resway = resway || ResoveWay.nodes;\r\n        let tokenKey = this.container.getTokenKey(token);\r\n        let provider: Type<T>;\r\n        if (resway & ResoveWay.current) {\r\n            provider = this.container.getTokenProvider(tokenKey);\r\n        }\r\n        if (!provider && (resway & ResoveWay.traverse)) {\r\n            this.resolvers.some((r: IResolverContainer) => {\r\n                if (!isFunction(r.getTokenImpl)) {\r\n                    return false;\r\n                }\r\n                provider = r.getTokenImpl(tokenKey, ResoveWay.nodes);\r\n                return !!provider;\r\n            });\r\n        }\r\n        if (!provider && (resway & ResoveWay.bubble) && this.container.parent) {\r\n            provider = this.container.parent.getTokenImpl(token, resway);\r\n        }\r\n\r\n        return provider || null;\r\n    }\r\n\r\n    /**\r\n     * has token or not in the registered resolver chain.\r\n     *\r\n     * @template T\r\n     * @param {SymbolType<T>} token\r\n     * @returns {boolean}\r\n     * @memberof ResolverChain\r\n     */\r\n    has<T>(token: Token<T>, aliasOrway?: string | ResoveWay): boolean {\r\n        let key = this.container.getTokenKey(token, isString(aliasOrway) ? aliasOrway : null);\r\n        let resway = isNumber(aliasOrway) ? aliasOrway : ResoveWay.all;\r\n        if ((resway & ResoveWay.current) && this.container.hasRegister(key)) {\r\n            return true;\r\n        }\r\n        if ((resway & ResoveWay.traverse) && this.resolvers.some(r => r.has(key, ResoveWay.nodes))) {\r\n            return true;\r\n        }\r\n        if ((resway & ResoveWay.bubble) && this.container.parent) {\r\n            return this.container.parent.has(token, resway);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * resolver chain to array.\r\n     *\r\n     * @returns {IResolver[]}\r\n     * @memberof ResolverChain\r\n     */\r\n    toArray(resway = ResoveWay.all): IResolver[] {\r\n        if (resway & ResoveWay.nodes) {\r\n            return [<IResolver>this.container].concat(this.resolvers);\r\n        } else if (resway & ResoveWay.current) {\r\n            return [this.container];\r\n        } else if (resway & ResoveWay.traverse) {\r\n            return this.resolvers;\r\n        }\r\n        return [];\r\n    }\r\n\r\n    forEach(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean): void | boolean {\r\n        if (this.container.forEach(callbackfn) === false) {\r\n            return false;\r\n        }\r\n        return !this.resolvers.some((r: IResolverContainer) => {\r\n            if (isFunction(r.forEach)) {\r\n                return r.forEach(callbackfn) === false;\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * iterator all resolvers.\r\n     *\r\n     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void} callbackfn\r\n     * @memberof ResolverChain\r\n     */\r\n    iterator(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void, resway = ResoveWay.all): void | boolean {\r\n        if (resway & ResoveWay.current) {\r\n            if (this.container.forEach(callbackfn) === false) {\r\n                return false;\r\n            }\r\n        }\r\n        if (resway & ResoveWay.traverse) {\r\n            if (this.resolvers.some((r: IResolverContainer) => {\r\n                if (isFunction(r.forEach)) {\r\n                    return r.forEach(callbackfn) === false;\r\n                }\r\n                return false;\r\n            })) {\r\n                return false;\r\n            }\r\n        }\r\n        if (this.container.parent && (resway & ResoveWay.bubble)) {\r\n            return this.container.parent.iterator(callbackfn, resway);\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ResolverChain\",\"params\":{\"constructor\":[\"container\"],\"next\":[\"resolver\"],\"hasResolver\":[\"resolver\"],\"resolve\":[\"token\",\"resway\",\"providers\"],\"unregister\":[\"token\",\"resway\"],\"getTokenImpl\":[\"token\",\"resway\"],\"has\":[\"token\",\"aliasOrway\"],\"toArray\":[\"resway\"],\"forEach\":[\"callbackfn\"],\"iterator\":[\"callbackfn\",\"resway\"]}};\n                        }\n                   }\r\n","export * from './ResolverType';\r\nexport * from './ResolverChain';\r\n","import { IContainer } from './IContainer';\r\nimport { LifeScopeToken } from './LifeScope';\r\nimport {\r\n    CacheManager, Injectable, Component, AutoWired, Inject, Singleton, Param,\r\n    Method, Abstract, Autorun, IocExt, Refs, Providers, CoreActions, MethodAccessor,\r\n    MetaAccessor, MetaAccessorToken, DefaultLifeScope\r\n} from './core'\r\nimport { CacheManagerToken } from './ICacheManager';\r\nimport { MethodAccessorToken } from './IMethodAccessor';\r\nimport { ResolverChain, ResolverChainToken } from './resolves';\r\nimport { ProviderMap, ProviderMapToken, ProviderParser, ProviderParserToken } from './providers';\r\n\r\n/**\r\n * register core for container.\r\n *\r\n * @export\r\n * @param {IContainer} container\r\n */\r\nexport function registerCores(container: IContainer) {\r\n    container.registerSingleton(LifeScopeToken, () => new DefaultLifeScope(container));\r\n    container.registerSingleton(CacheManagerToken, () => new CacheManager(container));\r\n    container.registerSingleton(ResolverChainToken, () => new ResolverChain(container));\r\n    container.register(ProviderMapToken, () => new ProviderMap(container));\r\n    container.bindProvider(ProviderMap, ProviderMapToken);\r\n    container.registerSingleton(ProviderParserToken, () => new ProviderParser(container));\r\n    container.registerSingleton(MethodAccessorToken, () => new MethodAccessor(container));\r\n    container.registerSingleton(MetaAccessorToken, MetaAccessor);\r\n\r\n    let lifeScope = container.get(LifeScopeToken);\r\n\r\n    lifeScope.registerDecorator(Injectable, CoreActions.bindProvider, CoreActions.cache);\r\n    lifeScope.registerDecorator(Component, CoreActions.bindProvider, CoreActions.cache, CoreActions.componentBeforeInit, CoreActions.componentInit, CoreActions.componentAfterInit);\r\n    lifeScope.registerDecorator(Singleton, CoreActions.bindProvider);\r\n    lifeScope.registerDecorator(Refs, CoreActions.bindProvider);\r\n    lifeScope.registerDecorator(Providers, CoreActions.bindProvider);\r\n    lifeScope.registerDecorator(Abstract, CoreActions.bindProvider, CoreActions.cache);\r\n    lifeScope.registerDecorator(AutoWired, CoreActions.bindParameterType, CoreActions.bindPropertyType);\r\n    lifeScope.registerDecorator(Inject, CoreActions.bindParameterType, CoreActions.bindPropertyType);\r\n    lifeScope.registerDecorator(Param, CoreActions.bindParameterType, CoreActions.bindPropertyType);\r\n    lifeScope.registerDecorator(Method, CoreActions.bindParameterProviders);\r\n\r\n    lifeScope.registerDecorator(Autorun, CoreActions.autorun, CoreActions.methodAutorun);\r\n    lifeScope.registerDecorator(IocExt, CoreActions.autorun, CoreActions.componentBeforeInit, CoreActions.componentInit, CoreActions.componentAfterInit);\r\n\r\n    container.register(Date, () => new Date());\r\n    container.register(String, () => '');\r\n    container.register(Number, () => Number.NaN);\r\n    container.register(Boolean, () => undefined);\r\n    container.register(Array, () => []);\r\n}\r\n","import 'reflect-metadata';\r\nimport { IContainer, ContainerToken, ResoveWay } from './IContainer';\r\nimport {\r\n    Type, Token, Factory, SymbolType, IocState,\r\n    ReferenceToken, RefTokenType, RefTokenFacType,\r\n    RefTokenFac, Modules, LoadType, RefTarget, RefTagLevel, ClassType, ToInstance, InstanceFactory\r\n} from './types';\r\nimport {\r\n    isClass, isFunction, isSymbol, isToken, isString, isUndefined,\r\n    lang, isArray, isBoolean, isRefTarget, isTypeObject, isAbstractClass, isClassType, isNumber\r\n} from './utils';\r\nimport { IParameter } from './IParameter';\r\nimport { Registration, isRegistrationClass } from './Registration';\r\nimport { MethodAccessorToken } from './IMethodAccessor';\r\nimport { CoreActions, CacheActionData, LifeState, ActionComponent, enumerable } from './core';\r\nimport { CacheManagerToken } from './ICacheManager';\r\nimport { IContainerBuilder, ContainerBuilderToken } from './IContainerBuilder';\r\nimport { registerCores } from './registerCores';\r\nimport { ResolverChain, ResolverChainToken } from './resolves';\r\nimport { InjectReference, InjectClassProvidesToken, isInjectReference } from './InjectReference';\r\nimport { LifeScope, LifeScopeToken } from './LifeScope';\r\nimport { ParamProviders, ProviderMap, ProviderParserToken, IProviderParser, ProviderTypes } from './providers';\r\nimport { IResolver } from './IResolver';\r\n\r\n/**\r\n * singleton reg token.\r\n */\r\nconst SingletonRegToken = '___IOC__Singleton___';\r\n\r\n/**\r\n * Container\r\n *\r\n * @export\r\n * @class Container\r\n * @implements {IContainer}\r\n */\r\nexport class Container implements IContainer {\r\n\r\n    // @enumerable(false)\r\n    parent: IContainer;\r\n\r\n    // @enumerable(false)\r\n    children: IContainer[] = [];\r\n\r\n    /**\r\n     * provide types.\r\n     *\r\n     * @protected\r\n     * @type {Map<Token<any>, Type<any>>}\r\n     * @memberof Container\r\n     */\r\n    protected provideTypes: Map<Token<any>, Type<any>>;\r\n    /**\r\n     * factories.\r\n     *\r\n     * @protected\r\n     * @type {Map<Token<any>, Function>}\r\n     * @memberof Container\r\n     */\r\n    protected factories: Map<Token<any>, InstanceFactory<any>>;\r\n\r\n    constructor() {\r\n        this.init();\r\n    }\r\n\r\n    get size(): number {\r\n        return this.factories.size;\r\n    }\r\n    /**\r\n     * get root container.\r\n     *\r\n     * @returns {IContainer}\r\n     * @memberof Container\r\n     */\r\n    getRoot(): IContainer {\r\n        let root: IContainer = this;\r\n        while (root.parent) {\r\n            root = root.parent;\r\n        }\r\n        return root;\r\n    }\r\n\r\n    private parser: IProviderParser;\r\n    getProviderParser(): IProviderParser {\r\n        if (!this.parser) {\r\n            this.parser = this.resolveValue(ProviderParserToken)\r\n        }\r\n        return this.parser;\r\n    }\r\n\r\n    /**\r\n     * get container builder.\r\n     *\r\n     * @returns {IContainerBuilder}\r\n     * @memberof Container\r\n     */\r\n    getBuilder(): IContainerBuilder {\r\n        return this.resolveValue(ContainerBuilderToken);\r\n    }\r\n\r\n    /**\r\n    * resolve token value in this container only.\r\n    *\r\n    * @template T\r\n    * @param {Token<T>} token\r\n    * @param {...ParamProviders[]} providers\r\n    * @returns {T}\r\n    * @memberof Container\r\n    */\r\n    getResolvers(): ResolverChain {\r\n        return this.resolveValue(ResolverChainToken);\r\n    }\r\n\r\n    /**\r\n     * has register the token or not.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [aliasOrway]\r\n     * @returns {boolean}\r\n     * @memberof Container\r\n     */\r\n    has<T>(token: Token<T>, aliasOrway?: string | ResoveWay): boolean {\r\n        return this.getResolvers().has(token, aliasOrway);\r\n    }\r\n\r\n    /**\r\n     * has register type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} key\r\n     * @returns\r\n     * @memberof Container\r\n     */\r\n    hasRegister<T>(key: Token<T>): boolean {\r\n        return this.factories.has(this.getTokenKey(key));\r\n    }\r\n\r\n    /**\r\n     * Retrieves an instance from the container based on the provided token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    get<T>(token: Token<T>, alias?: string, ...providers: ParamProviders[]): T {\r\n        return this.resolve(alias ? this.getTokenKey<T>(token, alias) : token, ...providers);\r\n    }\r\n\r\n    /**\r\n     * resolve type instance with token and param provider.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} [notFoundValue]\r\n     * @param {...ParamProviders[]} providers\r\n     * @memberof Container\r\n     */\r\n    resolve<T>(token: Token<T>, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T {\r\n        return this.getResolvers().resolve(token, resway, ...providers);\r\n    }\r\n\r\n    /**\r\n     * resolve first token when not null.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>[]} tokens\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    resolveFirst<T>(tokens: Token<T>[], ...providers: ParamProviders[]): T {\r\n        let inst: T;\r\n        tokens.some(tk => {\r\n            inst = this.resolve(tk, ...providers);\r\n            return inst !== null;\r\n        })\r\n        return inst;\r\n    }\r\n\r\n    /**\r\n     * resolve token value in this container only.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    resolveValue<T>(token: Token<T>, ...providers: ParamProviders[]): T {\r\n        let key = this.getTokenKey<T>(token);\r\n        if (!this.hasRegister(key)) {\r\n            return null;\r\n        }\r\n        let factory = this.factories.get(key);\r\n        return factory(...providers) as T;\r\n    }\r\n\r\n    /**\r\n     * get service or target reference service.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | Token<any>[])} token servive token.\r\n     * @param {(RefTarget | RefTarget[])} [target] service refrence target.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    getService<T>(token: Token<T> | Token<any>[], target?: RefTarget | RefTarget[] | ParamProviders, toRefToken?: boolean | Token<T> | RefTokenFac<T> | ParamProviders, defaultToken?: boolean | Token<T> | ParamProviders, ...providers: ParamProviders[]): T {\r\n        if (isArray(target) || isToken(target) || isRefTarget(target) || isTypeObject(target)) {\r\n            let tokens: Token<any>[] = [];\r\n            (isArray(token) ? token : [token]).forEach(tk => {\r\n                tokens.push(tk);\r\n                if (!isClass(tk)) {\r\n                    tokens.push(this.getTokenImpl(tk));\r\n                }\r\n            });\r\n\r\n            let fac: RefTokenFac<T>;\r\n            let defToken: Token<T> | Token<any>[];\r\n            let prds: ParamProviders[] = [];\r\n            if (isBoolean(toRefToken)) {\r\n                if (toRefToken) {\r\n                    defToken = token;\r\n                } else {\r\n                    defToken = null;\r\n                }\r\n            } else if (isToken(toRefToken)) {\r\n                defToken = toRefToken;\r\n            } else if (isFunction(toRefToken)) {\r\n                fac = toRefToken;\r\n                if (isBoolean(defaultToken)) {\r\n                    if (defaultToken) {\r\n                        defToken = token;\r\n                    } else {\r\n                        defToken = null;\r\n                    }\r\n                } else if (isToken(defaultToken)) {\r\n                    defToken = defaultToken;\r\n                } else if (defaultToken) {\r\n                    prds.push(defaultToken);\r\n                }\r\n            } else if (toRefToken) {\r\n                prds.unshift(toRefToken);\r\n            }\r\n\r\n\r\n            defToken = defToken === null ? null : (defToken || token);\r\n            prds = prds.concat(providers);\r\n            return this.getRefService(\r\n                [\r\n                    ...tokens.map(tk => { return { service: tk, isPrivate: true } }),\r\n                    ...fac ? [tk => fac(tk)] : [],\r\n                    ...tokens.map(t => (tk) => new InjectReference(t, tk))\r\n                ],\r\n                target as RefTarget | RefTarget[],\r\n                defToken,\r\n                ...prds);\r\n        } else {\r\n            return this.resolveFirst(isArray(token) ? token : [token], ...[target, toRefToken as ParamProviders, defaultToken as ParamProviders, ...providers].filter(a => a));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get target reference service.\r\n     *\r\n     * @template T\r\n     * @param {Type<Registration<T>>} [refToken] reference service Registration Injector\r\n     * @param {RefTarget | RefTarget[]} target  the service reference to.\r\n     * @param {Token<T>} [defaultToken] default service token.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    getRefService<T>(refToken: ReferenceToken<T>, target: RefTarget | RefTarget[], defaultToken?: Token<T> | Token<any>[], ...providers: ParamProviders[]): T {\r\n        let service: T = null;\r\n        (isArray(target) ? target : [target])\r\n            .some(tag => {\r\n                this.forInRefTarget(tag, tk => {\r\n                    // exclude ref registration.\r\n                    if (isInjectReference(tk)) {\r\n                        return true;\r\n                    }\r\n                    return !(isArray(refToken) ? refToken : [refToken]).some(stk => {\r\n                        let tokens = this.getRefToken(stk, tk);\r\n                        return (isArray(tokens) ? tokens : [tokens]).some(rtk => {\r\n                            service = this.resolveRef(rtk, tk, ...providers);\r\n                            return service !== null;\r\n                        });\r\n                    });\r\n                });\r\n                return service !== null;\r\n            });\r\n\r\n        if (!service && defaultToken) {\r\n            service = this.resolveFirst(isArray(defaultToken) ? defaultToken : [defaultToken], ...providers);\r\n        }\r\n        return service;\r\n    }\r\n\r\n    /**\r\n     * get all service extends type and reference target.\r\n     *\r\n     * @template T\r\n     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n     * @param {(Token<any> | Token<any>[])} [target] service refrence target.\r\n     * @param {(boolean|ParamProviders)} [both]\r\n     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    getServices<T>(token: Token<T> | ((token: ClassType<T>) => boolean), target?: ResoveWay | Token<any> | Token<any>[] | ParamProviders, both?: boolean | ResoveWay | ParamProviders, resway?: ResoveWay | ParamProviders, ...providers: ParamProviders[]): T[] {\r\n        let services: T[] = [];\r\n        this.iteratorServices((tk, fac, resolver, ...pds) => {\r\n            services.push(fac(...pds));\r\n        }, token, target, both, resway, ...providers);\r\n        return services;\r\n    }\r\n\r\n    /**\r\n     * get all service extends type and reference target.\r\n     *\r\n     * @template T\r\n     * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express\r\n     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.\r\n     * @param {(Token<any> | Token<any>[])} [target] service refrence target.\r\n     * @param {(boolean|ParamProviders)} [both]\r\n     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    iteratorServices<T>(\r\n        express: (tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean,\r\n        token: Token<T> | ((token: ClassType<T>) => boolean),\r\n        target?: ResoveWay | Token<any> | Token<any>[] | ParamProviders,\r\n        both?: boolean | ResoveWay | ParamProviders,\r\n        resway?: ResoveWay | ParamProviders,\r\n        ...providers: ParamProviders[]): void {\r\n\r\n        let withTag: boolean;\r\n        let rway = ResoveWay.all;\r\n        let withBoth = false;\r\n        let matchExp: (token: ClassType<T>) => boolean;\r\n        if (isToken(token)) {\r\n            let type = isClassType(token) ? token : this.getTokenImpl(token);\r\n            matchExp = (tk) => lang.isExtendsClass(tk, type);\r\n        } else if (isFunction(token)) {\r\n            matchExp = token;\r\n        }\r\n\r\n        if (isNumber(resway)) {\r\n            rway = resway;\r\n        } else {\r\n            providers.unshift(resway);\r\n        }\r\n        if (isToken(target) || isArray(target)) {\r\n            withTag = true;\r\n            if (isBoolean(both)) {\r\n                withBoth = both;\r\n            } else if (isNumber(both)) {\r\n                rway = both;\r\n            } else {\r\n                providers.unshift(both);\r\n            }\r\n            let tags: ClassType<any>[] = (isArray(target) ? target : [target]).map(t => {\r\n                if (isClass(t)) {\r\n                    return t;\r\n                } else if (isAbstractClass(t)) {\r\n                    return t;\r\n                } else {\r\n                    return this.getTokenImpl(t);\r\n                }\r\n            });\r\n            // target private service.\r\n            this.getResolvers().toArray().some(resolver => {\r\n                return tags.some(tg => {\r\n                    let priMapTk = new InjectReference(ProviderMap, tg);\r\n                    if (resolver.has(priMapTk, ResoveWay.nodes)) {\r\n                        let priMap = resolver.resolve(priMapTk, ResoveWay.nodes);\r\n                        return priMap.keys().some(ptk => {\r\n                            if (isClassType(ptk) && matchExp(ptk)) {\r\n                                return express(ptk, priMap.get(ptk), priMap, ...providers) !== false;\r\n                            }\r\n                            return false;\r\n                        });\r\n                    }\r\n                    return false;\r\n                });\r\n            });\r\n        } else {\r\n            if (isNumber(target)) {\r\n                rway = target;\r\n            } else {\r\n                providers.unshift(target);\r\n            }\r\n            withTag = false;\r\n        }\r\n        if (!withTag || (withTag && withBoth)) {\r\n            this.iterator((tk, fac, resolver) => {\r\n                if (isClassType(tk) && matchExp(tk)) {\r\n                    return express(tk, fac, resolver, ...providers);\r\n                }\r\n            }, rway);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * iterator all registered factory\r\n     *\r\n     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean} callbackfn\r\n     * @param {ResoveWay} [resway= ResoveWay.all]\r\n     * @memberof Container\r\n     */\r\n    iterator(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean, resway = ResoveWay.all): void {\r\n        this.getResolvers().iterator(callbackfn, resway);\r\n    }\r\n\r\n    /**\r\n     * iterator.\r\n     *\r\n     * @param {(tk: Token<any>, fac: InstanceFactory<any>) => void | boolean} callbackfn\r\n     * @memberof IExports\r\n     */\r\n    forEach(callbackfn: (tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean): void | boolean {\r\n        return !Array.from(this.factories.keys()).some(tk => {\r\n            return callbackfn(tk, this.factories.get(tk), this) === false;\r\n        });\r\n    }\r\n\r\n    protected getRefToken<T>(ref: RefTokenFacType<T>, tk: Token<any>): RefTokenType<T> | RefTokenType<T>[] {\r\n        if (isRegistrationClass(ref)) {\r\n            return new ref(tk);\r\n        }\r\n        if (isToken(ref)) {\r\n            return ref;\r\n        }\r\n        if (isFunction(ref)) {\r\n            return ref(tk);\r\n        }\r\n        return ref;\r\n    }\r\n\r\n    protected resolveRef<T>(refToken: RefTokenType<T>, target: Token<any>, ...providers: ParamProviders[]): T {\r\n        let tk: Token<T>;\r\n        let isPrivate = false;\r\n        if (isToken(refToken)) {\r\n            tk = refToken;\r\n        } else {\r\n            tk = refToken.service;\r\n            isPrivate = refToken.isPrivate !== false;\r\n        }\r\n\r\n        if (!tk) {\r\n            return null;\r\n        }\r\n        // resolve private first.\r\n        if (isClass(target) && !isInjectReference(tk)) {\r\n            let pdrmap = this.resolve(new InjectReference(ProviderMap, target));\r\n            if (pdrmap && pdrmap.has(tk)) {\r\n                return pdrmap.resolve(tk, ...providers);\r\n            }\r\n        }\r\n        // have not private registered.\r\n        if (isPrivate) {\r\n            return null;\r\n        }\r\n        return this.resolve(tk, ...providers);\r\n    }\r\n\r\n    /**\r\n     * get tocken key.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {SymbolType<T>}\r\n     * @memberof Container\r\n     */\r\n    getTokenKey<T>(token: Token<T>, alias?: string): SymbolType<T> {\r\n        if (alias) {\r\n            return new Registration(token, alias).toString();\r\n        } else if (token instanceof Registration) {\r\n            return token.toString();\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * register type.\r\n     * @abstract\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} [value]\r\n     * @returns {this}\r\n     * @memberOf Container\r\n     */\r\n    register<T>(token: Token<T>, value?: Factory<T>): this {\r\n        this.registerFactory(token, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * register stingleton type.\r\n     * @abstract\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {Factory<T>} [value]\r\n     * @returns {this}\r\n     * @memberOf Container\r\n     */\r\n    registerSingleton<T>(token: Token<T>, value?: Factory<T>): this {\r\n        this.registerFactory(token, value, true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * register value.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} value\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    registerValue<T>(token: Token<T>, value: T): this {\r\n        let key = this.getTokenKey(token);\r\n        this.getSingleton().set(key, value);\r\n        if (!this.factories.has(key)) {\r\n            this.factories.set(key, () => {\r\n                return this.getSingleton().get(key);\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * bind provider.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} provide\r\n     * @param {Token<T>} provider\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    bindProvider<T>(provide: Token<T>, provider: Token<T> | Factory<T>): this {\r\n        let provideKey = this.getTokenKey(provide);\r\n        let factory;\r\n        if (isToken(provider)) {\r\n            factory = (...providers: ParamProviders[]) => {\r\n                return this.resolve(provider, ...providers);\r\n            };\r\n        } else {\r\n            if (isFunction(provider)) {\r\n                factory = (...providers: ParamProviders[]) => {\r\n                    return (<ToInstance<any>>provider)(this, ...providers);\r\n                };\r\n            } else {\r\n                factory = () => {\r\n                    return provider\r\n                };\r\n            }\r\n        }\r\n        if (isClass(provider)) {\r\n            if (!this.has(provider)) {\r\n                this.register(provider);\r\n            }\r\n            this.provideTypes.set(provideKey, provider);\r\n        } else if (isToken(provider)) {\r\n            let token = provider;\r\n            while (this.provideTypes.has(token) && !isClass(token)) {\r\n                token = this.provideTypes.get(token);\r\n                if (isClass(token)) {\r\n                    this.provideTypes.set(provideKey, token);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.factories.set(provideKey, factory);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * bind providers for only target class.\r\n     *\r\n     * @param {Token<any>} target\r\n     * @param {ParamProviders[]} providers\r\n     * @param {(mapTokenKey: Token<any>) => void} [onceBinded]\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    bindProviders(target?: Token<any> | ProviderTypes, onceBinded?: ProviderTypes | ((mapTokenKey: Token<any>) => void), ...providers: ProviderTypes[]): this {\r\n        let tgt: Token<any>;\r\n        let complete: (mapTokenKey: Token<any>) => void;\r\n        let prods: ProviderTypes[] = providers;\r\n\r\n        if (isFunction(onceBinded)) {\r\n            complete = onceBinded as (mapTokenKey: Token<any>) => void;\r\n        } else if (onceBinded) {\r\n            prods.unshift(onceBinded);\r\n        }\r\n\r\n        if (isToken(target)) {\r\n            tgt = target;\r\n        } else if (target) {\r\n            tgt = null;\r\n            prods.unshift(target);\r\n        }\r\n\r\n        let maps = this.getProviderParser().parse(...prods);\r\n        if (tgt) {\r\n            let refKey = new InjectReference(ProviderMap, isClass(tgt) ? tgt : this.getTokenImpl(tgt));\r\n            if (this.hasRegister(refKey)) {\r\n                this.resolveValue(refKey).copy(maps);\r\n            } else {\r\n                this.bindProvider(refKey, maps);\r\n                complete && complete(refKey);\r\n            }\r\n        } else {\r\n            maps.keys().forEach(key => {\r\n                isToken(key) && this.factories.set(key, (...prds) => maps.resolve(key, ...prds));\r\n            })\r\n\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * bind provider ref to target.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>} target\r\n     * @param {Token<T>} provide\r\n     * @param {(Token<T> | Factory<T>)} provider\r\n     * @param {string} [alias]\r\n     * @param {(refToken: Token<T>) => void} [onceBinded]\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    bindRefProvider<T>(target: Token<any>, provide: Token<T>, provider: Token<T> | Factory<T>, alias?: string, onceBinded?: (refToken: Token<T>) => void): this {\r\n        let refToken = new InjectReference(this.getTokenKey(provide, alias), target);\r\n        this.bindProvider(refToken, provider);\r\n        onceBinded && onceBinded(refToken);\r\n        return this;\r\n    }\r\n\r\n    unregisterValue<T>(token: Token<T>): this {\r\n        let key = this.getTokenKey(token);\r\n        if (this.hasRegister(key)) {\r\n            this.factories.delete(key);\r\n            if (this.provideTypes.has(key)) {\r\n                this.provideTypes.delete(key);\r\n            }\r\n            if (isClass(key)) {\r\n                this.clearCache(key);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * unregister the token\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {ResoveWay} [resway]\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    unregister<T>(token: Token<T>, resway?: ResoveWay): this {\r\n        this.getResolvers().unregister(token, resway);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * clear cache.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @memberof IContainer\r\n     */\r\n    clearCache(targetType: Type<any>) {\r\n        this.resolveValue(CacheManagerToken).destroy(targetType);\r\n    }\r\n\r\n    /**\r\n     * get token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {Token<T>}\r\n     * @memberof Container\r\n     */\r\n    getToken<T>(token: Token<T>, alias?: string): Token<T> {\r\n        if (alias) {\r\n            return new Registration(token, alias);\r\n        }\r\n        return token;\r\n    }\r\n\r\n    getTokenProvider<T>(token: Token<T>): Type<T> {\r\n        if (isClass(token)) {\r\n            return token;\r\n        }\r\n        let tokenKey = this.getTokenKey(token);\r\n        if (this.provideTypes.has(tokenKey)) {\r\n            return this.provideTypes.get(tokenKey);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * get token implements class type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {boolean} [inchain]\r\n     * @returns {Type<T>}\r\n     * @memberof Container\r\n     */\r\n    getTokenImpl<T>(token: Token<T>, resway?: ResoveWay): Type<T> {\r\n        return this.getResolvers().getTokenImpl(token, resway);\r\n    }\r\n\r\n    /**\r\n     * iterate token  in  token class chain.  return false will break iterate.\r\n     *\r\n     * @param {RefTarget} target\r\n     * @param {(token: Token<any>) => boolean} express\r\n     * @memberof Container\r\n     */\r\n    forInRefTarget(target: RefTarget, express: (token: Token<any>) => boolean): void {\r\n        let type: ClassType<any>;\r\n        let token: Token<any>;\r\n        let level: RefTagLevel;\r\n        if (isToken(target)) {\r\n            token = target;\r\n            level = RefTagLevel.all;\r\n        } else if (target) {\r\n            if (isRefTarget(target)) {\r\n                token = target.target;\r\n                level = target.level || RefTagLevel.self;\r\n            } else if (isTypeObject(target)) {\r\n                token = lang.getClass(target);\r\n                level = RefTagLevel.all;\r\n            }\r\n        }\r\n\r\n        if (!isToken(token)) {\r\n            return;\r\n        }\r\n\r\n        if (isClassType(token)) {\r\n            type = token;\r\n            if (isClass(type) && !this.has(type)) {\r\n                this.use(type);\r\n            }\r\n        } else {\r\n            type = this.getTokenImpl(token);\r\n        }\r\n        if (!isClassType(token) || (RefTagLevel.self === level)) {\r\n            express(token);\r\n            return;\r\n        }\r\n\r\n        let inChain = (level & RefTagLevel.chain) > 0;\r\n        let inProviders = (level & RefTagLevel.providers) > 0;\r\n        lang.forInClassChain(type, ty => {\r\n            let tokens: Token<any>[];\r\n            if (inProviders) {\r\n                let prdKey = new InjectClassProvidesToken(ty);\r\n                let prds = this.get(prdKey);\r\n                if (prds && prds.provides && prds.provides.length) {\r\n                    let ppdkey = prdKey.toString();\r\n                    let pmapKey = new InjectReference(ProviderMap, ty).toString();\r\n                    tokens = prds.provides.slice(1).filter(p => {\r\n                        let key = this.getTokenKey(p);\r\n                        return key !== ppdkey && key !== pmapKey\r\n                    });\r\n                }\r\n            }\r\n            tokens = tokens || [];\r\n            return !(tokens.concat(ty).some(tk => express(tk) === false)) && inChain;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * get token implement class and base classes.\r\n     *\r\n     * @param {Token<any>} token\r\n     * @returns {Token<any>[]}\r\n     * @memberof Container\r\n     */\r\n    getTokenClassChain(token: Token<any>, chain = true): Token<any>[] {\r\n        let tokens: Token<any>[] = [];\r\n        this.forInRefTarget(token, tk => {\r\n            tokens.push(tk);\r\n            return chain;\r\n        });\r\n        return tokens;\r\n    }\r\n\r\n    /**\r\n    * get life scope of container.\r\n    *\r\n    * @returns {LifeScope}\r\n    * @memberof IContainer\r\n    */\r\n    getLifeScope(): LifeScope {\r\n        return this.get(LifeScopeToken);\r\n    }\r\n\r\n    /**\r\n     * use modules.\r\n     *\r\n     * @param {...Modules[]} modules\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    use(...modules: Modules[]): this {\r\n        this.getBuilder().syncLoadModule(this, ...modules);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * async use modules.\r\n     *\r\n     * @param {...LoadType[]} modules load modules.\r\n     * @returns {Promise<Type<any>[]>}  types loaded.\r\n     * @memberof IContainer\r\n     */\r\n    loadModule(...modules: LoadType[]): Promise<Type<any>[]> {\r\n        return this.getBuilder().loadModule(this, ...modules);\r\n    }\r\n\r\n    /**\r\n     * invoke method async.\r\n     *\r\n     * @template T\r\n     * @param {any} target\r\n     * @param {string} propertyKey\r\n     * @param {*} [instance]\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {Promise<T>}\r\n     * @memberof Container\r\n     */\r\n    invoke<T>(target: any, propertyKey: string, instance?: any, ...providers: ParamProviders[]): Promise<T> {\r\n        return this.resolveValue(MethodAccessorToken).invoke(target, propertyKey, instance, ...providers);\r\n    }\r\n\r\n    /**\r\n     * invoke method.\r\n     *\r\n     * @template T\r\n     * @param {any} target\r\n     * @param {string} propertyKey\r\n     * @param {*} [instance]\r\n     * @param {...ParamProviders[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    syncInvoke<T>(target: Token<any>, propertyKey: string, instance?: any, ...providers: ParamProviders[]): T {\r\n        return this.resolveValue(MethodAccessorToken).syncInvoke(target, propertyKey, instance, ...providers);\r\n    }\r\n\r\n    createSyncParams(params: IParameter[], ...providers: ParamProviders[]): any[] {\r\n        return this.resolveValue(MethodAccessorToken).createSyncParams(params, ...providers);\r\n    }\r\n\r\n    createParams(params: IParameter[], ...providers: ParamProviders[]): Promise<any[]> {\r\n        return this.resolveValue(MethodAccessorToken).createParams(params, ...providers);\r\n    }\r\n\r\n    protected cacheDecorator<T>(map: Map<string, ActionComponent>, action: ActionComponent) {\r\n        if (!map.has(action.name)) {\r\n            map.set(action.name, action);\r\n        }\r\n    }\r\n\r\n    protected init() {\r\n        this.factories = new Map();\r\n        this.provideTypes = new Map();\r\n        this.bindProvider(ContainerToken, () => this);\r\n        registerCores(this);\r\n    }\r\n\r\n    protected getSingleton(): Map<Token<any>, any> {\r\n        if (!this.hasRegister(SingletonRegToken)) {\r\n            this.bindProvider(SingletonRegToken, new Map<Token<any>, any>());\r\n        }\r\n        return this.resolveValue(SingletonRegToken);\r\n    }\r\n\r\n    protected registerFactory<T>(token: Token<T>, value?: Factory<T>, singleton?: boolean) {\r\n        let key = this.getTokenKey(token);\r\n\r\n        if (this.factories.has(key)) {\r\n            return;\r\n        }\r\n\r\n        let classFactory;\r\n        if (!isUndefined(value)) {\r\n            if (isFunction(value)) {\r\n                if (isClass(value)) {\r\n                    this.bindTypeFactory(key, value as Type<T>, singleton);\r\n                } else {\r\n                    classFactory = this.createCustomFactory(key, value as ToInstance<T>, singleton);\r\n                }\r\n            } else if (singleton && value !== undefined) {\r\n                classFactory = this.createCustomFactory(key, () => value, singleton);\r\n            }\r\n\r\n        } else if (!isString(token) && !isSymbol(token)) {\r\n            let ClassT = (token instanceof Registration) ? token.getClass() : token;\r\n            if (isClass(ClassT)) {\r\n                this.bindTypeFactory(key, ClassT as Type<T>, singleton);\r\n            }\r\n        }\r\n\r\n        if (classFactory) {\r\n            this.factories.set(key, classFactory);\r\n        }\r\n    }\r\n\r\n    protected createCustomFactory<T>(key: SymbolType<T>, factory?: ToInstance<T>, singleton?: boolean) {\r\n        return singleton ?\r\n            (...providers: ParamProviders[]) => {\r\n                if (this.getSingleton().has(key)) {\r\n                    return this.getSingleton().get(key);\r\n                }\r\n                let instance = factory(this, ...providers);\r\n                this.getSingleton().set(key, instance);\r\n                return instance;\r\n            }\r\n            : (...providers: ParamProviders[]) => factory(this, ...providers);\r\n    }\r\n\r\n    protected bindTypeFactory<T>(key: SymbolType<T>, ClassT?: Type<T>, singleton?: boolean) {\r\n        if (!Reflect.isExtensible(ClassT)) {\r\n            return;\r\n        }\r\n\r\n        let lifeScope = this.getLifeScope();\r\n        let parameters = lifeScope.getConstructorParameters(ClassT);\r\n        if (!singleton) {\r\n            singleton = lifeScope.isSingletonType<T>(ClassT);\r\n        }\r\n\r\n        let factory = (...providers: ParamProviders[]) => {\r\n            if (singleton && this.getSingleton().has(key)) {\r\n                return this.getSingleton().get(key);\r\n            }\r\n\r\n            if (providers.length < 1) {\r\n                let lifecycleData: CacheActionData = {\r\n                    tokenKey: key,\r\n                    targetType: ClassT,\r\n                    // raiseContainer: this,\r\n                    singleton: singleton\r\n                };\r\n                lifeScope.execute(lifecycleData, CoreActions.cache);\r\n                if (lifecycleData.execResult && lifecycleData.execResult instanceof ClassT) {\r\n                    return lifecycleData.execResult;\r\n                }\r\n            }\r\n\r\n            let providerMap = this.getProviderParser().parse(...providers);\r\n\r\n            lifeScope.execute({\r\n                tokenKey: key,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.beforeCreateArgs);\r\n\r\n            let args = this.createSyncParams(parameters, providerMap);\r\n\r\n            lifeScope.routeExecute({\r\n                tokenKey: key,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.beforeConstructor);\r\n\r\n            let instance = new ClassT(...args);\r\n\r\n            lifeScope.routeExecute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.afterConstructor);\r\n\r\n            lifeScope.execute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.onInit);\r\n\r\n\r\n            lifeScope.routeExecute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.AfterInit);\r\n\r\n            lifeScope.execute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this\r\n            }, CoreActions.cache);\r\n\r\n            return instance;\r\n        };\r\n\r\n        this.factories.set(key, factory);\r\n\r\n        lifeScope.routeExecute({\r\n            tokenKey: key,\r\n            targetType: ClassT,\r\n            raiseContainer: this\r\n        }, IocState.design);\r\n\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"Container\",\"params\":{\"constructor\":[],\"getRoot\":[],\"getProviderParser\":[],\"getBuilder\":[],\"getResolvers\":[],\"has\":[\"token\",\"aliasOrway\"],\"hasRegister\":[\"key\"],\"get\":[\"token\",\"alias\",\"providers\"],\"resolve\":[\"token\",\"resway\",\"providers\"],\"resolveFirst\":[\"tokens\",\"providers\"],\"resolveValue\":[\"token\",\"providers\"],\"getService\":[\"token\",\"target\",\"toRefToken\",\"defaultToken\",\"providers\"],\"getRefService\":[\"refToken\",\"target\",\"defaultToken\",\"providers\"],\"getServices\":[\"token\",\"target\",\"both\",\"resway\",\"providers\"],\"iteratorServices\":[\"express\",\"token\",\"target\",\"both\",\"resway\",\"providers\"],\"iterator\":[\"callbackfn\",\"resway\"],\"forEach\":[\"callbackfn\"],\"getRefToken\":[\"ref\",\"tk\"],\"resolveRef\":[\"refToken\",\"target\",\"providers\"],\"getTokenKey\":[\"token\",\"alias\"],\"register\":[\"token\",\"value\"],\"registerSingleton\":[\"token\",\"value\"],\"registerValue\":[\"token\",\"value\"],\"bindProvider\":[\"provide\",\"provider\"],\"bindProviders\":[\"target\",\"onceBinded\",\"providers\"],\"bindRefProvider\":[\"target\",\"provide\",\"provider\",\"alias\",\"onceBinded\"],\"unregisterValue\":[\"token\"],\"unregister\":[\"token\",\"resway\"],\"clearCache\":[\"targetType\"],\"getToken\":[\"token\",\"alias\"],\"getTokenProvider\":[\"token\"],\"getTokenImpl\":[\"token\",\"resway\"],\"forInRefTarget\":[\"target\",\"express\"],\"getTokenClassChain\":[\"token\",\"chain\"],\"getLifeScope\":[],\"use\":[\"modules\"],\"loadModule\":[\"modules\"],\"invoke\":[\"target\",\"propertyKey\",\"instance\",\"providers\"],\"syncInvoke\":[\"target\",\"propertyKey\",\"instance\",\"providers\"],\"createSyncParams\":[\"params\",\"providers\"],\"createParams\":[\"params\",\"providers\"],\"cacheDecorator\":[\"map\",\"action\"],\"init\":[],\"getSingleton\":[],\"registerFactory\":[\"token\",\"value\",\"singleton\"],\"createCustomFactory\":[\"key\",\"factory\",\"singleton\"],\"bindTypeFactory\":[\"key\",\"ClassT\",\"singleton\"]}};\n                        }\n                   }\r\n","import { Type, Modules, LoadType } from '../types';\r\nimport { InjectToken } from '../InjectToken';\r\n\r\n/**\r\n * module loader token.\r\n */\r\nexport const ModuleLoaderToken = new InjectToken<IModuleLoader>('DI_ModuleLoader');\r\n\r\n\r\n/**\r\n * module loader interface for ioc.\r\n *\r\n * @export\r\n * @interface IModuleLoader\r\n */\r\nexport interface IModuleLoader {\r\n    /**\r\n     * load modules by files patterns, module name or modules.\r\n     *\r\n     * @param {LoadType[]} modules\r\n     * @returns {Promise<Modules[]>}\r\n     * @memberof IModuleLoader\r\n     */\r\n    load(modules: LoadType[]): Promise<Modules[]>;\r\n\r\n    /**\r\n     * load all class types in modules\r\n     *\r\n     * @param {LoadType[]} modules\r\n     * @returns {Promise<Type<any>[]>}\r\n     * @memberof IModuleLoader\r\n     */\r\n    loadTypes(modules: LoadType[]): Promise<Type<any>[][]>;\r\n\r\n    /**\r\n     * get all class type in modules.\r\n     *\r\n     * @param {Modules[]} modules\r\n     * @returns {Type<any>[]}\r\n     * @memberof IModuleLoader\r\n     */\r\n    getTypes(modules: Modules[]): Type<any>[][];\r\n\r\n}\r\n\r\n","import { Type, Modules, LoadType, PathModules } from '../types';\r\nimport { IModuleLoader } from './IModuleLoader';\r\nimport { isString, isClass, isObject, isArray } from '../utils';\r\n\r\ndeclare let require: any;\r\n\r\n/**\r\n * default module loader.\r\n *\r\n * @export\r\n * @class DefaultModuleLoader\r\n * @implements {IModuleLoader}\r\n */\r\nexport class DefaultModuleLoader implements IModuleLoader {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    private _loader: (modulepath: string) => Promise<Modules[]>;\r\n    getLoader() {\r\n        if (!this._loader) {\r\n            this._loader = this.createLoader();\r\n        }\r\n        return this._loader;\r\n    }\r\n\r\n    /**\r\n     * load module.\r\n     *\r\n     * @param {...LoadType[]} modules\r\n     * @returns {Promise<Modules[]>}\r\n     * @memberof DefaultModuleLoader\r\n     */\r\n    load(modules: LoadType[]): Promise<Modules[]> {\r\n        if (modules.length) {\r\n            return Promise.all(modules.map(mdty => {\r\n                if (isString(mdty)) {\r\n                    return this.isFile(mdty) ? this.loadFile(mdty) : this.loadModule(mdty);\r\n                } else if (isObject(mdty) && (mdty['modules'] || mdty['files'])) {\r\n                    return this.loadPathModule(mdty as PathModules);\r\n                } else {\r\n                    return mdty ? [mdty] : [];\r\n                }\r\n            }))\r\n                .then(allms => {\r\n                    let rmodules: Modules[] = [];\r\n                    allms.forEach(ms => {\r\n                        rmodules = rmodules.concat(ms);\r\n                    })\r\n                    return rmodules;\r\n                });\r\n        } else {\r\n            return Promise.resolve([]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load types from module.\r\n     *\r\n     * @param {...LoadType[]} modules\r\n     * @returns {Promise<Type<any>[]>}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    async loadTypes(modules: LoadType[]): Promise<Type<any>[][]> {\r\n        let mdls = await this.load(modules);\r\n        return this.getTypes(mdls);\r\n    }\r\n\r\n    /**\r\n     * get all class type in modules.\r\n     *\r\n     * @param {Modules[]} modules\r\n     * @param {...Express<Type<any>, boolean>[]} filters\r\n     * @returns {Type<any>[]}\r\n     * @memberof DefaultModuleLoader\r\n     */\r\n    getTypes(modules: Modules[]): Type<any>[][] {\r\n        let regModules: Type<any>[][] = [];\r\n\r\n        modules.forEach(m => {\r\n            let types = this.getContentTypes(m);\r\n            regModules.push(types);\r\n        });\r\n\r\n        return regModules;\r\n    }\r\n\r\n    protected loadFile(files: string | string[], basePath?: string): Promise<Modules[]> {\r\n        let loader = this.getLoader();\r\n        let fRes: Promise<Modules[]>;\r\n        if (isArray(files)) {\r\n            fRes = Promise.all(files.map(f => loader(f)))\r\n                .then(allms => {\r\n                    let rms = [];\r\n                    allms.forEach(ms => {\r\n                        rms = rms.concat(ms);\r\n                    });\r\n                    return rms;\r\n                });\r\n        } else {\r\n            fRes = loader(files);\r\n        }\r\n        return fRes.then(ms => ms.filter(it => !!it));\r\n    }\r\n\r\n    protected isFile(str: string) {\r\n        return str && /\\/((\\w|%|\\.))+\\.\\w+$/.test(str.replace(/\\\\\\\\/gi, '/'));\r\n    }\r\n\r\n\r\n    protected loadModule(moduleName: string): Promise<Modules[]> {\r\n        let loader = this.getLoader();\r\n        return loader(moduleName).then(ms => ms.filter(it => !!it));\r\n    }\r\n\r\n    protected async loadPathModule(pmd: PathModules): Promise<Modules[]> {\r\n        let modules: Modules[] = [];\r\n        if (pmd.files) {\r\n            await this.loadFile(pmd.files, pmd.basePath)\r\n                .then(allmoduls => {\r\n                    allmoduls.forEach(ms => {\r\n                        modules = modules.concat(ms);\r\n                    });\r\n                    return modules;\r\n                })\r\n        }\r\n        if (pmd.modules) {\r\n            await Promise.all(pmd.modules.map(nmd => {\r\n                return isString(nmd) ? this.loadModule(nmd) : nmd;\r\n            })).then(ms => {\r\n                modules = modules.concat(ms);\r\n                return modules;\r\n            });\r\n        }\r\n\r\n        return modules;\r\n    }\r\n\r\n    protected createLoader(): (modulepath: string) => Promise<Modules[]> {\r\n        if (typeof require !== 'undefined') {\r\n            return (modulepath: string) => {\r\n                return new Promise<Modules[]>((resolve, reject) => {\r\n                    require(modulepath, (mud) => {\r\n                        resolve(mud);\r\n                    }, err => {\r\n                        reject(err);\r\n                    })\r\n                });\r\n            }\r\n        } else {\r\n            throw new Error('has not module loader');\r\n        }\r\n    }\r\n\r\n    protected getContentTypes(regModule: Modules): Type<any>[] {\r\n        let regModules: Type<any>[] = [];\r\n\r\n        if (isClass(regModule)) {\r\n            regModules.push(regModule);\r\n        } else if (regModule) {\r\n            let rmodules = regModule['exports'] ? regModule['exports'] : regModule;\r\n            for (let p in rmodules) {\r\n                let type = rmodules[p];\r\n                if (isClass(type)) {\r\n                    regModules.push(type);\r\n                }\r\n            }\r\n        }\r\n\r\n        return regModules;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"DefaultModuleLoader\",\"params\":{\"constructor\":[],\"getLoader\":[],\"load\":[\"modules\"],\"loadTypes\":[\"modules\"],\"getTypes\":[\"modules\"],\"loadFile\":[\"files\",\"basePath\"],\"isFile\":[\"str\"],\"loadModule\":[\"moduleName\"],\"loadPathModule\":[\"pmd\"],\"createLoader\":[],\"getContentTypes\":[\"regModule\"]}};\n                        }\n                   }\r\n","import { Type } from '../types';\r\nimport { RefRegistration } from '../InjectReference';\r\n\r\n/**\r\n * module validate.\r\n *\r\n * @export\r\n * @interface IModuleValidate\r\n */\r\nexport interface IModuleValidate {\r\n    /**\r\n     * is right module or not.\r\n     *\r\n     * @param {Type<any>} type\r\n     * @returns {boolean}\r\n     * @memberof IModuleValidate\r\n     */\r\n    valid(type: Type<any>): boolean;\r\n\r\n    /**\r\n     * get special decorators of the module.\r\n     *\r\n     * @returns {string}\r\n     * @memberof IModuleValidate\r\n     */\r\n    getDecorator(): string | string[];\r\n}\r\n\r\n\r\n/**\r\n * inject module validate token for decorator or class.\r\n *\r\n * @export\r\n * @class InjectMetadataManagerToken\r\n * @extends {RefRegistration<IMetadataManager>}\r\n * @template T\r\n */\r\nexport class InjectModuleValidateToken<T extends IModuleValidate> extends RefRegistration<T> {\r\n    constructor(decorator: string) {\r\n        super(decorator, 'ModuleValidate');\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"InjectModuleValidateToken\",\"params\":{\"constructor\":[\"decorator\"]}};\n                        }\n                   }\r\n\r\n/**\r\n * Module Validate Token\r\n */\r\nexport const ModuleValidateToken = new InjectModuleValidateToken<IModuleValidate>('');\r\n","import { IModuleValidate, InjectModuleValidateToken } from './IModuleValidate';\r\nimport { Type } from '../types';\r\nimport { isClass, isString, isArray } from '../utils';\r\nimport { hasOwnClassMetadata, IocExt } from '../core';\r\n\r\n/**\r\n * base module validate.\r\n *\r\n * @export\r\n * @abstract\r\n * @class BaseModuelValidate\r\n * @implements {IModuleValidate}\r\n */\r\nexport class ModuelValidate implements IModuleValidate {\r\n    constructor() {\r\n\r\n    }\r\n\r\n    valid(type: Type<any>): boolean {\r\n        if (!isClass(type)) {\r\n            return false;\r\n        }\r\n\r\n        let decorator = this.getDecorator();\r\n        if (isString(decorator)) {\r\n            return hasOwnClassMetadata(decorator, type);\r\n        } else if (isArray(decorator)) {\r\n            return decorator.some(d => hasOwnClassMetadata(d, type));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    getDecorator(): string | string[] {\r\n        return null;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ModuelValidate\",\"params\":{\"constructor\":[],\"valid\":[\"type\"],\"getDecorator\":[]}};\n                        }\n                   }\r\n\r\n/**\r\n * IocExt module validate token.\r\n */\r\nexport const IocExtModuleValidateToken = new InjectModuleValidateToken(IocExt.toString());\r\n/**\r\n * IocExt module validate.\r\n *\r\n * @export\r\n * @class IocExtModuleValidate\r\n * @extends {ModuelValidate}\r\n * @implements {IModuleValidate}\r\n */\r\nexport class IocExtModuleValidate extends ModuelValidate implements IModuleValidate {\r\n    getDecorator(): string | string[] {\r\n        return IocExt.toString();\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"IocExtModuleValidate\",\"params\":{\"getDecorator\":[]}};\n                        }\n                   }\r\n","import { Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { Registration } from '../Registration';\r\n\r\n/**\r\n *  InjectorResult\r\n *\r\n * @export\r\n * @interface InjectorResult\r\n */\r\nexport interface InjectorResult {\r\n    injected: Type<any>[];\r\n    next?: Type<any>[];\r\n}\r\n\r\n/**\r\n * module injector.\r\n *\r\n * @export\r\n * @interface IModuleInjector\r\n */\r\nexport interface IModuleInjector {\r\n    /**\r\n     * inject module to container.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {Type<any>[]} modules\r\n     * @returns {Type<any>[]}\r\n     * @memberof IModuleInjector\r\n     */\r\n    inject(container: IContainer, modules: Type<any>[]): Promise<InjectorResult>;\r\n\r\n    /**\r\n     * sync inject module.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {Type<any>[]} modules\r\n     * @returns {InjectorResult}\r\n     * @memberof IModuleInjector\r\n     */\r\n    syncInject(container: IContainer, modules: Type<any>[]): InjectorResult;\r\n}\r\n\r\n/**\r\n *  inject module injector token.\r\n */\r\nexport class InjectModuleInjectorToken<T extends IModuleInjector> extends Registration<T> {\r\n    constructor(desc: string) {\r\n        super('DI_ModuleInjector', desc)\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"InjectModuleInjectorToken\",\"params\":{\"constructor\":[\"desc\"]}};\n                        }\n                   }\r\n\r\n/**\r\n * async module injector token.\r\n */\r\nexport const ModuleInjectorToken = new InjectModuleInjectorToken<IModuleInjector>('');\r\n","import { IModuleInjector, ModuleInjectorToken, InjectorResult } from './IModuleInjector';\r\nimport { Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { PromiseUtil } from '../utils';\r\nimport { IModuleValidate, ModuleValidateToken } from './IModuleValidate';\r\nimport { Injectable, Inject } from '../core';\r\n\r\n\r\n/**\r\n * base module injector. abstract class.\r\n *\r\n * @export\r\n * @abstract\r\n * @class BaseModuleInjector\r\n * @implements {IModuleInjector}\r\n */\r\n@Injectable(ModuleInjectorToken)\r\nexport class ModuleInjector implements IModuleInjector {\r\n\r\n    /**\r\n     *Creates an instance of BaseModuleInjector.\r\n     * @param {IModuleValidate} [validate]\r\n     * @param {boolean} [skipNext] skip next when has match module to injector.\r\n     * @memberof BaseModuleInjector\r\n     */\r\n    constructor(@Inject(ModuleValidateToken) protected validate?: IModuleValidate, protected skipNext?: boolean) {\r\n    }\r\n\r\n    async inject(container: IContainer, modules: Type<any>[]): Promise<InjectorResult> {\r\n        let types = (modules || []).filter(ty => this.valid(container, ty));\r\n        if (types.length) {\r\n            await PromiseUtil.step(types.map(ty => () => this.setup(container, ty)));\r\n        }\r\n        let next = this.getNext(modules, types);\r\n        return { injected: types, next: next };\r\n    }\r\n\r\n    syncInject(container: IContainer, modules: Type<any>[]): InjectorResult {\r\n        let types = (modules || []).filter(ty => this.valid(container, ty));\r\n        if (types.length) {\r\n            types.forEach(ty => {\r\n                this.syncSetup(container, ty);\r\n            });\r\n        }\r\n        let next = this.getNext(modules, types);\r\n        return { injected: types, next: next };\r\n    }\r\n\r\n    protected valid(container: IContainer, type: Type<any>): boolean {\r\n        if (!this.validate) {\r\n            return true;\r\n        }\r\n        return this.validate.valid(type);\r\n    }\r\n\r\n    protected getNext(all: Type<any>[], filtered: Type<any>[]): Type<any>[] {\r\n        if (filtered.length === 0) {\r\n            return all;\r\n        }\r\n        if (this.skipNext) {\r\n            return null;\r\n        }\r\n        if (filtered.length === all.length) {\r\n            return null;\r\n        }\r\n        return all.filter(it => filtered.indexOf(it) < 0);\r\n    }\r\n\r\n    protected async setup(container: IContainer, type: Type<any>) {\r\n        container.register(type);\r\n    }\r\n    protected syncSetup(container: IContainer, type: Type<any>) {\r\n        container.register(type);\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ModuleInjector\",\"params\":{\"constructor\":[\"validate\",\"skipNext\"],\"inject\":[\"container\",\"modules\"],\"syncInject\":[\"container\",\"modules\"],\"valid\":[\"container\",\"type\"],\"getNext\":[\"all\",\"filtered\"],\"setup\":[\"container\",\"type\"],\"syncSetup\":[\"container\",\"type\"]}};\n                        }\n                   }\r\n","import { InjectToken } from '../InjectToken';\r\nimport { IContainer } from '../IContainer';\r\nimport { Type } from '../types';\r\nimport { IModuleInjector } from './IModuleInjector';\r\n\r\n/**\r\n * module Injector chian interface.\r\n *\r\n * @export\r\n * @interface IModuleInjectorChain\r\n */\r\nexport interface IModuleInjectorChain {\r\n    /**\r\n     * injector chain.\r\n     *\r\n     * @type {IModuleInjector[]}\r\n     * @memberof IModuleInjectorChain\r\n     */\r\n    readonly injectors: IModuleInjector[];\r\n\r\n    /**\r\n     * set first step.\r\n     *\r\n     * @param {IModuleInjector} injector\r\n     * @memberof IModuleInjectorChain\r\n     */\r\n    first(injector: IModuleInjector): this;\r\n\r\n    /**\r\n     * set next step.\r\n     *\r\n     * @param {IModuleInjector} injector\r\n     * @memberof IModuleInjectorChain\r\n     */\r\n    next(injector: IModuleInjector): this;\r\n\r\n    /**\r\n     * inject module via injector chain.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {Type<any>[]} modules\r\n     * @returns {Promise(Type<any>[]>}\r\n     * @memberof IModuleInjectorChain\r\n     */\r\n    inject(container: IContainer, modules: Type<any>[]): Promise<Type<any>[]>;\r\n\r\n    /**\r\n     * sync inject module.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {Type<any>[]} modules\r\n     * @returns {Type<any>[]}\r\n     * @memberof IModuleInjectorChain\r\n     */\r\n    syncInject(container: IContainer, modules: Type<any>[]): Type<any>[];\r\n}\r\n\r\n\r\n/**\r\n * module fileter token. mast use as singlton.\r\n */\r\nexport const ModuleInjectorChainToken = new InjectToken<IModuleInjectorChain>('DI_ModuleInjectorChain');\r\n","import { IModuleInjectorChain } from './IModuleInjectorChain';\r\nimport { IModuleInjector } from './IModuleInjector';\r\nimport { ModuleInjector } from './ModuleInjector';\r\nimport { Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { PromiseUtil } from '../utils';\r\n\r\n/**\r\n * Module Injector chain, base injector chain.\r\n *\r\n * @export\r\n * @class ModuleInjectorChain\r\n * @implements {IModuleInjectorChain}\r\n */\r\nexport class ModuleInjectorChain implements IModuleInjectorChain {\r\n\r\n    protected _injectors: IModuleInjector[];\r\n    get injectors(): IModuleInjector[] {\r\n        return this._injectors;\r\n    }\r\n\r\n    constructor() {\r\n        this._injectors = [];\r\n    }\r\n\r\n    first(injector: IModuleInjector) {\r\n        if (this.isInjector(injector)) {\r\n            this._injectors.unshift(injector);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    next(injector: IModuleInjector) {\r\n        if (this.isInjector(injector)) {\r\n            this._injectors.push(injector);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected isInjector(injector: IModuleInjector) {\r\n        return injector instanceof ModuleInjector;\r\n    }\r\n\r\n    async inject(container: IContainer, modules: Type<any>[]): Promise<Type<any>[]> {\r\n        let types: Type<any>[] = [];\r\n        await PromiseUtil.runInChain(this.injectors.map(jtor => {\r\n            return async (mds: Type<any>[], next?: () => Promise<void>) => {\r\n                let ijRt = await jtor.inject(container, mds);\r\n                if (ijRt.injected && ijRt.injected.length) {\r\n                    types = types.concat(ijRt.injected);\r\n                }\r\n                if (ijRt.next && ijRt.next.length > 0) {\r\n                    return next();\r\n                }\r\n            }\r\n        }), modules);\r\n        return types;\r\n    }\r\n\r\n    syncInject(container: IContainer, modules: Type<any>[]): Type<any>[] {\r\n        let types: Type<any>[] = [];\r\n        let completed = false;\r\n        this.injectors.some(jtor => {\r\n            if (jtor instanceof ModuleInjector) {\r\n                let result = jtor.syncInject(container, modules);\r\n                types = types.concat(result.injected);\r\n                completed = (!result.next || result.next.length < 1);\r\n            }\r\n            return completed;\r\n        });\r\n        return types;\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ModuleInjectorChain\",\"params\":{\"constructor\":[],\"first\":[\"injector\"],\"next\":[\"injector\"],\"isInjector\":[\"injector\"],\"inject\":[\"container\",\"modules\"],\"syncInject\":[\"container\",\"modules\"]}};\n                        }\n                   }\r\n\r\n","export * from './IModuleLoader';\r\nexport * from './DefaultModuleLoader';\r\nexport * from './IModuleValidate';\r\nexport * from './ModuleValidate';\r\nexport * from './IModuleInjector';\r\nexport * from './ModuleInjector';\r\nexport * from './IModuleInjectorChain';\r\nexport * from './ModuleInjectorChain';\r\n","import { IContainer } from './IContainer';\r\nimport { Container } from './Container';\r\nimport { Type, Modules, LoadType, Express } from './types';\r\nimport { IContainerBuilder, ContainerBuilderToken } from './IContainerBuilder';\r\nimport {\r\n    IModuleLoader, ModuleLoaderToken, DefaultModuleLoader, IModuleInjectorChain,\r\n    ModuleInjectorChainToken, IocExtModuleValidateToken, ModuleInjector, IocExtModuleValidate,\r\n    ModuleInjectorChain, ModuelValidate, ModuleValidateToken, ModuleInjectorToken\r\n} from './injectors';\r\nimport { PromiseUtil } from './utils';\r\n\r\n/**\r\n * default container builder.\r\n *\r\n * @export\r\n * @class DefaultContainerBuilder\r\n * @implements {IContainerBuilder}\r\n */\r\nexport class ContainerBuilder implements IContainerBuilder {\r\n\r\n    private _loader: IModuleLoader;\r\n    filter: Express<Type<any>, boolean>;\r\n    constructor(loader?: IModuleLoader) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    get loader(): IModuleLoader {\r\n        if (!this._loader) {\r\n            this._loader = new DefaultModuleLoader();\r\n        }\r\n\r\n        return this._loader;\r\n    }\r\n\r\n    create(): IContainer {\r\n        let container = new Container();\r\n        container.bindProvider(ContainerBuilderToken, () => this);\r\n        container.bindProvider(ModuleLoaderToken, () => this.loader);\r\n        return container;\r\n    }\r\n\r\n    /**\r\n     * build container.\r\n     *\r\n     * @param {...LoadType[]} [modules]\r\n     * @returns\r\n     * @memberof DefaultContainerBuilder\r\n     */\r\n    async build(...modules: LoadType[]) {\r\n        let container: IContainer = this.create();\r\n        if (modules.length) {\r\n            await this.loadModule(container, ...modules);\r\n        }\r\n        return container;\r\n    }\r\n\r\n    /**\r\n     * load modules for container.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {...LoadType[]} modules\r\n     * @returns {Promise<Type<any>[]>}\r\n     * @memberof DefaultContainerBuilder\r\n     */\r\n    async loadModule(container: IContainer, ...modules: LoadType[]): Promise<Type<any>[]> {\r\n        let regModules = await this.loader.loadTypes(modules);\r\n        let injTypes = [];\r\n        if (regModules && regModules.length) {\r\n            let injChain = this.getInjectorChain(container);\r\n            await PromiseUtil.step(regModules.map(typs => async () => {\r\n                let ityps = await injChain.inject(container, typs);\r\n                injTypes = injTypes.concat(ityps);\r\n            }));\r\n        }\r\n        return injTypes;\r\n    }\r\n\r\n\r\n    syncBuild(...modules: Modules[]): IContainer {\r\n        let container: IContainer = this.create();\r\n        if (modules.length) {\r\n            this.syncLoadModule(container, ...modules);\r\n        }\r\n        return container;\r\n    }\r\n\r\n    syncLoadModule(container: IContainer, ...modules: Modules[]): Type<any>[] {\r\n        let regModules = this.loader.getTypes(modules);\r\n        let injTypes: Type<any>[] = [];\r\n        if (regModules && regModules.length) {\r\n            let injChain = this.getInjectorChain(container);\r\n            regModules.forEach(typs => {\r\n                let ityps = injChain.syncInject(container, typs);\r\n                injTypes = injTypes.concat(ityps);\r\n            });\r\n        }\r\n        return injTypes;\r\n    }\r\n\r\n    getInjectorChain(container: IContainer): IModuleInjectorChain {\r\n        if (!container.has(ModuleInjectorChainToken)) {\r\n            container.register(ModuleInjector)\r\n                .bindProvider(ModuleValidateToken, new ModuelValidate())\r\n                .bindProvider(IocExtModuleValidateToken, new IocExtModuleValidate())\r\n                .bindProvider(ModuleInjectorChainToken,\r\n                    new ModuleInjectorChain()\r\n                        .next(container.resolve(ModuleInjectorToken, { provide: ModuleValidateToken, useValue: container.get(IocExtModuleValidateToken) }, { skipNext: true }))\r\n                        .next(container.resolve(ModuleInjectorToken))\r\n                );\r\n        }\r\n        return container.get(ModuleInjectorChainToken);\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"ContainerBuilder\",\"params\":{\"constructor\":[\"loader\"],\"create\":[],\"build\":[\"modules\"],\"loadModule\":[\"container\",\"modules\"],\"syncBuild\":[\"modules\"],\"syncLoadModule\":[\"container\",\"modules\"],\"getInjectorChain\":[\"container\"]}};\n                        }\n                   }\r\n","export * from './IResolver';\r\nexport * from './IContainer';\r\nexport * from './Container';\r\n\r\nexport * from './types';\r\nexport * from './Registration';\r\nexport * from './InjectReference';\r\nexport * from './InjectToken';\r\nexport * from './IContainerBuilder';\r\nexport * from './IParameter';\r\nexport * from './IMethodAccessor';\r\nexport * from './ICacheManager';\r\n\r\nexport * from './LifeScope';\r\n\r\n\r\nexport * from './ContainerBuilder';\r\n\r\nexport * from './utils';\r\nexport * from './components';\r\nexport * from './core';\r\nexport * from './injectors';\r\nexport * from './providers';\r\nexport * from './resolves';\r\n\r\n"],"names":["typeCheck_1","utils_1","types_1","components_1","NullAction_1","DecoratorFactory_1","factories_1","IContainer_1","providers_1","ICacheManager_1","IocExt_1","AutoRun_1","decorators_1","actions_1","actions","types","Singleton_1","IMetaAccessor_1","providers","LifeScope_1","core_1","resolves_1","IMethodAccessor_1","IContainerBuilder_1","require","IModuleValidate_1","IModuleInjector_1","injectors_1"],"mappings":"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"}