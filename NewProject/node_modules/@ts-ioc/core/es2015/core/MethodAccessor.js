"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const actions_1 = require("./actions");
const utils_1 = require("../utils");
const providers_1 = require("../providers");
/**
 * method accessor
 *
 * @export
 * @class MethodAccessor
 * @implements {IMethodAccessor}
 */
class MethodAccessor {
    constructor(container) {
        this.container = container;
    }
    invoke(target, propertyKey, instance, ...providers) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let targetClass;
            if (providers_1.isProvider(instance)) {
                providers.unshift(instance);
                instance = undefined;
            }
            if (utils_1.isToken(target)) {
                if (utils_1.isNullOrUndefined(instance)) {
                    targetClass = this.container.getTokenImpl(target);
                    instance = this.container.resolve(target, ...providers);
                }
                else {
                    targetClass = utils_1.lang.getClass(instance) || this.container.getTokenImpl(target);
                }
                utils_1.lang.assert(targetClass, target.toString() + ' is not implements by any class.');
            }
            else {
                targetClass = utils_1.lang.getClass(target);
                instance = target;
            }
            utils_1.lang.assertExp(instance && utils_1.isFunction(instance[propertyKey]), `type: ${targetClass} has no method ${propertyKey.toString()}.`);
            let actionData = {
                target: instance,
                targetType: targetClass,
                propertyKey: propertyKey,
            };
            let lifeScope = this.container.getLifeScope();
            lifeScope.execute(actionData, actions_1.LifeState.onInit, actions_1.CoreActions.bindParameterProviders);
            providers = providers.concat(actionData.execResult);
            let parameters = lifeScope.getMethodParameters(targetClass, instance, propertyKey);
            let paramInstances = yield this.createParams(parameters, ...providers);
            return instance[propertyKey](...paramInstances);
        });
    }
    syncInvoke(target, propertyKey, instance, ...providers) {
        let targetClass;
        if (providers_1.isProvider(instance)) {
            providers.unshift(instance);
            instance = undefined;
        }
        if (utils_1.isToken(target)) {
            targetClass = this.container.getTokenImpl(target);
            utils_1.lang.assert(targetClass, target.toString() + ' is not implements by any class.');
            if (utils_1.isNullOrUndefined(instance)) {
                instance = this.container.resolve(target, ...providers);
            }
        }
        else {
            targetClass = utils_1.lang.getClass(target);
            instance = target;
        }
        utils_1.lang.assertExp(instance && utils_1.isFunction(instance[propertyKey]), `type: ${targetClass} has no method ${propertyKey.toString()}.`);
        let actionData = {
            target: instance,
            targetType: targetClass,
            propertyKey: propertyKey,
        };
        let lifeScope = this.container.getLifeScope();
        lifeScope.execute(actionData, actions_1.LifeState.onInit, actions_1.CoreActions.bindParameterProviders);
        providers = providers.concat(actionData.execResult);
        let parameters = lifeScope.getMethodParameters(targetClass, instance, propertyKey);
        let paramInstances = this.createSyncParams(parameters, ...providers);
        return instance[propertyKey](...paramInstances);
    }
    createSyncParams(params, ...providers) {
        let providerMap = this.container.getProviderParser().parse(...providers);
        return params.map((param, index) => {
            if (param.name && providerMap.has(param.name)) {
                return providerMap.resolve(param.name);
            }
            else if (utils_1.isToken(param.type)) {
                if (providerMap.has(param.type)) {
                    return providerMap.resolve(param.type);
                }
                return this.container.resolve(param.type, providerMap);
            }
            else {
                return undefined;
            }
        });
    }
    createParams(params, ...providers) {
        let providerMap = this.container.getProviderParser().parse(...providers);
        return Promise.all(params.map((param, index) => {
            if (param.name && providerMap.has(param.name)) {
                return providerMap.resolve(param.name);
            }
            else if (utils_1.isToken(param.type)) {
                if (providerMap.has(param.type)) {
                    return providerMap.resolve(param.type);
                }
                return this.container.resolve(param.type, providerMap);
            }
            else {
                return undefined;
            }
        }));
    }
    static getClassAnnations() {
        return { "name": "MethodAccessor", "params": { "constructor": ["container"], "invoke": ["target", "propertyKey", "instance", "providers"], "syncInvoke": ["target", "propertyKey", "instance", "providers"], "createSyncParams": ["params", "providers"], "createParams": ["params", "providers"] } };
    }
}
exports.MethodAccessor = MethodAccessor;

//# sourceMappingURL=../sourcemaps/core/MethodAccessor.js.map
