"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@ts-ioc/core");
const joinpoints_1 = require("../joinpoints");
const joinpoints_2 = require("../joinpoints");
const IAdvisor_1 = require("../IAdvisor");
const IProxyMethod_1 = require("./IProxyMethod");
const IAdvisorChainFactory_1 = require("./IAdvisorChainFactory");
const NonePointcut_1 = require("../decorators/NonePointcut");
/**
 * Proxy method.
 *
 * @export
 * @class ProxyMethod
 * @implements {IProxyMethod}
 */
let ProxyMethod = class ProxyMethod {
    constructor(container) {
        this.container = container;
    }
    get advisor() {
        if (!this._advisor) {
            this._advisor = this.container.get(IAdvisor_1.AdvisorToken);
        }
        return this._advisor;
    }
    get liefScope() {
        if (!this._liefScope) {
            this._liefScope = this.container.getLifeScope();
        }
        return this._liefScope;
    }
    /**
     * proceed the proxy method.
     *
     * @param {*} target
     * @param {Type<any>} targetType
     * @param {IPointcut} pointcut
     * @param {Joinpoint} [provJoinpoint]
     * @memberof ProxyMethod
     */
    proceed(target, targetType, pointcut, provJoinpoint) {
        let aspectMgr = this.advisor;
        let fullName = pointcut.fullName;
        let methodName = pointcut.name;
        let advices = aspectMgr.getAdvices(fullName);
        if (advices && pointcut) {
            if (pointcut.descriptor && (pointcut.descriptor.get || pointcut.descriptor.set)) {
                if (pointcut.descriptor.get) {
                    let getMethod = pointcut.descriptor.get.bind(target);
                    pointcut.descriptor.get = this.proxy(getMethod, advices, target, targetType, pointcut, provJoinpoint);
                }
                if (pointcut.descriptor.set) {
                    let setMethod = pointcut.descriptor.set.bind(target);
                    pointcut.descriptor.set = this.proxy(setMethod, advices, target, targetType, pointcut, provJoinpoint);
                }
                Object.defineProperty(target, methodName, pointcut.descriptor);
            }
            else if (core_1.isFunction(target[methodName])) {
                let propertyMethod = target[methodName].bind(target);
                target[methodName] = this.proxy(propertyMethod, advices, target, targetType, pointcut, provJoinpoint);
            }
        }
    }
    proxy(propertyMethod, advices, target, targetType, pointcut, provJoinpoint) {
        let fullName = pointcut.fullName;
        let methodName = pointcut.name;
        let liefScope = this.liefScope;
        let container = this.container;
        return (...args) => {
            let joinPoint = this.container.resolve(joinpoints_2.Joinpoint, core_1.Provider.create('options', {
                name: methodName,
                fullName: fullName,
                provJoinpoint: provJoinpoint,
                annotations: provJoinpoint ? null : liefScope.getMethodMetadatas(targetType, methodName),
                params: liefScope.getMethodParameters(targetType, target, methodName),
                args: args,
                target: target,
                targetType: targetType
            }));
            let adChain = container.resolve(IAdvisorChainFactory_1.AdvisorChainFactoryToken, { container: container, advisor: this.advisor, advices: advices });
            adChain.invoaction(joinPoint, joinpoints_1.JoinpointState.Before);
            adChain.invoaction(joinPoint, joinpoints_1.JoinpointState.Pointcut);
            let val, exeErr;
            try {
                val = propertyMethod(...joinPoint.args);
            }
            catch (err) {
                exeErr = err;
            }
            adChain.invoaction(joinPoint, joinpoints_1.JoinpointState.After, val);
            if (exeErr) {
                adChain.invoaction(joinPoint, joinpoints_1.JoinpointState.AfterThrowing, exeErr);
            }
            else {
                adChain.invoaction(joinPoint, joinpoints_1.JoinpointState.AfterReturning, val);
                return joinPoint.returning;
            }
        };
    }
    static getClassAnnations() {
        return { "name": "ProxyMethod", "params": { "constructor": ["container"], "proceed": ["target", "targetType", "pointcut", "provJoinpoint"], "proxy": ["propertyMethod", "advices", "target", "targetType", "pointcut", "provJoinpoint"] } };
    }
};
ProxyMethod = tslib_1.__decorate([
    NonePointcut_1.NonePointcut(),
    core_1.Singleton(IProxyMethod_1.ProxyMethodToken),
    tslib_1.__param(0, core_1.Inject(core_1.ContainerToken)),
    tslib_1.__metadata("design:paramtypes", [Object])
], ProxyMethod);
exports.ProxyMethod = ProxyMethod;

//# sourceMappingURL=../sourcemaps/access/ProxyMethod.js.map
