"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
var IContainer_1 = require("./IContainer");
var types_1 = require("./types");
var utils_1 = require("./utils");
var Registration_1 = require("./Registration");
var IMethodAccessor_1 = require("./IMethodAccessor");
var core_1 = require("./core");
var ICacheManager_1 = require("./ICacheManager");
var IContainerBuilder_1 = require("./IContainerBuilder");
var registerCores_1 = require("./registerCores");
var resolves_1 = require("./resolves");
var InjectReference_1 = require("./InjectReference");
var LifeScope_1 = require("./LifeScope");
var providers_1 = require("./providers");
/**
 * singleton reg token.
 */
var SingletonRegToken = '___IOC__Singleton___';
/**
 * Container
 *
 * @export
 * @class Container
 * @implements {IContainer}
 */
var Container = /** @class */ (function () {
    function Container() {
        // @enumerable(false)
        this.children = [];
        this.init();
    }
    Object.defineProperty(Container.prototype, "size", {
        get: function () {
            return this.factories.size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * get root container.
     *
     * @returns {IContainer}
     * @memberof Container
     */
    Container.prototype.getRoot = function () {
        var root = this;
        while (root.parent) {
            root = root.parent;
        }
        return root;
    };
    Container.prototype.getProviderParser = function () {
        if (!this.parser) {
            this.parser = this.resolveValue(providers_1.ProviderParserToken);
        }
        return this.parser;
    };
    /**
     * get container builder.
     *
     * @returns {IContainerBuilder}
     * @memberof Container
     */
    Container.prototype.getBuilder = function () {
        return this.resolveValue(IContainerBuilder_1.ContainerBuilderToken);
    };
    /**
    * resolve token value in this container only.
    *
    * @template T
    * @param {Token<T>} token
    * @param {...ParamProviders[]} providers
    * @returns {T}
    * @memberof Container
    */
    Container.prototype.getResolvers = function () {
        return this.resolveValue(resolves_1.ResolverChainToken);
    };
    /**
     * has register the token or not.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [aliasOrway]
     * @returns {boolean}
     * @memberof Container
     */
    Container.prototype.has = function (token, aliasOrway) {
        return this.getResolvers().has(token, aliasOrway);
    };
    /**
     * has register type.
     *
     * @template T
     * @param {Token<T>} key
     * @returns
     * @memberof Container
     */
    Container.prototype.hasRegister = function (key) {
        return this.factories.has(this.getTokenKey(key));
    };
    /**
     * Retrieves an instance from the container based on the provided token.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    Container.prototype.get = function (token, alias) {
        var providers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers[_i - 2] = arguments[_i];
        }
        return this.resolve.apply(this, [alias ? this.getTokenKey(token, alias) : token].concat(providers));
    };
    /**
     * resolve type instance with token and param provider.
     *
     * @template T
     * @param {Token<T>} token
     * @param {T} [notFoundValue]
     * @param {...ParamProviders[]} providers
     * @memberof Container
     */
    Container.prototype.resolve = function (token, resway) {
        var providers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers[_i - 2] = arguments[_i];
        }
        var _a;
        return (_a = this.getResolvers()).resolve.apply(_a, [token, resway].concat(providers));
    };
    /**
     * resolve first token when not null.
     *
     * @template T
     * @param {Token<T>[]} tokens
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    Container.prototype.resolveFirst = function (tokens) {
        var _this = this;
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        var inst;
        tokens.some(function (tk) {
            inst = _this.resolve.apply(_this, [tk].concat(providers));
            return inst !== null;
        });
        return inst;
    };
    /**
     * resolve token value in this container only.
     *
     * @template T
     * @param {Token<T>} token
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    Container.prototype.resolveValue = function (token) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        var key = this.getTokenKey(token);
        if (!this.hasRegister(key)) {
            return null;
        }
        var factory = this.factories.get(key);
        return factory.apply(void 0, providers);
    };
    /**
     * get service or target reference service.
     *
     * @template T
     * @param {(Token<T> | Token<any>[])} token servive token.
     * @param {(RefTarget | RefTarget[])} [target] service refrence target.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    Container.prototype.getService = function (token, target, toRefToken, defaultToken) {
        var _this = this;
        var providers = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            providers[_i - 4] = arguments[_i];
        }
        if (utils_1.isArray(target) || utils_1.isToken(target) || utils_1.isRefTarget(target) || utils_1.isTypeObject(target)) {
            var tokens_1 = [];
            (utils_1.isArray(token) ? token : [token]).forEach(function (tk) {
                tokens_1.push(tk);
                if (!utils_1.isClass(tk)) {
                    tokens_1.push(_this.getTokenImpl(tk));
                }
            });
            var fac_1;
            var defToken = void 0;
            var prds = [];
            if (utils_1.isBoolean(toRefToken)) {
                if (toRefToken) {
                    defToken = token;
                }
                else {
                    defToken = null;
                }
            }
            else if (utils_1.isToken(toRefToken)) {
                defToken = toRefToken;
            }
            else if (utils_1.isFunction(toRefToken)) {
                fac_1 = toRefToken;
                if (utils_1.isBoolean(defaultToken)) {
                    if (defaultToken) {
                        defToken = token;
                    }
                    else {
                        defToken = null;
                    }
                }
                else if (utils_1.isToken(defaultToken)) {
                    defToken = defaultToken;
                }
                else if (defaultToken) {
                    prds.push(defaultToken);
                }
            }
            else if (toRefToken) {
                prds.unshift(toRefToken);
            }
            defToken = defToken === null ? null : (defToken || token);
            prds = prds.concat(providers);
            return this.getRefService.apply(this, [tokens_1.map(function (tk) { return { service: tk, isPrivate: true }; }).concat(fac_1 ? [function (tk) { return fac_1(tk); }] : [], tokens_1.map(function (t) { return function (tk) { return new InjectReference_1.InjectReference(t, tk); }; })), target,
                defToken].concat(prds));
        }
        else {
            return this.resolveFirst.apply(this, [utils_1.isArray(token) ? token : [token]].concat([target, toRefToken, defaultToken].concat(providers).filter(function (a) { return a; })));
        }
    };
    /**
     * get target reference service.
     *
     * @template T
     * @param {Type<Registration<T>>} [refToken] reference service Registration Injector
     * @param {RefTarget | RefTarget[]} target  the service reference to.
     * @param {Token<T>} [defaultToken] default service token.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    Container.prototype.getRefService = function (refToken, target, defaultToken) {
        var _this = this;
        var providers = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            providers[_i - 3] = arguments[_i];
        }
        var service = null;
        (utils_1.isArray(target) ? target : [target])
            .some(function (tag) {
            _this.forInRefTarget(tag, function (tk) {
                // exclude ref registration.
                if (InjectReference_1.isInjectReference(tk)) {
                    return true;
                }
                return !(utils_1.isArray(refToken) ? refToken : [refToken]).some(function (stk) {
                    var tokens = _this.getRefToken(stk, tk);
                    return (utils_1.isArray(tokens) ? tokens : [tokens]).some(function (rtk) {
                        service = _this.resolveRef.apply(_this, [rtk, tk].concat(providers));
                        return service !== null;
                    });
                });
            });
            return service !== null;
        });
        if (!service && defaultToken) {
            service = this.resolveFirst.apply(this, [utils_1.isArray(defaultToken) ? defaultToken : [defaultToken]].concat(providers));
        }
        return service;
    };
    /**
     * get all service extends type and reference target.
     *
     * @template T
     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.
     * @param {(Token<any> | Token<any>[])} [target] service refrence target.
     * @param {(boolean|ParamProviders)} [both]
     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    Container.prototype.getServices = function (token, target, both, resway) {
        var providers = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            providers[_i - 4] = arguments[_i];
        }
        var services = [];
        this.iteratorServices.apply(this, [function (tk, fac, resolver) {
                var pds = [];
                for (var _i = 3; _i < arguments.length; _i++) {
                    pds[_i - 3] = arguments[_i];
                }
                services.push(fac.apply(void 0, pds));
            }, token, target, both, resway].concat(providers));
        return services;
    };
    /**
     * get all service extends type and reference target.
     *
     * @template T
     * @param {(tk: ClassType<T>, fac: InstanceFactory<T>, resolvor?: IResolver, ...providers: ParamProviders[]) => void | boolean} express
     * @param {(Token<T> | ((token: ClassType<T>) => boolean))} type servive token or express match token.
     * @param {(Token<any> | Token<any>[])} [target] service refrence target.
     * @param {(boolean|ParamProviders)} [both]
     * @param {(boolean|ParamProviders)} [both] get services bubble up to parent container.
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof IContainer
     */
    Container.prototype.iteratorServices = function (express, token, target, both, resway) {
        var _this = this;
        var providers = [];
        for (var _i = 5; _i < arguments.length; _i++) {
            providers[_i - 5] = arguments[_i];
        }
        var withTag;
        var rway = IContainer_1.ResoveWay.all;
        var withBoth = false;
        var matchExp;
        if (utils_1.isToken(token)) {
            var type_1 = utils_1.isClassType(token) ? token : this.getTokenImpl(token);
            matchExp = function (tk) { return utils_1.lang.isExtendsClass(tk, type_1); };
        }
        else if (utils_1.isFunction(token)) {
            matchExp = token;
        }
        if (utils_1.isNumber(resway)) {
            rway = resway;
        }
        else {
            providers.unshift(resway);
        }
        if (utils_1.isToken(target) || utils_1.isArray(target)) {
            withTag = true;
            if (utils_1.isBoolean(both)) {
                withBoth = both;
            }
            else if (utils_1.isNumber(both)) {
                rway = both;
            }
            else {
                providers.unshift(both);
            }
            var tags_1 = (utils_1.isArray(target) ? target : [target]).map(function (t) {
                if (utils_1.isClass(t)) {
                    return t;
                }
                else if (utils_1.isAbstractClass(t)) {
                    return t;
                }
                else {
                    return _this.getTokenImpl(t);
                }
            });
            // target private service.
            this.getResolvers().toArray().some(function (resolver) {
                return tags_1.some(function (tg) {
                    var priMapTk = new InjectReference_1.InjectReference(providers_1.ProviderMap, tg);
                    if (resolver.has(priMapTk, IContainer_1.ResoveWay.nodes)) {
                        var priMap_1 = resolver.resolve(priMapTk, IContainer_1.ResoveWay.nodes);
                        return priMap_1.keys().some(function (ptk) {
                            if (utils_1.isClassType(ptk) && matchExp(ptk)) {
                                return express.apply(void 0, [ptk, priMap_1.get(ptk), priMap_1].concat(providers)) !== false;
                            }
                            return false;
                        });
                    }
                    return false;
                });
            });
        }
        else {
            if (utils_1.isNumber(target)) {
                rway = target;
            }
            else {
                providers.unshift(target);
            }
            withTag = false;
        }
        if (!withTag || (withTag && withBoth)) {
            this.iterator(function (tk, fac, resolver) {
                if (utils_1.isClassType(tk) && matchExp(tk)) {
                    return express.apply(void 0, [tk, fac, resolver].concat(providers));
                }
            }, rway);
        }
    };
    /**
     * iterator all registered factory
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>, resolvor?: IResolver) => void | boolean} callbackfn
     * @param {ResoveWay} [resway= ResoveWay.all]
     * @memberof Container
     */
    Container.prototype.iterator = function (callbackfn, resway) {
        if (resway === void 0) { resway = IContainer_1.ResoveWay.all; }
        this.getResolvers().iterator(callbackfn, resway);
    };
    /**
     * iterator.
     *
     * @param {(tk: Token<any>, fac: InstanceFactory<any>) => void | boolean} callbackfn
     * @memberof IExports
     */
    Container.prototype.forEach = function (callbackfn) {
        var _this = this;
        return !Array.from(this.factories.keys()).some(function (tk) {
            return callbackfn(tk, _this.factories.get(tk), _this) === false;
        });
    };
    Container.prototype.getRefToken = function (ref, tk) {
        if (Registration_1.isRegistrationClass(ref)) {
            return new ref(tk);
        }
        if (utils_1.isToken(ref)) {
            return ref;
        }
        if (utils_1.isFunction(ref)) {
            return ref(tk);
        }
        return ref;
    };
    Container.prototype.resolveRef = function (refToken, target) {
        var providers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers[_i - 2] = arguments[_i];
        }
        var tk;
        var isPrivate = false;
        if (utils_1.isToken(refToken)) {
            tk = refToken;
        }
        else {
            tk = refToken.service;
            isPrivate = refToken.isPrivate !== false;
        }
        if (!tk) {
            return null;
        }
        // resolve private first.
        if (utils_1.isClass(target) && !InjectReference_1.isInjectReference(tk)) {
            var pdrmap = this.resolve(new InjectReference_1.InjectReference(providers_1.ProviderMap, target));
            if (pdrmap && pdrmap.has(tk)) {
                return pdrmap.resolve.apply(pdrmap, [tk].concat(providers));
            }
        }
        // have not private registered.
        if (isPrivate) {
            return null;
        }
        return this.resolve.apply(this, [tk].concat(providers));
    };
    /**
     * get tocken key.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @returns {SymbolType<T>}
     * @memberof Container
     */
    Container.prototype.getTokenKey = function (token, alias) {
        if (alias) {
            return new Registration_1.Registration(token, alias).toString();
        }
        else if (token instanceof Registration_1.Registration) {
            return token.toString();
        }
        return token;
    };
    /**
     * register type.
     * @abstract
     * @template T
     * @param {Token<T>} token
     * @param {T} [value]
     * @returns {this}
     * @memberOf Container
     */
    Container.prototype.register = function (token, value) {
        this.registerFactory(token, value);
        return this;
    };
    /**
     * register stingleton type.
     * @abstract
     * @template T
     * @param {Token<T>} token
     * @param {Factory<T>} [value]
     * @returns {this}
     * @memberOf Container
     */
    Container.prototype.registerSingleton = function (token, value) {
        this.registerFactory(token, value, true);
        return this;
    };
    /**
     * register value.
     *
     * @template T
     * @param {Token<T>} token
     * @param {T} value
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.registerValue = function (token, value) {
        var _this = this;
        var key = this.getTokenKey(token);
        this.getSingleton().set(key, value);
        if (!this.factories.has(key)) {
            this.factories.set(key, function () {
                return _this.getSingleton().get(key);
            });
        }
        return this;
    };
    /**
     * bind provider.
     *
     * @template T
     * @param {Token<T>} provide
     * @param {Token<T>} provider
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.bindProvider = function (provide, provider) {
        var _this = this;
        var provideKey = this.getTokenKey(provide);
        var factory;
        if (utils_1.isToken(provider)) {
            factory = function () {
                var providers = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    providers[_i] = arguments[_i];
                }
                return _this.resolve.apply(_this, [provider].concat(providers));
            };
        }
        else {
            if (utils_1.isFunction(provider)) {
                factory = function () {
                    var providers = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        providers[_i] = arguments[_i];
                    }
                    return provider.apply(void 0, [_this].concat(providers));
                };
            }
            else {
                factory = function () {
                    return provider;
                };
            }
        }
        if (utils_1.isClass(provider)) {
            if (!this.has(provider)) {
                this.register(provider);
            }
            this.provideTypes.set(provideKey, provider);
        }
        else if (utils_1.isToken(provider)) {
            var token = provider;
            while (this.provideTypes.has(token) && !utils_1.isClass(token)) {
                token = this.provideTypes.get(token);
                if (utils_1.isClass(token)) {
                    this.provideTypes.set(provideKey, token);
                    break;
                }
            }
        }
        this.factories.set(provideKey, factory);
        return this;
    };
    /**
     * bind providers for only target class.
     *
     * @param {Token<any>} target
     * @param {ParamProviders[]} providers
     * @param {(mapTokenKey: Token<any>) => void} [onceBinded]
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.bindProviders = function (target, onceBinded) {
        var _this = this;
        var providers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            providers[_i - 2] = arguments[_i];
        }
        var _a;
        var tgt;
        var complete;
        var prods = providers;
        if (utils_1.isFunction(onceBinded)) {
            complete = onceBinded;
        }
        else if (onceBinded) {
            prods.unshift(onceBinded);
        }
        if (utils_1.isToken(target)) {
            tgt = target;
        }
        else if (target) {
            tgt = null;
            prods.unshift(target);
        }
        var maps = (_a = this.getProviderParser()).parse.apply(_a, prods);
        if (tgt) {
            var refKey = new InjectReference_1.InjectReference(providers_1.ProviderMap, utils_1.isClass(tgt) ? tgt : this.getTokenImpl(tgt));
            if (this.hasRegister(refKey)) {
                this.resolveValue(refKey).copy(maps);
            }
            else {
                this.bindProvider(refKey, maps);
                complete && complete(refKey);
            }
        }
        else {
            maps.keys().forEach(function (key) {
                utils_1.isToken(key) && _this.factories.set(key, function () {
                    var prds = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        prds[_i] = arguments[_i];
                    }
                    return maps.resolve.apply(maps, [key].concat(prds));
                });
            });
        }
        return this;
    };
    /**
     * bind provider ref to target.
     *
     * @template T
     * @param {Token<any>} target
     * @param {Token<T>} provide
     * @param {(Token<T> | Factory<T>)} provider
     * @param {string} [alias]
     * @param {(refToken: Token<T>) => void} [onceBinded]
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.bindRefProvider = function (target, provide, provider, alias, onceBinded) {
        var refToken = new InjectReference_1.InjectReference(this.getTokenKey(provide, alias), target);
        this.bindProvider(refToken, provider);
        onceBinded && onceBinded(refToken);
        return this;
    };
    Container.prototype.unregisterValue = function (token) {
        var key = this.getTokenKey(token);
        if (this.hasRegister(key)) {
            this.factories.delete(key);
            if (this.provideTypes.has(key)) {
                this.provideTypes.delete(key);
            }
            if (utils_1.isClass(key)) {
                this.clearCache(key);
            }
        }
        return this;
    };
    /**
     * unregister the token
     *
     * @template T
     * @param {Token<T>} token
     * @param {ResoveWay} [resway]
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.unregister = function (token, resway) {
        this.getResolvers().unregister(token, resway);
        return this;
    };
    /**
     * clear cache.
     *
     * @param {Type<any>} targetType
     * @memberof IContainer
     */
    Container.prototype.clearCache = function (targetType) {
        this.resolveValue(ICacheManager_1.CacheManagerToken).destroy(targetType);
    };
    /**
     * get token.
     *
     * @template T
     * @param {Token<T>} token
     * @param {string} [alias]
     * @returns {Token<T>}
     * @memberof Container
     */
    Container.prototype.getToken = function (token, alias) {
        if (alias) {
            return new Registration_1.Registration(token, alias);
        }
        return token;
    };
    Container.prototype.getTokenProvider = function (token) {
        if (utils_1.isClass(token)) {
            return token;
        }
        var tokenKey = this.getTokenKey(token);
        if (this.provideTypes.has(tokenKey)) {
            return this.provideTypes.get(tokenKey);
        }
        return null;
    };
    /**
     * get token implements class type.
     *
     * @template T
     * @param {Token<T>} token
     * @param {boolean} [inchain]
     * @returns {Type<T>}
     * @memberof Container
     */
    Container.prototype.getTokenImpl = function (token, resway) {
        return this.getResolvers().getTokenImpl(token, resway);
    };
    /**
     * iterate token  in  token class chain.  return false will break iterate.
     *
     * @param {RefTarget} target
     * @param {(token: Token<any>) => boolean} express
     * @memberof Container
     */
    Container.prototype.forInRefTarget = function (target, express) {
        var _this = this;
        var type;
        var token;
        var level;
        if (utils_1.isToken(target)) {
            token = target;
            level = types_1.RefTagLevel.all;
        }
        else if (target) {
            if (utils_1.isRefTarget(target)) {
                token = target.target;
                level = target.level || types_1.RefTagLevel.self;
            }
            else if (utils_1.isTypeObject(target)) {
                token = utils_1.lang.getClass(target);
                level = types_1.RefTagLevel.all;
            }
        }
        if (!utils_1.isToken(token)) {
            return;
        }
        if (utils_1.isClassType(token)) {
            type = token;
            if (utils_1.isClass(type) && !this.has(type)) {
                this.use(type);
            }
        }
        else {
            type = this.getTokenImpl(token);
        }
        if (!utils_1.isClassType(token) || (types_1.RefTagLevel.self === level)) {
            express(token);
            return;
        }
        var inChain = (level & types_1.RefTagLevel.chain) > 0;
        var inProviders = (level & types_1.RefTagLevel.providers) > 0;
        utils_1.lang.forInClassChain(type, function (ty) {
            var tokens;
            if (inProviders) {
                var prdKey = new InjectReference_1.InjectClassProvidesToken(ty);
                var prds = _this.get(prdKey);
                if (prds && prds.provides && prds.provides.length) {
                    var ppdkey_1 = prdKey.toString();
                    var pmapKey_1 = new InjectReference_1.InjectReference(providers_1.ProviderMap, ty).toString();
                    tokens = prds.provides.slice(1).filter(function (p) {
                        var key = _this.getTokenKey(p);
                        return key !== ppdkey_1 && key !== pmapKey_1;
                    });
                }
            }
            tokens = tokens || [];
            return !(tokens.concat(ty).some(function (tk) { return express(tk) === false; })) && inChain;
        });
    };
    /**
     * get token implement class and base classes.
     *
     * @param {Token<any>} token
     * @returns {Token<any>[]}
     * @memberof Container
     */
    Container.prototype.getTokenClassChain = function (token, chain) {
        if (chain === void 0) { chain = true; }
        var tokens = [];
        this.forInRefTarget(token, function (tk) {
            tokens.push(tk);
            return chain;
        });
        return tokens;
    };
    /**
    * get life scope of container.
    *
    * @returns {LifeScope}
    * @memberof IContainer
    */
    Container.prototype.getLifeScope = function () {
        return this.get(LifeScope_1.LifeScopeToken);
    };
    /**
     * use modules.
     *
     * @param {...Modules[]} modules
     * @returns {this}
     * @memberof Container
     */
    Container.prototype.use = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        var _a;
        (_a = this.getBuilder()).syncLoadModule.apply(_a, [this].concat(modules));
        return this;
    };
    /**
     * async use modules.
     *
     * @param {...LoadType[]} modules load modules.
     * @returns {Promise<Type<any>[]>}  types loaded.
     * @memberof IContainer
     */
    Container.prototype.loadModule = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        var _a;
        return (_a = this.getBuilder()).loadModule.apply(_a, [this].concat(modules));
    };
    /**
     * invoke method async.
     *
     * @template T
     * @param {any} target
     * @param {string} propertyKey
     * @param {*} [instance]
     * @param {...ParamProviders[]} providers
     * @returns {Promise<T>}
     * @memberof Container
     */
    Container.prototype.invoke = function (target, propertyKey, instance) {
        var providers = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            providers[_i - 3] = arguments[_i];
        }
        var _a;
        return (_a = this.resolveValue(IMethodAccessor_1.MethodAccessorToken)).invoke.apply(_a, [target, propertyKey, instance].concat(providers));
    };
    /**
     * invoke method.
     *
     * @template T
     * @param {any} target
     * @param {string} propertyKey
     * @param {*} [instance]
     * @param {...ParamProviders[]} providers
     * @returns {T}
     * @memberof Container
     */
    Container.prototype.syncInvoke = function (target, propertyKey, instance) {
        var providers = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            providers[_i - 3] = arguments[_i];
        }
        var _a;
        return (_a = this.resolveValue(IMethodAccessor_1.MethodAccessorToken)).syncInvoke.apply(_a, [target, propertyKey, instance].concat(providers));
    };
    Container.prototype.createSyncParams = function (params) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        var _a;
        return (_a = this.resolveValue(IMethodAccessor_1.MethodAccessorToken)).createSyncParams.apply(_a, [params].concat(providers));
    };
    Container.prototype.createParams = function (params) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        var _a;
        return (_a = this.resolveValue(IMethodAccessor_1.MethodAccessorToken)).createParams.apply(_a, [params].concat(providers));
    };
    Container.prototype.cacheDecorator = function (map, action) {
        if (!map.has(action.name)) {
            map.set(action.name, action);
        }
    };
    Container.prototype.init = function () {
        var _this = this;
        this.factories = new Map();
        this.provideTypes = new Map();
        this.bindProvider(IContainer_1.ContainerToken, function () { return _this; });
        registerCores_1.registerCores(this);
    };
    Container.prototype.getSingleton = function () {
        if (!this.hasRegister(SingletonRegToken)) {
            this.bindProvider(SingletonRegToken, new Map());
        }
        return this.resolveValue(SingletonRegToken);
    };
    Container.prototype.registerFactory = function (token, value, singleton) {
        var key = this.getTokenKey(token);
        if (this.factories.has(key)) {
            return;
        }
        var classFactory;
        if (!utils_1.isUndefined(value)) {
            if (utils_1.isFunction(value)) {
                if (utils_1.isClass(value)) {
                    this.bindTypeFactory(key, value, singleton);
                }
                else {
                    classFactory = this.createCustomFactory(key, value, singleton);
                }
            }
            else if (singleton && value !== undefined) {
                classFactory = this.createCustomFactory(key, function () { return value; }, singleton);
            }
        }
        else if (!utils_1.isString(token) && !utils_1.isSymbol(token)) {
            var ClassT = (token instanceof Registration_1.Registration) ? token.getClass() : token;
            if (utils_1.isClass(ClassT)) {
                this.bindTypeFactory(key, ClassT, singleton);
            }
        }
        if (classFactory) {
            this.factories.set(key, classFactory);
        }
    };
    Container.prototype.createCustomFactory = function (key, factory, singleton) {
        var _this = this;
        return singleton ?
            function () {
                var providers = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    providers[_i] = arguments[_i];
                }
                if (_this.getSingleton().has(key)) {
                    return _this.getSingleton().get(key);
                }
                var instance = factory.apply(void 0, [_this].concat(providers));
                _this.getSingleton().set(key, instance);
                return instance;
            }
            : function () {
                var providers = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    providers[_i] = arguments[_i];
                }
                return factory.apply(void 0, [_this].concat(providers));
            };
    };
    Container.prototype.bindTypeFactory = function (key, ClassT, singleton) {
        var _this = this;
        if (!Reflect.isExtensible(ClassT)) {
            return;
        }
        var lifeScope = this.getLifeScope();
        var parameters = lifeScope.getConstructorParameters(ClassT);
        if (!singleton) {
            singleton = lifeScope.isSingletonType(ClassT);
        }
        var factory = function () {
            var providers = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                providers[_i] = arguments[_i];
            }
            var _a;
            if (singleton && _this.getSingleton().has(key)) {
                return _this.getSingleton().get(key);
            }
            if (providers.length < 1) {
                var lifecycleData = {
                    tokenKey: key,
                    targetType: ClassT,
                    // raiseContainer: this,
                    singleton: singleton
                };
                lifeScope.execute(lifecycleData, core_1.CoreActions.cache);
                if (lifecycleData.execResult && lifecycleData.execResult instanceof ClassT) {
                    return lifecycleData.execResult;
                }
            }
            var providerMap = (_a = _this.getProviderParser()).parse.apply(_a, providers);
            lifeScope.execute({
                tokenKey: key,
                targetType: ClassT,
                raiseContainer: _this,
                params: parameters,
                providers: providers,
                providerMap: providerMap,
                singleton: singleton
            }, types_1.IocState.runtime, core_1.LifeState.beforeCreateArgs);
            var args = _this.createSyncParams(parameters, providerMap);
            lifeScope.routeExecute({
                tokenKey: key,
                targetType: ClassT,
                raiseContainer: _this,
                args: args,
                params: parameters,
                providers: providers,
                providerMap: providerMap,
                singleton: singleton
            }, types_1.IocState.runtime, core_1.LifeState.beforeConstructor);
            var instance = new (ClassT.bind.apply(ClassT, [void 0].concat(args)))();
            lifeScope.routeExecute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: _this,
                args: args,
                params: parameters,
                providers: providers,
                providerMap: providerMap,
                singleton: singleton
            }, types_1.IocState.runtime, core_1.LifeState.afterConstructor);
            lifeScope.execute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: _this,
                args: args,
                params: parameters,
                providers: providers,
                providerMap: providerMap,
                singleton: singleton
            }, types_1.IocState.runtime, core_1.LifeState.onInit);
            lifeScope.routeExecute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: _this,
                args: args,
                params: parameters,
                providers: providers,
                providerMap: providerMap,
                singleton: singleton
            }, types_1.IocState.runtime, core_1.LifeState.AfterInit);
            lifeScope.execute({
                tokenKey: key,
                target: instance,
                targetType: ClassT,
                raiseContainer: _this
            }, core_1.CoreActions.cache);
            return instance;
        };
        this.factories.set(key, factory);
        lifeScope.routeExecute({
            tokenKey: key,
            targetType: ClassT,
            raiseContainer: this
        }, types_1.IocState.design);
    };
    Container.getClassAnnations = function () {
        return { "name": "Container", "params": { "constructor": [], "getRoot": [], "getProviderParser": [], "getBuilder": [], "getResolvers": [], "has": ["token", "aliasOrway"], "hasRegister": ["key"], "get": ["token", "alias", "providers"], "resolve": ["token", "resway", "providers"], "resolveFirst": ["tokens", "providers"], "resolveValue": ["token", "providers"], "getService": ["token", "target", "toRefToken", "defaultToken", "providers"], "getRefService": ["refToken", "target", "defaultToken", "providers"], "getServices": ["token", "target", "both", "resway", "providers"], "iteratorServices": ["express", "token", "target", "both", "resway", "providers"], "iterator": ["callbackfn", "resway"], "forEach": ["callbackfn"], "getRefToken": ["ref", "tk"], "resolveRef": ["refToken", "target", "providers"], "getTokenKey": ["token", "alias"], "register": ["token", "value"], "registerSingleton": ["token", "value"], "registerValue": ["token", "value"], "bindProvider": ["provide", "provider"], "bindProviders": ["target", "onceBinded", "providers"], "bindRefProvider": ["target", "provide", "provider", "alias", "onceBinded"], "unregisterValue": ["token"], "unregister": ["token", "resway"], "clearCache": ["targetType"], "getToken": ["token", "alias"], "getTokenProvider": ["token"], "getTokenImpl": ["token", "resway"], "forInRefTarget": ["target", "express"], "getTokenClassChain": ["token", "chain"], "getLifeScope": [], "use": ["modules"], "loadModule": ["modules"], "invoke": ["target", "propertyKey", "instance", "providers"], "syncInvoke": ["target", "propertyKey", "instance", "providers"], "createSyncParams": ["params", "providers"], "createParams": ["params", "providers"], "cacheDecorator": ["map", "action"], "init": [], "getSingleton": [], "registerFactory": ["token", "value", "singleton"], "createCustomFactory": ["key", "factory", "singleton"], "bindTypeFactory": ["key", "ClassT", "singleton"] } };
    };
    return Container;
}());
exports.Container = Container;

//# sourceMappingURL=sourcemaps/Container.js.map
