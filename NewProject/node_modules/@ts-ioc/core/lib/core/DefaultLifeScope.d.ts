import { LifeScope, DecorSummary } from '../LifeScope';
import { Type, Express } from '../types';
import { MethodMetadata } from './metadatas';
import { IContainer } from '../IContainer';
import { ActionComponent } from './actions';
import { DecoratorType } from './factories';
import { ActionData } from './ActionData';
import { IParameter } from '../IParameter';
/**
 * default implement life scope.
 *
 * @export
 * @class DefaultLifeScope
 * @implements {LifeScope}
 */
export declare class DefaultLifeScope implements LifeScope {
    private container;
    decorators: DecorSummary[];
    action: ActionComponent;
    constructor(container: IContainer);
    addAction(action: ActionComponent, ...nodepaths: string[]): this;
    registerDecorator(decorator: Function, ...actions: string[]): this;
    registerCustomDecorator(decorator: Function, type: DecoratorType, ...actions: string[]): this;
    execute<T>(data: ActionData<T>, ...names: string[]): void;
    routeExecute<T>(data: ActionData<T>, ...names: string[]): void;
    hasDecorator(target: Type<any> | any, dtype: DecoratorType, match?: Express<DecorSummary, boolean>): boolean;
    getClassDecorators(type: Type<any>, match?: Express<DecorSummary, boolean>): DecorSummary[];
    getMethodDecorators(type: Type<any>, match?: Express<DecorSummary, boolean>): DecorSummary[];
    getPropertyDecorators(type: Type<any>, match?: Express<DecorSummary, boolean>): DecorSummary[];
    getParameterDecorators(target: any, propertyKey: string, match?: Express<DecorSummary, boolean>): DecorSummary[];
    getDecoratorType(decirator: any): DecoratorType;
    /**
     * is vaildate dependence type or not. dependence type must with class decorator.
     *
     * @template T
     * @param {Type<T>} target
     * @returns {boolean}
     * @memberof Container
     */
    isVaildDependence<T>(target: Type<T>): boolean;
    getAtionByName(name: string): ActionComponent;
    getClassAction(): ActionComponent;
    getMethodAction(): ActionComponent;
    getPropertyAction(): ActionComponent;
    getParameterAction(): ActionComponent;
    /**
     * get constructor parameters metadata.
     *
     * @template T
     * @param {Type<T>} type
     * @returns {IParameter[]}
     * @memberof IContainer
     */
    getConstructorParameters<T>(type: Type<T>): IParameter[];
    /**
     * get method params metadata.
     *
     * @template T
     * @param {Type<T>} type
     * @param {T} instance
     * @param {(string | symbol)} propertyKey
     * @returns {IParameter[]}
     * @memberof IContainer
     */
    getMethodParameters<T>(type: Type<T>, instance: T, propertyKey: string): IParameter[];
    /**
     * get paramerter names.
     *
     * @template T
     * @param {Type<T>} type
     * @param {string} propertyKey
     * @returns {string[]}
     * @memberof DefaultLifeScope
     */
    getParamerterNames<T>(type: Type<T>, propertyKey: string): string[];
    isSingletonType<T>(type: Type<T>): boolean;
    getMethodMetadatas<T>(type: Type<T>, propertyKey: string): MethodMetadata[];
    filerDecorators(express?: Express<DecorSummary, boolean>): DecorSummary[];
    protected getParameters<T>(type: Type<T>, instance?: T, propertyKey?: string): IParameter[];
    protected getTypeDecorators(decType: string, match?: Express<DecorSummary, boolean>): DecorSummary[];
    protected buildAction(): void;
    toActionName(type: DecoratorType): string;
    static getClassAnnations(): any;
}
