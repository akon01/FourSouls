{"version":3,"sources":["core/actions/MethodAutorun.ts"],"names":[],"mappings":";;AAEA,uDAAoD;AAEpD,uCAA6C;AAC7C,+CAA4C;AAC5C,4CAAoE;AACpE,8CAAwC;AAexC;;;;;;GAMG;AACH,MAAa,aAAc,SAAQ,iCAAe;IAE9C;QACI,KAAK,CAAC,yBAAW,CAAC,aAAa,CAAC,CAAA;IACpC,CAAC;IAES,OAAO,CAAC,SAAqB,EAAE,IAA6B;QAClE,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,KAAK,SAAS,EAAE;YAC1D,OAAO;SACV;QACD,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,EAAE;YAChC,IAAI,6BAAiB,CAAC,oBAAO,EAAE,IAAI,CAAC,UAAU,CAAC,EAAE;gBAC7C,IAAI,KAAK,GAAG,6BAAiB,CAAkB,oBAAO,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;gBACzE,IAAI,SAAS,GAAsB,EAAE,CAAC;gBACtC,IAAI,GAAG,GAAG,YAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC;gBAClC,YAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,GAAW,EAAE,EAAE;oBAClC,IAAI,EAAE,IAAI,EAAE,CAAC,MAAM,EAAE;wBACjB,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;wBACd,CAAC,CAAC,OAAO,GAAG,GAAG,CAAC;wBAChB,GAAG,EAAE,CAAC;wBACN,IAAI,CAAC,gBAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;4BACpB,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC;yBACjB;wBACD,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;qBACrB;gBACL,CAAC,CAAC,CAAC;gBAEH,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;oBACxB,OAAO,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC;gBACjC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;oBACb,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;gBACnF,CAAC,CAAC,CAAC;aACN;SAEJ;IACL,CAAC;IAEmB,MAAM,CAAC,iBAAiB;QACpB,OAAO,EAAC,MAAM,EAAC,eAAe,EAAC,QAAQ,EAAC,EAAC,aAAa,EAAC,EAAE,EAAC,SAAS,EAAC,CAAC,WAAW,EAAC,MAAM,CAAC,EAAC,EAAC,CAAC;IAC/F,CAAC;CACL;AAxCpB,sCAwCoB","file":"../../../core/actions/MethodAutorun.js","sourcesContent":["import { ActionData } from '../ActionData';\r\nimport { AutorunMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { lang, isNumber } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\nimport { hasMethodMetadata, getMethodMetadata } from '../factories';\r\nimport { Autorun } from '../decorators';\r\n\r\n\r\n\r\n/**\r\n * auto run action data.\r\n *\r\n * @export\r\n * @interface AutorunActionData\r\n * @extends {ActionData<AutorunMetadata>}\r\n */\r\nexport interface MethodAutorunActionData extends ActionData<AutorunMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * Inject DrawType action.\r\n *\r\n * @export\r\n * @class SetPropAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class MethodAutorun extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.methodAutorun)\r\n    }\r\n\r\n    protected working(container: IContainer, data: MethodAutorunActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.target && data.targetType) {\r\n            if (hasMethodMetadata(Autorun, data.targetType)) {\r\n                let metas = getMethodMetadata<AutorunMetadata>(Autorun, data.targetType);\r\n                let lastmetas: AutorunMetadata[] = [];\r\n                let idx = lang.keys(metas).length;\r\n                lang.forIn(metas, (mm, key: string) => {\r\n                    if (mm && mm.length) {\r\n                        let m = mm[0];\r\n                        m.autorun = key;\r\n                        idx++;\r\n                        if (!isNumber(m.order)) {\r\n                            m.order = idx;\r\n                        }\r\n                        lastmetas.push(m);\r\n                    }\r\n                });\r\n\r\n                lastmetas.sort((au1, au2) => {\r\n                    return au1.order - au1.order;\r\n                }).forEach(aut => {\r\n                    container.syncInvoke(data.target || data.targetType, aut.autorun, data.target);\r\n                });\r\n            }\r\n\r\n        }\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"MethodAutorun\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                        }\n                   }\r\n\r\n"]}