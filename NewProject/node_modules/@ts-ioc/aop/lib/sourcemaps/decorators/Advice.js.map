{"version":3,"sources":["decorators/Advice.ts"],"names":[],"mappings":";;AACA,qCAA8H;AAoD9H,SAAgB,qBAAqB,CAA2B,UAAkB,EAC9E,OAAyB,EACzB,oBAAsC,EACtC,eAAoC;IAEpC,OAAO,4BAAqB,CAAiB,QAAQ,EACjD,UAAA,IAAI;QACA,IAAI,OAAO,EAAE;YACT,OAAO,CAAC,IAAI,CAAC,CAAC;SACjB;QACD,IAAI,CAAC,IAAI,CAAiB;YACtB,KAAK,EAAE,UAAC,GAAG,IAAK,OAAA,eAAQ,CAAC,GAAG,CAAC,IAAI,eAAQ,CAAC,GAAG,CAAC,EAA9B,CAA8B;YAC9C,WAAW,EAAE,UAAC,QAAQ,EAAE,GAAG;gBACvB,QAAQ,CAAC,QAAQ,GAAG,GAAG,CAAC;YAC5B,CAAC;SACJ,CAAC,CAAC;QACH,IAAI,oBAAoB,EAAE;YACtB,oBAAoB,CAAC,IAAI,CAAC,CAAC;SAC9B;QAED,IAAI,CAAC,IAAI,CAAiB;YACtB,KAAK,EAAE,UAAC,GAAG,IAAK,OAAA,eAAQ,CAAC,GAAG,CAAC,EAAb,CAAa;YAC7B,WAAW,EAAE,UAAC,QAAQ,EAAE,GAAG;gBACvB,QAAQ,CAAC,iBAAiB,GAAG,GAAG,CAAC;YACrC,CAAC;SACJ,CAAC,CAAC;QAEH,IAAI,CAAC,IAAI,CAAiB;YACtB,KAAK,EAAE,UAAC,GAAG,IAAK,OAAA,eAAQ,CAAC,GAAG,CAAC,EAAb,CAAa;YAC7B,WAAW,EAAE,UAAC,QAAQ,EAAE,GAAG;gBACvB,QAAQ,CAAC,cAAc,GAAG,GAAG,CAAC;YAClC,CAAC;SACJ,CAAC,CAAC;IACP,CAAC,EACD,UAAA,QAAQ;QACJ,IAAI,eAAe,EAAE;YACjB,eAAe,CAAC,QAAa,CAAC,CAAC;SAClC;QACD,QAAQ,CAAC,UAAU,GAAG,UAAU,CAAC;QACjC,OAAO,QAAQ,CAAC;IACpB,CAAC,CAAwB,CAAC;AAClC,CAAC;AAzCD,sDAyCC;AAED;;;;GAIG;AACU,QAAA,MAAM,GAAqC,qBAAqB,CAAC,QAAQ,CAAC,CAAC","file":"../../decorators/Advice.js","sourcesContent":["\r\nimport { createMethodDecorator, IMethodDecorator, MetadataAdapter, MetadataExtends, isString, isRegExp  } from '@ts-ioc/core';\r\nimport { AdviceMetadata } from '../metadatas';\r\n\r\n/**\r\n * advice decorator for method.\r\n *\r\n * @export\r\n * @interface IAdviceDecorator\r\n * @extends {IMethodDecorator<T>}\r\n * @template T\r\n */\r\nexport interface IAdviceDecorator<T extends AdviceMetadata> extends IMethodDecorator<T> {\r\n    /**\r\n     * define advice with params.\r\n     *\r\n     * ### Usage\r\n     * - path or module name, match express.\r\n     *  - `execution(moduelName.*.*(..)) || @annotation(DecortorName) || @within(ClassName)`\r\n     *  - `execution(moduelName.*.*(..)) && @annotation(DecortorName) && @within(ClassName)`\r\n     *\r\n     * ```\r\n     * @Aspect()\r\n     * class AspectClass {\r\n     *   @Advice('\"execution(moduelName.*.*(..)\")')\r\n     *   process(joinPoint: JointPoint){\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * - match method with a decorator annotation.\r\n     *\r\n     * ```\r\n     * @Aspect()\r\n     * class AspectClass {\r\n     *   @Advice('@annotation(DecoratorName)')\r\n     *   process(joinPoint: JointPoint){\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * @param {(string | RegExp)} [pointcut] define advice match express for pointcut.\r\n     * @param { string } [annotation] annotation name, special annotation metadata for annotation advices.\r\n     */\r\n    (pointcut?: string | RegExp, annotation?: string): MethodDecorator;\r\n\r\n    /**\r\n     * define advice with metadata map.\r\n     * @param {T} [metadata]\r\n     */\r\n    (metadata?: T): MethodDecorator;\r\n}\r\n\r\nexport function createAdviceDecorator<T extends AdviceMetadata>(adviceName: string,\r\n    adapter?: MetadataAdapter,\r\n    afterPointcutAdapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IAdviceDecorator<T> {\r\n\r\n    return createMethodDecorator<AdviceMetadata>('Advice',\r\n        args => {\r\n            if (adapter) {\r\n                adapter(args);\r\n            }\r\n            args.next<AdviceMetadata>({\r\n                match: (arg) => isString(arg) || isRegExp(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.pointcut = arg;\r\n                }\r\n            });\r\n            if (afterPointcutAdapter) {\r\n                afterPointcutAdapter(args);\r\n            }\r\n\r\n            args.next<AdviceMetadata>({\r\n                match: (arg) => isString(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.annotationArgName = arg;\r\n                }\r\n            });\r\n\r\n            args.next<AdviceMetadata>({\r\n                match: (arg) => isString(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.annotationName = arg;\r\n                }\r\n            });\r\n        },\r\n        metadata => {\r\n            if (metadataExtends) {\r\n                metadataExtends(metadata as T);\r\n            }\r\n            metadata.adviceName = adviceName;\r\n            return metadata;\r\n        }) as IAdviceDecorator<T>;\r\n}\r\n\r\n/**\r\n * aop advice decorator.\r\n *\r\n * @Advice\r\n */\r\nexport const Advice: IAdviceDecorator<AdviceMetadata> = createAdviceDecorator('Advice');\r\n"]}