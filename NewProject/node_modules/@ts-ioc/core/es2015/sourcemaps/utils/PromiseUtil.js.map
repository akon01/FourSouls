{"version":3,"sources":["utils/PromiseUtil.ts"],"names":[],"mappings":"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","file":"../../utils/PromiseUtil.js","sourcesContent":["import { isFunction } from './typeCheck';\r\nimport { Express } from '../types';\r\n\r\n\r\n/**\r\n * defer\r\n *\r\n * @export\r\n * @class Defer\r\n * @template T\r\n */\r\nexport class Defer<T> {\r\n    static create<T>(then?: (val: T) => T | PromiseLike<T>): Defer<T> {\r\n        let defer = new Defer<T>();\r\n        if (then) {\r\n            defer.promise = defer.promise.then(then);\r\n            return defer;\r\n        } else {\r\n            return defer;\r\n        }\r\n    }\r\n    /**\r\n     * promise.\r\n     *\r\n     * @type {Promise<T>}\r\n     * @memberof Defer\r\n     */\r\n    promise: Promise<T>\r\n    /**\r\n     * resolve.\r\n     *\r\n     * @memberof Defer\r\n     */\r\n    resolve: (value?: T | PromiseLike<T>) => void;\r\n    /**\r\n     * reject.\r\n     *\r\n     * @memberof Defer\r\n     */\r\n    reject: (reason?: any) => void;\r\n\r\n    constructor() {\r\n        this.promise = new Promise<T>((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n\n                        static getClassAnnations():any  {\n                            return {\"name\":\"Defer\",\"params\":{\"create\":[\"then\"],\"constructor\":[]}};\n                        }\n                   }\r\n\r\n/**\r\n * promise util.\r\n */\r\nexport namespace PromiseUtil {\r\n\r\n    /**\r\n     * create defer.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {((val: T) => T | PromiseLike<T>)} [then]\r\n     * @returns {Defer<T>}\r\n     */\r\n    export function defer<T>(then?: (val: T) => T | PromiseLike<T>): Defer<T> {\r\n        return Defer.create(then);\r\n    }\r\n\r\n    /**\r\n     * foreach opter for promises.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\r\n     * @param {Express<T, any>} express\r\n     * @param {T} [defVal]\r\n     * @returns\r\n     */\r\n    export function forEach<T>(promises: (T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[], express: Express<T, any>, defVal?: T) {\r\n        let defer = new Defer<string>();\r\n        let pf = Promise.resolve<T>(defVal);\r\n        let length = promises ? promises.length : 0;\r\n\r\n        if (length) {\r\n            promises.forEach((p, idx) => {\r\n                pf = pf.then(v => isFunction(p) ? p(v) : p)\r\n                    .then(data => {\r\n                        if (express(data) === false) {\r\n                            defer.resolve('complete');\r\n                            return Promise.reject<T>('complete');\r\n                        } else if (idx === length - 1) {\r\n                            defer.resolve('complete');\r\n                            return Promise.reject<T>('complete');\r\n                        }\r\n                        return data;\r\n                    });\r\n            });\r\n            pf.catch(err => {\r\n                return err;\r\n            });\r\n        } else {\r\n            defer.reject('array empty.');\r\n        }\r\n        return defer.promise;\r\n    }\r\n\r\n    /**\r\n     * run promise step by step.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\r\n     * @returns\r\n     */\r\n    export function step<T>(promises: (T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[]) {\r\n        let result = Promise.resolve<T>(null);\r\n        promises.forEach(p => {\r\n            result = result.then(v => isFunction(p) ? p(v) : p);\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * find first validate value from promises.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {(...(T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\r\n     * @param {Express<T, boolean>} validate\r\n     * @returns\r\n     */\r\n    export function find<T>(promises: (T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[], filter: Express<T, boolean>, defVal?: T) {\r\n        let defer = new Defer<T>();\r\n        forEach(promises, val => {\r\n            if (filter(val)) {\r\n                defer.resolve(val);\r\n                return false;\r\n            }\r\n            return true;\r\n        }, defVal)\r\n            .then(() => defer.resolve(null))\r\n            .catch(() => {\r\n                defer.resolve(null)\r\n            });\r\n        return defer.promise;\r\n    }\r\n\r\n    /**\r\n     *  action handle.\r\n     */\r\n    export type ActionHandle<T> = (ctx: T, next?: () => Promise<void>) => Promise<void>;\r\n\r\n    /**\r\n     * run action in chain.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {ActionHandle<T>[]} handles\r\n     * @param {T} ctx\r\n     * @param {() => Promise<void>} [next]\r\n     * @returns {Promise<void>}\r\n     */\r\n    export function runInChain<T>(handles: ActionHandle<T>[], ctx: T, next?: () => Promise<void>): Promise<void> {\r\n        let index = -1;\r\n        return dispatch(0);\r\n        function dispatch(idx: number): Promise<any> {\r\n            if (idx <= index) {\r\n                return Promise.reject('next called mutiple times');\r\n            }\r\n            index = idx;\r\n            let handle = idx < handles.length ? handles[idx] : null;\r\n            if (idx === handles.length) {\r\n                handle = next;\r\n            }\r\n            if (!handle) {\r\n                return Promise.resolve();\r\n            }\r\n            try {\r\n                return Promise.resolve(handle(ctx, dispatch.bind(null, idx + 1)));\r\n            } catch (err) {\r\n                return Promise.reject(err);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n"]}