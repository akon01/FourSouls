"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ActionComposite_1 = require("./ActionComposite");
const utils_1 = require("../../utils");
const CoreActions_1 = require("./CoreActions");
const factories_1 = require("../factories");
const AutoRun_1 = require("../decorators/AutoRun");
const IocExt_1 = require("../decorators/IocExt");
/**
 * Inject DrawType action.
 *
 * @export
 * @class SetPropAction
 * @extends {ActionComposite}
 */
class AutorunAction extends ActionComposite_1.ActionComposite {
    constructor() {
        super(CoreActions_1.CoreActions.autorun);
    }
    getDecorator() {
        return [IocExt_1.IocExt, AutoRun_1.Autorun];
    }
    working(container, data) {
        if (data.raiseContainer && data.raiseContainer !== container) {
            return;
        }
        if (data.tokenKey && data.targetType) {
            let decorators = this.getDecorator();
            decorators.forEach(decorator => {
                if (factories_1.hasClassMetadata(decorator, data.targetType)) {
                    let metas = factories_1.getTypeMetadata(decorator, data.targetType);
                    let meta = metas.find(it => !!it.autorun);
                    if (!meta && metas.length) {
                        meta = metas[0];
                    }
                    if (meta) {
                        let instance = container.get(data.tokenKey);
                        if (instance && meta.autorun && utils_1.isFunction(instance[meta.autorun])) {
                            container.syncInvoke(instance, meta.autorun);
                        }
                    }
                }
            });
        }
    }
    static getClassAnnations() {
        return { "name": "AutorunAction", "params": { "constructor": [], "getDecorator": [], "working": ["container", "data"] } };
    }
}
exports.AutorunAction = AutorunAction;

//# sourceMappingURL=../../sourcemaps/core/actions/AutorunAction.js.map
